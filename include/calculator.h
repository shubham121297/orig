#include <boost/config.hpp> /* keep it first to prevent nasty warns in MSVC */
#include <utility>
#include <pthread.h>
#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>
#include <boost/interprocess/sync/scoped_lock.hpp>
#include <boost/interprocess/allocators/allocator.hpp>
#include <boost/interprocess/containers/string.hpp>
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/lockfree/spsc_queue.hpp> // ring buffer
#include <utility>
#include <iostream>
#include <string>
#include <sstream>
#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/allocators/allocator.hpp>
#include <boost/interprocess/containers/string.hpp>
#include <boost/interprocess/shared_memory_object.hpp>
#include <algorithm>
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <iterator>
#include <unistd.h>
#include <vector>
/* Binary Tree */
#include <string.h>
#include <bits/stdc++.h>

#include <cstddef>

#include <string.h>
#include <bits/stdc++.h>
#include <stdio.h>      /* printf */
#include <math.h>       /* floor */
#include <iostream>

#include <occi.h>




using namespace oracle::occi;

using namespace std;
using namespace boost;
using boost::multi_index_container;
using namespace boost::multi_index;
namespace bip = boost::interprocess;
const long unsigned int QUEUECAPACITY = 10000000;
bip::managed_shared_memory::size_type OSRMCAPACITY = 40000000000;

namespace shm
{
typedef bip::allocator<char, bip::managed_shared_memory::segment_manager> char_alloc;
typedef bip::basic_string<char, std::char_traits<char>, char_alloc >   shared_string;
typedef boost::lockfree::spsc_queue<
		std::pair<int,shm::shared_string>,
		boost::lockfree::capacity<QUEUECAPACITY>
> ring_buffer;
typedef boost::lockfree::spsc_queue<
		std::tuple<int,shm::shared_string,shm::shared_string>,
		boost::lockfree::capacity<QUEUECAPACITY>
> ring_buffer2;

}

bool is_number(const std::string& s)
{
	return !s.empty() && std::find_if(s.begin(),
			s.end(), [](char c) { return !std::isdigit(c); }) == s.end();
}


enum class TripAction
{
	//0 = ready
			//1 = batch
			//2 = FB/Assign
			//3 = in the process of assigning

	READY,
	BATCH,
	FB,
	ASSIGN

};


/*
       enum class Color
    {
        RED,
        BLUE
    };
     //if (color == Color::RED)


    Color color = Color::BLUE;

    std::cout << color; // won't work, because there's no implicit conversion to int
    std::cout << static_cast<int>(color); // will print 1

    return 0;

 */





#include <iostream>
#include <cctype>
#include <algorithm>
using namespace std;
//int DEBUG = 1;
//int DEBUGSTATE = 1;
const string CONFIGFILE = "/usr/local/bin/configFarm.txt";
const string CONFIGLOGS = "/usr/local/bin/configLogs.txt";
//MAXTRIPIDX = 52000
//MAXCLUSTERS = 3000
//TREESIZE = 100000
const int MAXNUMOFALREADYTRIED = 1000;
const int MAXCLIENTS = 55;
const int MAXOSRM = 3;
const int MAXSTOPS = 500;
const int MAXSEGMENTS = 500;
const int MAXTRIPIDX = 5000;
const int MAXREQUESTS = 5000;

/*
void SetSiteTripSize(string size){
    //cout << "Set site trip size " << endl;
    if(size == "LARGE"){
        siteTripSize = 5000;
    }
    else if(size == "MEDIUM"){
        siteTripSize = 3000; 
    }
    else if(size == "SMALL"){
        siteTripSize  = 1000; 
    }
    //cout << siteTripSize  << endl;
}
const int& MAXTRIPIDX = siteTripSize; //black magic to get around having to set a "constant" array size
const int& MAXREQUESTS = siteTripSize; //black magic to get around having to set a "constant" array size
 */
/*if(siteSize == "LARGE"){
const int MAXTRIPIDX = a; 
const int MAXREQUESTS = 5000;
}
else if(siteSize == "MEDIUM"){
const int MAXTRIPIDX = 3000; 
const int MAXREQUESTS = 3000; 
}
else if(siteSize == "SMALL"){
const int MAXTRIPIDX = 1000; 
const int MAXREQUESTS = 1000; 
}*/
const int MAXNUMTOPROCESSMONITOR = 1000;
const int MAXTIMESLOTS = 96;
const int MAXCLUSTERS = 3000; // 1500 //3000-------------
const int MAXTC_COLUMNSIZE = 1000; /// number of tripidx per cluster per timeslot
const int MAXTS_COLUMNSIZE = 200;
const int TREESIZE = 50000; //50000 //200000 -----------------
const int TRIPCOLSIZE = 100;
const int MAXLGSTRSIZE = 200; // 200 -- old value
const int MAXVYLGSTRSIZE = 400000; ///allows ~25000 edges if each edge is about 10 characters.
const int MAXNUMBOFROUTE = 3000;
/// should be at least equal to the max number of trips to be inserted into the unprocess table at any given time
const int MAXREQUESTCOL = 6; //0 access request number if there is one |1 tripid| 2request lat long |3 distance |4 edges| 5 tripindicies
const int MAXPROCESSESCOL = 3;
const int NUMBEROFPROCESSES = 15;
const int LOADDB = 1;
const int OSRMSTATUS = 2;
const int ACCESS = 3;
const int MONITOR = 4;
const int FB = 5;
const int SLACKPROCESS = 6;
const int TIME_BATCH = 7;
const int RECALCSTATUS = 8;
const int DBWRITE = 9;
const int WRITINGFB = 1;
const int FINALIZEBATCH = 10;
const int BATCHRUNNING = 11;
const int NUMBEROFTRIPSSCHEDULED = 12;
const int GROUPBUILDER = 13;
const int EXCLUSIONINCLUSIONCHARSIZE = 5000;
const int MAXTREEINDEXSTRSIZE = 20000;
const int MAXAVLTOPSCOLUMNSIZE = 7;






struct Tree
{
	//EdgeInfo data;
	unsigned long long  id = -1;
	char index_str[MAXTREEINDEXSTRSIZE] = "0";
	bool available;
	int left = -1;
	int right = -1;  
	int parent = -1; 
	char dummy[1] = "";
};
Tree *root;
char (*shm_edgeids)[MAXVYLGSTRSIZE];
char (*schd_tab)[TRIPCOLSIZE][MAXLGSTRSIZE];
char (*schd_tab_unprocess)[TRIPCOLSIZE][MAXLGSTRSIZE];
char (*schd_tab_delete)[TRIPCOLSIZE][MAXLGSTRSIZE];
// char (*fb_tab)[2000][500];
int (*s_tab)[MAXSTOPS];

int (*ts_tab)[MAXCLUSTERS][2][MAXTC_COLUMNSIZE];
int (*tc_tab)[MAXTC_COLUMNSIZE];
char (*process_tab)[MAXPROCESSESCOL][MAXLGSTRSIZE];
char (*shared_process_tab)[MAXPROCESSESCOL][MAXLGSTRSIZE];
char (*request_number)[MAXLGSTRSIZE];
char (*request_numberofedges)[MAXLGSTRSIZE];
char (*request_id)[MAXLGSTRSIZE];
char (*request_latlon)[MAXLGSTRSIZE];
char (*request_distance)[MAXLGSTRSIZE];
char (*request_time)[MAXLGSTRSIZE];
char (*request_edges)[MAXVYLGSTRSIZE];
char (*request_tripidx)[MAXVYLGSTRSIZE];
char (*request_function)[MAXLGSTRSIZE];
char (*request_timestamp)[MAXLGSTRSIZE];

char (*avl_tops)[MAXAVLTOPSCOLUMNSIZE][MAXLGSTRSIZE]; //Hui, 01-FEB-21; 0: segment_id, 1: lat, 2: lng, 3: record_time




char MILITARYTIME = 'F';
const int SLACK = 1;
const int UNASSIGNED = 0;
const int DIRTYBIT = 49;
const int OPER_ID = 50;
const int EARLIEST_ARR = 51;
const int LATEST_DEP = 52;
const int SITE = 53;
const int ORIG_PROMTIME = 54;
const int NEIGHBORS = 55;
const int PICKUPIDX = 56;
const int ACTION = 57;
const int INCLUDESEG = 0;
const int EXCLUDESEG = 1;
const int SKIPTS = 59;
const int GRPIDX = 60;
const int PWWAIT = 61;
const int DWWAIT = 62;
const int DISPOSITION = 63;
const int CURRENTODO = 64;
const int PUODO = 65;
const int DOODO = 66;
const int LATEDEVIATION = 67;
const int TRVLTIMEDEVIATION = 68;
const int TIMESTAMP = 69;
const int NUMBEROFSLACKATTEMPTS = 70;
const int WHICHAPPLICATION = 71;
const int WHICHSEGMENT = 72;
const int CLIENTID = 73;
const int OB_TRIP_ID = 74;
const int GROUPNUMBER = 75;
const int INUSEFLAG = 76;
const int INUSEUSER = 77;
const int ASSIGNMENTPROCESS = 78;
const int CALCULATEDTIME = 79;
const int WEIGHT = 80;
const int CS_OCC = 81;
const int BS_OCC = 82;
const int SEGMENTTYPE = 83;
const int BUILTEXCLUSION = 84;
const int FARE = 85;
const int TEMPINCLUDEDSEG = 99;
const int PRM_TIME = 4;
const int LAT = 10;
const int LON = 37;
const int ETA = 29;
const int ETD = 30;
const int ESTDIST = 21;
const int AMB = 31;
const int WC =  32;
const int SUGG_RES_NUM = 45;
const int MONITOR1 = 1;
const int FILE1 = 0;
int semaphore = 0;
const int MAXZONES = 15;
const int RETURNTRIP = 18;
const int SHMID = 20;

const int VELOCITY = 10;
const int ZONE = 15;
const int MAXSMSTRSIZE = 10;
const int SCHEDZONE = 50; //Hui, maximum number of scheduleing zones allowed in itms_registry.

const int STOP_NUM = 2;
const int ARRIVE_TIME = 23;
const int DEPART_TIME = 24;
const int START_TIME = 26;
const int DESIRED_END_TIME = 27;
const int RES_NUM = 0;
const int TIME_TO_NEXT_STOP = 28;
const int DIST_TO_NEXT_STOP = 6;
const int DISABILITY = 12;
const int TRIP_ID = 3;
const int PROM_TIME = 4;


string numberofedges;
string osrm_shm;
string username;
string password;
string port;
char connectString[300];

key_t key_V_VEL_PT;
key_t key_V_VEL_WT;
key_t key_V_VEL_LT;
key_t key_V_VEL_ET;
key_t key_V_VEL_NT;
key_t key_V_VEL_HT;
key_t key_velocityMaxDist;
key_t key_velocityMinDist;
key_t key_zone;
key_t key_starttime;
key_t key_endtime;
key_t  keyreq;


key_t keyu; //key for sched table unprocess
key_t key; // key for sched table to be updated
key_t keyd; // key for delete table
key_t keyf;
key_t keys;
key_t keye;
key_t keyt;
key_t keytc;
key_t keyr;
key_t keyrnum;
key_t keyrid;
key_t  keyrlatlong;
key_t  keyrdist;
key_t  keyredge;
key_t keyrtime;
key_t   keyrtripidx;
key_t  keyfunc;
key_t  keytime;
//11122 can be used for shared access keys
key_t  key_shared_process;

double  (*V_VEL_PT)  ;
double (*V_VEL_WT)   ;
double (*V_VEL_LT)   ;
double  (*V_VEL_ET)   ;
double (*V_VEL_NT);
double (*V_VEL_HT)   ;
int (*velocityMaxDist);
int (*velocityMinDist);
char (*zone)[MAXSMSTRSIZE];
int (*starttime);
int (*endtime);






key_t key_IGNORE_DEPOTS_CUTOFF;
key_t key_p_WHEELLOAD;
key_t key_p_AMBLOAD;
key_t key_p_MAXEARLYDROPOFFFACTOR;
key_t key_p_DIALRIDEEARLYPICKFACTOR;
key_t key_p_DIALRIDELATEPICKFACTOR;
key_t key_p_OTHEREARLYPICKFACTOR;
key_t key_p_OTHERLATEPICKFACTOR;
key_t key_ignorepu;
key_t key_p_SHORTBREAK;
key_t key_p_LUNCHBREAK;
key_t key_p_PROXIMITYFACTOR;
key_t key_ZONE_DESCR;
key_t key_a_mediumshortdistance;
key_t key_a_shorttriptime;
key_t key_a_longtriptime;
key_t key_a_mediumtriptime;
key_t key_a_mediumlongdistance;
key_t key_a_extra_loadtime;
key_t key_number_of_edges;
key_t key_OPENSEGSTHRESHOLD;
key_t key_numberofedges ;
key_t key_SLACKTHRESHOLD ;
key_t key_ACALCULATE_GCOUNT_WC;
key_t key_PERCENTAGETOSTOPBATCH;
key_t key_EXTRAGRPTT;
key_t key_USEREVERSECALC;
key_t key_MAXDEADHEADVARIANCE;
key_t key_XTRTRAVTIME;
key_t key_headhome;
key_t key_exclusioninclusion;
key_t key_exclusioninclusionlist;
key_t key_sameoutboundpreassignment;
key_t key_maxstopnum;
key_t key_fb_threshold;
key_t key_extra_slack;
key_t key_relax_constraints;
key_t key_cs_cap_agency;
key_t key_cs_cap_vol;
key_t key_bs_cap_agency;
key_t key_bs_cap_vol;
key_t key_dw_sml;
key_t key_dw_med;
key_t key_dw_lng;

key_t key_avl_tops; //Hui, 01-FEB-21


int (*cs_cap_agency);
int (*cs_cap_vol);
int (*bs_cap_agency);
int (*bs_cap_vol);

char(*MAXSTOPNUM)[MAXSMSTRSIZE];
int (*exclu_inclu)[MAXSEGMENTS];
char (*exclusioninclusionlist)[2][EXCLUSIONINCLUSIONCHARSIZE];
string siteSize;

double (*HEADHOMETHRESHOLD);
double (*EXTRASLACK);
double (*RELAXCONSTRAINTS);
double (*MAXDEADHEADVARIANCE);
double (*PERCENTAGETOSTOPBATCH);
char (*ACALCULATE_GCOUNT_WC)[MAXSMSTRSIZE];
char (*IGNORE_DEPOTS_CUTOFF)[MAXSMSTRSIZE];
char (*USEREVERSECALC)[MAXSMSTRSIZE];
char (*SAMEOUTBOUNDPREASSIGNMENT)[MAXSMSTRSIZE];

double (*DW_VARIANCE_CHECK_SML) ;
double (*DW_VARIANCE_CHECK_MED) ;
double (*DW_VARIANCE_CHECK_LNG) ;

double (*OPEN_SEG_THRESHOLD) ;
double (*XTRTRAVTIME);
double (*SLACK_THRESHOLD) ;
double (*FB_THRESHOLD) ;
int (*EXTRAGRPTT) ;
int (*NUMBER_OF_EDGES) ;
int (*p_WHEELLOAD) ;
int (*p_AMBLOAD);
int (*p_MAXEARLYDROPOFFFACTOR) ;
int (*p_DIALRIDEEARLYPICKFACTOR);
int (*p_DIALRIDELATEPICKFACTOR) ;
int (*p_OTHEREARLYPICKFACTOR);
int (*p_OTHERLATEPICKFACTOR);
char (*ignorepu)[MAXSMSTRSIZE];
int (*p_SHORTBREAK);
int (*p_LUNCHBREAK);
int (*p_PROXIMITYFACTOR);
char (*ZONE_DESCR)[MAXSMSTRSIZE];
double (*a_mediumshortdistance) ;
int (*a_shorttriptime);
int (*a_longtriptime) ;
int (*a_mediumtriptime) ;
double (*a_mediumlongdistance);
int (*a_extra_loadtime) ;

int aMaxTripTime;
int aPerfTime;
int aLastPickTime;
int aEarlyPickTime;
int aLastDropTime ;
int aEarlyDropTime;
int  aEstPickTime;
string FIXEDBOOL;



int DEBUG;
int DEBUGSTATE;
int DEBUGACCESS;
int DEBUGLAUNCHER;
int DEBUGBATCH;
int DEBUGBUILDGRPS;
int DEBUGCALC;
int DEBUGCHECKINCL;
int DEBUGCLEANALL;
int DEBUGCLEARSCR;
int DEBUGSYSSERV;
int DEBUGDBWRITE;
int DEBUGFB;
int DEBUGFB2;
int DEBUGFINAL;
int DEBUGALLFIXED;
int DEBUGKILLALLFIXED;
int DEBUGKILLALLPROG;
int DEBUGKILLCLIENTDATE;
int DEBUGKILLPROC;
int DEBUGMONITOR;
int DEBUGORACLEBAT;
int DEBUGPRINT;
int DEBUGPRINTPROCSTAT;
int DEBUGPRINTXML;
int DEBUGRESTARTDB;
int DEBUGREVERSE;
int DEBUGSEARCHNOTRIP;
int DEBUGSLACK;
int DEBUGSWITCHBRD;
int DEBUGSYNC;
int DEBUGTIMEBATCH;
int DEBUGVERSION;
int DEBUGVIEWSCR;
int DEBUGVIEWTAB;
int DEBUGROUTED;


shm::shared_string to_shared_string(string str,shm::char_alloc char_alloc){
	shm::shared_string shared(str.c_str(), char_alloc);
	return shared;
}


ofstream gse;
string filename = "hbssgseout.txt";
ofstream logstatechange;
string aFileName = "";

void f_cout(string filename2){

	if(!gse.is_open())
		//gse.open(filename2,fstream::out | fstream::app);
	gse.open(filename2);


}

void s_cout(string theFilename){
	if(!logstatechange.is_open())
	{
		aFileName = theFilename;
		logstatechange.open(aFileName,fstream::out | fstream::app);
		// logstatechange.open(theFilename);
	}

}

//Hui 02-Sep-2020, write timestampe into log files.
std::string getCurrentDateTime()
{
	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	// printf("%d-%02d-%02d %02d:%02d:%02d\n ", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
	char* datetime = (char*)malloc(13 * sizeof(char));
	sprintf(datetime, "%d-%02d-%02d %02d:%02d:%02d ", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
	std::string datetimestr = datetime;
	// std::cout << datetimestr << "Some logs here" << std::endl;
	return datetimestr;
}

std::string getCurrentDateTimeMilSecs()
{
	struct timespec ts;
	// timespec_get(&ts, TIME_UTC);
	clock_gettime(CLOCK_REALTIME, &ts);
	char buff[100];
	strftime(buff, sizeof buff, "%D %T", gmtime(&ts.tv_sec));
	// printf("Producer-Consumer Test started: %s.%09ld UTC\n", buff, ts.tv_nsec);
	sprintf(buff, "%s.%09ld ", buff, ts.tv_nsec);
	std::string datetimestr = (string)buff;
	return datetimestr;
}
#define gse gse << getCurrentDateTimeMilSecs()
#define logstatechange logstatechange << getCurrentDateTimeMilSecs()


string table_itms_trips;
string table_itms_segments;
string ip;
string servicename;
string LOGDIR = "/var/log/";
string MAPDIR = "/home/hbss/"; //Wherever the /Deployment folder is (eg: /home/hbss/Deployment/osrm/data/map.osrm)
string BATCHMACHINE = "N";
//string APPLICATIONDIR = "/usr/local/bin/";


double to_number(string str){
	double toint;
	if(str == "")
		return 0;
	else{
		stringstream ss(str);
		ss >> toint;
		return toint;
	}
}




string GetStdoutFromCommand(string cmd) {

	string data;
	FILE * stream;
	const int max_buffer = 20000;
	char buffer[max_buffer];
	//cmd.append(" 2>&1");

	stream = popen(cmd.c_str(), "r");

	if (stream) {
		while (!feof(stream)){
			if (fgets(buffer, max_buffer, stream) != NULL) { data.append(buffer);}
			if(fgets(buffer, max_buffer, stream) == "\n") break;
		}
		pclose(stream);
	}
	return data;
}

string GetStdoutFromCommandSWITCHBOARD(string cmd) {

	string data;
	FILE * stream;
	const int max_buffer = 2000000;
	char buffer[max_buffer];
	string buffer1;
	//cmd.append(" 2>&1");

	cmd = cmd + " 2>&1";

	stream = popen(cmd.c_str(), "r");
	if(DEBUG == 1) gse << "cmd " << cmd << endl;

	if (stream) {
		while (!feof(stream)){

			fgets(buffer, max_buffer, stream);
			buffer1 = buffer;
			if(DEBUG == 1) gse << "buffer " << buffer1 << endl;

			if (buffer != NULL ) {

				if(buffer1.substr(0,9)=="FINALCOUT"){
					data.append(buffer);
					if(DEBUG == 1) gse << "data " <<  data  << endl;
					break;
				}
			}
			else{
				if(DEBUG == 1) gse << "NULL BUFFER" << endl;
			}
			if(buffer == "\n") {  if(DEBUG == 1) gse << "found endline" <<endl; break;}
		}
		pclose(stream);
	}
	return data;
}


//JDC The function below has not been modified to include CONFIGLOGS since 1) it is only used in routed.cpp and the functions checkfixedroutedata, initshm, and checkdaily
//JDC where it is commented out, and 2) routed.cpp currently has no debug flags associated with it.
void initosrmshm(string osrm_shm){

	ifstream myfile (CONFIGFILE);
	string line;
	if (myfile.is_open())
	{
		while(getline (myfile,line)){
			if(line == "OSRM"+osrm_shm){
				getline (myfile,line);
				keyrnum = (int)to_number(line); getline (myfile,line);
				keyrid = (int)to_number(line); getline (myfile,line);
				keyrlatlong = (int)to_number(line); getline (myfile,line);
				keyrdist = (int)to_number(line); getline (myfile,line);
				keyredge = (int)to_number(line); getline (myfile,line);
				keyrtripidx = (int)to_number(line); getline (myfile,line);
				keyfunc = (int)to_number(line); getline (myfile,line);
				keytime = (int)to_number(line); getline (myfile,line);
				key_shared_process = (int)to_number(line); getline (myfile,line);
				key_number_of_edges = (int)to_number(line); getline (myfile,line);
			}
		}
		myfile.close();
	}


}

string GetStdoutFromCommand_nolinebreak(string cmd) {

	string data;
	FILE * stream;
	const int max_buffer = 10000;
	char buffer[max_buffer];
	//cmd.append(" 2>&1");

	stream = popen(cmd.c_str(), "r");
	if (stream) {
		while (!feof(stream)){
			if (fgets(buffer, max_buffer, stream) != NULL) data.append(buffer);
			//if(fgets(buffer, max_buffer, stream) == "\n") break;
		}
		pclose(stream);
	}
	return data;
}

string getNextToken(string *str, string delimiter){

	size_t pos = 0;
	std::string token = "";

	while ((pos = str->find(delimiter)) != std::string::npos) {

		// if(DEBUG == 1) gse << "start " << str->length()<< endl;
		token = str->substr(0, pos);
		str->erase(0, pos + delimiter.length());
		// if(DEBUG == 1) gse << "end " << str->length()<< " token " << token <<  endl;
		return token;
	}
	if((pos = str->find(delimiter)) == std::string::npos){
		token = *str;
		str->erase(0, str->length());
		return token;
	}
	return token;
}

bool checkfixedroutedata(){

	ifstream logfile (CONFIGLOGS);
	string line;
	bool foundclient = false;
	bool foundFlag = false;
	if (logfile.is_open())
	{
		while(getline (logfile,line)){

			if(line == "DIRECTORIES"){
				getline (logfile,line);
				LOGDIR = line; getline (logfile,line);
				MAPDIR = line; getline (logfile,line);
			}

			if(line == "CLIENT"){
				getline (logfile,line);
				string client = line;
				foundclient = true;
				pid_t pid = getpid();
				string requestName;
				string processName;
				/*//JDC "ps -p <pid> -o comm=" sometimes returns "sh" as the process, depending on how the process was launched.
				  //JDC Seems to occur with the use of "nohup".  Also, ps (ubuntu linux) has a longstanding problem of truncating
				  //JDC process names to 15 characters.  Both of these necessitate the use of a different approach
				  //JDC to acquiring the process name.
				requestName = "ps -p " + to_string(pid) +  " -o comm=";
				processName = GetStdoutFromCommand(requestName); //JDC This always leaves a \n at the end of the string
				processName.erase(std::remove(processName.begin(), processName.end(), '\n'), processName.end());
				*/
				string throwaway;

				requestName = "ps " + to_string(pid) + " | grep 'GSE_'"; //JDC LIMITATION: This assumes processes are run from a folder that begins with "GSE_"
				processName = GetStdoutFromCommand(requestName);
				throwaway=getNextToken(&(processName),"GSE_"); //JDC Launched processes include the Path, e.g., /usr/local/bin/GSE_LARGE
				throwaway=getNextToken(&(processName),"/");
				processName = getNextToken(&(processName)," "); //JDC This assumes there is always a space at the end of the process name.
				processName.erase(std::remove(processName.begin(), processName.end(), '\n'), processName.end()); //JDC If there is no space then there will be a \n

				string candidateName;

				getline (logfile,line);
				candidateName=getNextToken(&(line),"=");
				DEBUG = (int) to_number(getNextToken(&(line),";"));
				getline(logfile,line);
				candidateName=getNextToken(&(line),"=");
				DEBUGSTATE = (int) to_number(getNextToken(&(line),";"));
				string debugFlag;
				int flagValue;
				while(getline (logfile,line)){
					candidateName = getNextToken(&(line),":");
					debugFlag = getNextToken(&(line),"=");
					flagValue = (int) to_number(getNextToken(&(line),";"));
					if (candidateName == processName) {
						if (debugFlag == "DEBUGACCESS"){
							DEBUGACCESS=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGLAUNCHER"){
							DEBUGLAUNCHER=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGBATCH"){
							DEBUGBATCH=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGBUILDGRPS"){
							DEBUGBUILDGRPS=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCALC"){
							DEBUGCALC=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCHECKINCL"){
							DEBUGCHECKINCL=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCLEANALL"){
							DEBUGCLEANALL=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCLEARSCR"){
							DEBUGCLEARSCR=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSYSSERV"){
							DEBUGSYSSERV=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGDBWRITE"){
							DEBUGDBWRITE=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGFB"){
							DEBUGFB=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGFB2"){
							DEBUGFB2=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGFINAL"){
							DEBUGFINAL=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLALLFIXED"){
							DEBUGKILLALLFIXED=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLALLPROG"){
							DEBUGKILLALLPROG=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLCLIENTDATE"){
							DEBUGKILLCLIENTDATE=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLPROC"){
							DEBUGKILLPROC=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGMONITOR"){
							DEBUGMONITOR=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGORACLEBAT"){
							DEBUGORACLEBAT=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGPRINT"){
							DEBUGPRINT=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGPRINTXML"){
							DEBUGPRINTXML=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGRESTARTDB"){
							DEBUGRESTARTDB=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGREVERSE"){
							DEBUGREVERSE=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSEARCHNOTRIP"){
							DEBUGSEARCHNOTRIP=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSLACK"){
							DEBUGSLACK=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSWITCHBRD"){
							DEBUGSWITCHBRD=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSYNC"){
							DEBUGSYNC=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGTIMEBATCH"){
							DEBUGTIMEBATCH=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGVERSION"){
							DEBUGVERSION=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGVIEWSCR"){
							DEBUGVIEWSCR=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGVIEWTAB"){
							DEBUGVIEWTAB=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGROUTED"){
							DEBUGROUTED=flagValue;
							foundFlag = true;
							break;
						}
					}
				}
				if (foundFlag) {break;}
			}
		}
		logfile.close();
	}

	string date = "010199";
	if(DEBUG == 1) gse << "Checking for fixed route " << endl;

	ifstream myfile (CONFIGFILE);
	//string line;
	//bool foundclient = false;
	foundclient = false;
	if (myfile.is_open())
	{
		while(getline (myfile,line)){


			if(line == "DIRECTORIES"){
				getline (myfile,line);
				LOGDIR = line; getline (myfile,line);
				MAPDIR = line; getline (myfile,line);
				BATCHMACHINE = line; getline (myfile,line);
				//APPLICATIONDIR = line; getline (myfile,line);
			}

			if(line == "CLIENT"){
				getline (myfile,line);
				string client = line;
				foundclient = true;
				getline (myfile,line);
				table_itms_segments = line;  getline (myfile,line);
				table_itms_trips = line; getline (myfile,line);
				ip = line; getline (myfile,line);
				servicename = line; getline (myfile,line);
				keyreq =  (int)to_number(line+date); getline (myfile,line);
				keyu =  (int)to_number(line+date); getline (myfile,line);
				key =  (int)to_number(line+date); getline (myfile,line);
				keyd =  (int)to_number(line+date); getline (myfile,line);
				keyf =  (int)to_number(line+date); getline (myfile,line);
				keys =  (int)to_number(line+date); getline (myfile,line);
				keye =  (int)to_number(line+date); getline (myfile,line);
				keyt =  (int)to_number(line+date); getline (myfile,line);
				keytc =  (int)to_number(line+date); getline (myfile,line);
				keyr =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_PT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_WT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_LT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_ET =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_NT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_HT =  (int)to_number(line+date); getline (myfile,line);
				key_velocityMaxDist  =  (int)to_number(line+date); getline (myfile,line);
				key_velocityMinDist =  (int)to_number(line+date); getline (myfile,line);
				key_zone =  (int)to_number(line+date); getline (myfile,line);
				key_starttime  =  (int)to_number(line+date); getline (myfile,line);
				key_endtime  =  (int)to_number(line+date); getline (myfile,line);
				key_IGNORE_DEPOTS_CUTOFF =  (int)to_number(line+date); getline (myfile,line);
				key_p_WHEELLOAD =  (int)to_number(line+date);getline (myfile,line);
				key_p_AMBLOAD =  (int)to_number(line+date); getline (myfile,line);
				key_p_MAXEARLYDROPOFFFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_DIALRIDEEARLYPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_DIALRIDELATEPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_OTHEREARLYPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_OTHERLATEPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_ignorepu =  (int)to_number(line+date); getline (myfile,line);
				key_p_SHORTBREAK =  (int)to_number(line+date); getline (myfile,line);
				key_p_LUNCHBREAK =  (int)to_number(line+date); getline (myfile,line);
				key_p_PROXIMITYFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_ZONE_DESCR =  (int)to_number(line+date); getline (myfile,line);
				key_a_mediumshortdistance =  (int)to_number(line+date); getline (myfile,line);
				key_a_shorttriptime = (int)to_number(line+date); getline (myfile,line);
				key_a_longtriptime = (int)to_number(line+date); getline (myfile,line);
				key_a_mediumtriptime =  (int)to_number(line+date); getline (myfile,line);
				key_a_mediumlongdistance =  (int)to_number(line+date); getline (myfile,line);
				key_a_extra_loadtime =  (int)to_number(line+date); getline (myfile,line);
				key_OPENSEGSTHRESHOLD=  (int)to_number(line+date); getline (myfile,line);
				key_numberofedges =  (int)to_number(line+date); getline (myfile,line);
				key_SLACKTHRESHOLD =  (int)to_number(line+date); getline (myfile,line);
				key_ACALCULATE_GCOUNT_WC =  (int)to_number(line+date); getline (myfile,line);
				key_PERCENTAGETOSTOPBATCH =  (int)to_number(line+date); getline (myfile,line);
				keyrnum = (int)to_number(line+date); getline (myfile,line);
				keyrid = (int)to_number(line+date); getline (myfile,line);
				keyrlatlong = (int)to_number(line+date); getline (myfile,line);
				keyrdist = (int)to_number(line+date); getline (myfile,line);
				keyredge = (int)to_number(line+date); getline (myfile,line);
				keyrtripidx = (int)to_number(line+date); getline (myfile,line);
				keyfunc = (int)to_number(line+date); getline (myfile,line);
				keytime = (int)to_number(line+date); getline (myfile,line);
				key_shared_process = (int)to_number(line+date); getline (myfile,line);
				key_number_of_edges = (int)to_number(line+date); getline (myfile,line);
				key_EXTRAGRPTT = (int)to_number(line+date); getline (myfile,line);
				key_USEREVERSECALC = (int)to_number(line+date); getline (myfile,line);
				key_MAXDEADHEADVARIANCE = (int)to_number(line+date); getline (myfile,line);
				key_XTRTRAVTIME = (int)to_number(line+date); getline (myfile,line);
				key_headhome = (int)to_number(line+date); getline (myfile,line);
				key_exclusioninclusion = (int)to_number(line+date); getline (myfile,line);
				key_exclusioninclusionlist = (int)to_number(line+date); getline (myfile,line);
				key_sameoutboundpreassignment = (int)to_number(line+date); getline (myfile,line);
				key_maxstopnum = (int)to_number(line+date); getline (myfile,line);
				keyrtime = (int)to_number(line+date); getline (myfile,line);
				key_fb_threshold = (int)to_number(line+date); getline (myfile,line);
				key_extra_slack  = (int)to_number(line+date); getline (myfile,line);
				key_relax_constraints  = (int)to_number(line+date); getline (myfile,line);
				key_cs_cap_agency =(int)to_number(line+date); getline (myfile,line);
				key_cs_cap_vol =(int)to_number(line+date); getline (myfile,line);
				key_bs_cap_agency =(int)to_number(line+date); getline (myfile,line);
				key_bs_cap_vol =(int)to_number(line+date); getline (myfile,line);
				key_dw_sml =(int)to_number(line+date); getline (myfile,line);
				key_dw_med =(int)to_number(line+date); getline (myfile,line);
				key_dw_lng =(int)to_number(line+date); getline (myfile,line);
				key_avl_tops = (int)to_number(line+date); getline (myfile,line); //Hui, 01-FEB-21
				siteSize = line; getline (myfile,line);

				/*
            osrm_shm = line; getline (myfile,line);
            initosrmshm(osrm_shm);*/
				username = line; getline (myfile,line);
				password = line; getline (myfile,line);
				FIXEDBOOL = line; getline (myfile,line);
				port = line;
				// string tempstr = ip+":1521/"+servicename;
				string tempstr = ip+port+servicename;
				strcpy(connectString,tempstr.c_str());







				if(DEBUG == 1) gse << "fixed bool is " << FIXEDBOOL << " client " << client << endl;
				if(FIXEDBOOL == "FIXED"){

					/*DEBUG = 1;
					Environment *env = Environment::createEnvironment();
					Connection *conn = env->createConnection(username, password, connectString);
					string command = "SELECT featureid, featurevalue FROM itms_oe_registry WHERE  FEATUREID = 'DEBUG_FLAG'";
					//if(DEBUG == 1) gse <<command << endl;
					Statement * stmt = conn->createStatement (command);
					ResultSet * rs = stmt->executeQuery();
					while(rs->next()){
						if(rs->getString(1) == "DEBUG_FLAG")
							DEBUG = rs->getInt(2);
					}
					stmt->closeResultSet(rs);
					conn->terminateStatement(stmt);
					env->terminateConnection(conn);
					env->terminateEnvironment(env); */ //JDC DEBUG is now set in the configLogs.txt in /usr/local/bin

					//if(DEBUG == 1) gse << "The debug flag " << DEBUG << endl;


					if(DEBUG == 1) gse << "Found a fixed route client checking v2..." << client << endl;

					int shmid = shmget(keyreq, sizeof(char[MAXPROCESSESCOL][MAXLGSTRSIZE][NUMBEROFPROCESSES]), IPC_CREAT | 0666);
					process_tab = (char( * )[MAXPROCESSESCOL][MAXLGSTRSIZE]) shmat(shmid, 0, 0);

					strcpy(process_tab[FINALIZEBATCH][0] , "");

					string syncstring = "nohup /usr/local/bin/GSE_"+siteSize+"/gse_sync " + client + " 01-JAN-2099 ALL &";
					if(DEBUG == 1) gse << syncstring << endl;
					std::system(syncstring.c_str());
					sleep(2);



					shmid = shmget(key, sizeof(char[MAXTRIPIDX][TRIPCOLSIZE][MAXLGSTRSIZE]),IPC_CREAT |  0666);
					schd_tab = (char( * )[TRIPCOLSIZE][MAXLGSTRSIZE]) shmat(shmid, 0, 0);

					if(DEBUG == 1) gse << "finalize status " << process_tab[FINALIZEBATCH][0] << endl;


					while(true){

						if(strcmp(process_tab[FINALIZEBATCH][0] , ("DONE"))==0){
							break;
						}
					}

					if(strcmp((schd_tab[1][10]), "")==0){
						if(DEBUG == 1) gse << "There is no data loaded so clearing shared memory for this client " << schd_tab[1][0] << " " <<  process_tab[FINALIZEBATCH][0] <<   endl;
						string  pid = GetStdoutFromCommand_nolinebreak("pgrep -x \"/usr/local/bin/GSE_"+siteSize+"/gse_access\"");

						while(pid!= ""){
							string pidtoken = getNextToken(&(pid),"\n");
							string startstr = GetStdoutFromCommand_nolinebreak("ps -p " + pidtoken + " -f");
							getNextToken(&(startstr),"\n");
							string commandline =  getNextToken(&(startstr),"\n");
							string nextToken;
							while(nextToken != "gse_access"){
								nextToken = getNextToken(&(commandline)," ");
							}
							string client1 = getNextToken(&(commandline)," ");
							string date1 = getNextToken(&(commandline)," ");

							if(DEBUG == 1) gse << client1 << " " << date1 << endl;

							string monitor = "/usr/local/bin/GSE_"+siteSize+"/gse_monitor " + client + " " + date1;
							string dbwrite = "/usr/local/bin/GSE_"+siteSize+"/gse_dbwrite " + client + " " + date1;
							string access = "/usr/local/bin/GSE_"+siteSize+"/gse_access " + client + " " + date1;
							string osrm = "/usr/local/bin/GSE_"+siteSize+"/osrm-routed --shared-memory=yes " + client +  " " + date1;

							if(client == client1){
								string killpid = GetStdoutFromCommand("pgrep -o -f -x \""+access+"\"");
								killpid.erase(std::remove(killpid.begin(), killpid.end(), '\n'), killpid.end());
								string killstr = "kill -9 " + killpid;
								std::system(killstr.c_str());
								if(DEBUG == 1) gse << "killed " << access  <<endl;
								killpid = GetStdoutFromCommand("pgrep -o -f -x \""+monitor+"\"");
								killpid.erase(std::remove(killpid.begin(), killpid.end(), '\n'), killpid.end());
								killstr = "kill -9 " + killpid;
								std::system(killstr.c_str());
								if(DEBUG == 1) gse << "killed " << monitor  <<endl;
								killpid = GetStdoutFromCommand("pgrep -o -f -x \""+dbwrite+"\"");
								killpid.erase(std::remove(killpid.begin(), killpid.end(), '\n'), killpid.end());
								killstr = "kill -9 " + killpid;
								std::system(killstr.c_str());
								if(DEBUG == 1) gse << "killed " << dbwrite  <<endl;
								killpid = GetStdoutFromCommand("pgrep -o -f -x \""+osrm+"\"");
								killpid.erase(std::remove(killpid.begin(), killpid.end(), '\n'), killpid.end());
								killstr = "kill -9 " + killpid;
								std::system(killstr.c_str());
								if(DEBUG == 1) gse << "killed " << osrm  <<endl;
								shmid = shmget(keyreq, sizeof(char[MAXPROCESSESCOL][MAXLGSTRSIZE][NUMBEROFPROCESSES]),  0666);
								//shmctl(shmid, IPC_RMID, 0);
								shmdt(process_tab);
								shmid = shmget(key, sizeof(char[MAXTRIPIDX][TRIPCOLSIZE][MAXLGSTRSIZE]), 0666);
								//shmctl(shmid, IPC_RMID, 0);
								shmdt(schd_tab);
								if(DEBUG == 1) gse << "Detached from system service" << endl;
								sleep(1);
								std::system("nohup /usr/local/bin/GSE_LARGE/gse_killall");
								if(DEBUG == 1) gse << "cleared shared memory for " <<client1 << " " << date1 <<endl;

							}
						}



					}
					else{shmid = shmget(keyreq, sizeof(char[MAXPROCESSESCOL][MAXLGSTRSIZE][NUMBEROFPROCESSES]),  0666);
					shmdt(process_tab);
					shmid = shmget(key, sizeof(char[MAXTRIPIDX][TRIPCOLSIZE][MAXLGSTRSIZE]), 0666);
					//shmctl(shmid, IPC_RMID, 0);
					shmdt(schd_tab);
					if(DEBUG == 1) gse << "Data loaded and synchronizing" << endl;
					}

				}


			}

		}

		myfile.close();
	}

	return true;


}





bool initshm(string client, string date){

	ifstream logfile (CONFIGLOGS);
	string line;
	bool foundclient = false;
	bool foundFlag = false;
	if (logfile.is_open())
	{
		while(getline (logfile,line)){

			if(line == "DIRECTORIES"){ //JDC This section is currently not needed for logging purposes
				getline (logfile,line);
				LOGDIR = line; getline (logfile,line);
				MAPDIR = line; getline (logfile,line);
			}

			if(line == "CLIENT"){
				getline (logfile,line);
				if (client == line) {
					foundclient = true;

					pid_t pid = getpid();
					string requestName;
					string processName;
					/*//JDC "ps -p <pid> -o comm=" sometimes returns "sh" as the process, depending on how the process was launched.
					  //JDC Seems to occur with the use of "nohup".  Also, ps (ubuntu linux) has a longstanding problem of truncating
					  //JDC process names to 15 characters.  Both of these necessitate the use of a different approach
					  //JDC to acquiring the process name.
					requestName = "ps -p " + to_string(pid) +  " -o comm=";
					processName = GetStdoutFromCommand(requestName); //JDC This always leaves a \n at the end of the string
					processName.erase(std::remove(processName.begin(), processName.end(), '\n'), processName.end());
					*/
					string throwaway;

					requestName = "ps " + to_string(pid) + " | grep 'GSE_'"; //JDC LIMITATION: This assumes processes are run from a folder that begins with "GSE_"
					processName = GetStdoutFromCommand(requestName);
					throwaway=getNextToken(&(processName),"GSE_"); //JDC Launched processes include the Path, e.g., /usr/local/bin/GSE_LARGE
					throwaway=getNextToken(&(processName),"/");
					processName = getNextToken(&(processName)," "); //JDC This assumes there is always a space at the end of the process name.
					processName.erase(std::remove(processName.begin(), processName.end(), '\n'), processName.end()); //JDC If there is no space then there will be a \n
					string candidateName;

					getline (logfile,line);
					candidateName=getNextToken(&(line),"=");
					DEBUG = (int) to_number(getNextToken(&(line),";"));
					getline(logfile,line);
					candidateName=getNextToken(&(line),"=");
					DEBUGSTATE = (int) to_number(getNextToken(&(line),";"));
					string debugFlag;
					int flagValue;
					while(getline (logfile,line)){
						candidateName = getNextToken(&(line),":");
						debugFlag = getNextToken(&(line),"=");
						flagValue = (int) to_number(getNextToken(&(line),";"));
						if (candidateName == processName) {
							if (debugFlag == "DEBUGACCESS"){
								DEBUGACCESS=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGLAUNCHER"){
								DEBUGLAUNCHER=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGBATCH"){
								DEBUGBATCH=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGBUILDGRPS"){
								DEBUGBUILDGRPS=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGCALC"){
								DEBUGCALC=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGCHECKINCL"){
								DEBUGCHECKINCL=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGCLEANALL"){
								DEBUGCLEANALL=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGCLEARSCR"){
								DEBUGCLEARSCR=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGSYSSERV"){
								DEBUGSYSSERV=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGDBWRITE"){
								DEBUGDBWRITE=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGFB"){
								DEBUGFB=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGFB2"){
								DEBUGFB2=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGFINAL"){
								DEBUGFINAL=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGKILLALLFIXED"){
								DEBUGKILLALLFIXED=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGKILLALLPROG"){
								DEBUGKILLALLPROG=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGKILLCLIENTDATE"){
								DEBUGKILLCLIENTDATE=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGKILLPROC"){
								DEBUGKILLPROC=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGMONITOR"){
								DEBUGMONITOR=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGORACLEBAT"){
								DEBUGORACLEBAT=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGPRINT"){
								DEBUGPRINT=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGPRINTXML"){
								DEBUGPRINTXML=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGRESTARTDB"){
								DEBUGRESTARTDB=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGREVERSE"){
								DEBUGREVERSE=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGSEARCHNOTRIP"){
								DEBUGSEARCHNOTRIP=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGSLACK"){
								DEBUGSLACK=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGSWITCHBRD"){
								DEBUGSWITCHBRD=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGSYNC"){
								DEBUGSYNC=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGTIMEBATCH"){
								DEBUGTIMEBATCH=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGVERSION"){
								DEBUGVERSION=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGVIEWSCR"){
								DEBUGVIEWSCR=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGVIEWTAB"){
								DEBUGVIEWTAB=flagValue;
								foundFlag = true;
								break;
							}
							if (debugFlag == "DEBUGROUTED"){
								DEBUGROUTED=flagValue;
								foundFlag = true;
								break;
							}
						}
					}
					if (foundFlag) {break;}
				}

			}
		}
		logfile.close();
	}


	ifstream myfile (CONFIGFILE);
	//string line;
	//bool foundclient = false;
	foundclient = false;
	if (myfile.is_open())
	{

		while(getline (myfile,line)){

			if(line == "DIRECTORIES"){
				getline (myfile,line);
				LOGDIR = line; getline (myfile,line);
				MAPDIR = line; getline (myfile,line);
				BATCHMACHINE = line; getline (myfile,line);
				if(client == "Directories"){
					foundclient = true;
					break;
				}
				//APPLICATIONDIR = line; getline (myfile,line);
			}
			if(line == "CLIENT"){
				getline (myfile,line);
				if(line == client ){
					foundclient = true;
					getline (myfile,line);
					table_itms_segments = line;  getline (myfile,line);
					table_itms_trips = line; getline (myfile,line);
					ip = line; getline (myfile,line);
					servicename = line; getline (myfile,line);
					keyreq =  (int)to_number(line+date); getline (myfile,line);
					keyu =  (int)to_number(line+date); getline (myfile,line);
					key =  (int)to_number(line+date); getline (myfile,line);
					keyd =  (int)to_number(line+date); getline (myfile,line);
					keyf =  (int)to_number(line+date); getline (myfile,line);
					keys =  (int)to_number(line+date); getline (myfile,line);
					keye =  (int)to_number(line+date); getline (myfile,line);
					keyt =  (int)to_number(line+date); getline (myfile,line);
					keytc =  (int)to_number(line+date); getline (myfile,line);
					keyr =  (int)to_number(line+date); getline (myfile,line);
					key_V_VEL_PT =  (int)to_number(line+date); getline (myfile,line);
					key_V_VEL_WT =  (int)to_number(line+date); getline (myfile,line);
					key_V_VEL_LT =  (int)to_number(line+date); getline (myfile,line);
					key_V_VEL_ET =  (int)to_number(line+date); getline (myfile,line);
					key_V_VEL_NT =  (int)to_number(line+date); getline (myfile,line);
					key_V_VEL_HT =  (int)to_number(line+date); getline (myfile,line);
					key_velocityMaxDist  =  (int)to_number(line+date); getline (myfile,line);
					key_velocityMinDist =  (int)to_number(line+date); getline (myfile,line);
					key_zone =  (int)to_number(line+date); getline (myfile,line);
					key_starttime  =  (int)to_number(line+date); getline (myfile,line);
					key_endtime  =  (int)to_number(line+date); getline (myfile,line);
					key_IGNORE_DEPOTS_CUTOFF =  (int)to_number(line+date); getline (myfile,line);
					key_p_WHEELLOAD =  (int)to_number(line+date);getline (myfile,line);
					key_p_AMBLOAD =  (int)to_number(line+date); getline (myfile,line);
					key_p_MAXEARLYDROPOFFFACTOR =  (int)to_number(line+date); getline (myfile,line);
					key_p_DIALRIDEEARLYPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
					key_p_DIALRIDELATEPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
					key_p_OTHEREARLYPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
					key_p_OTHERLATEPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
					key_ignorepu =  (int)to_number(line+date); getline (myfile,line);
					key_p_SHORTBREAK =  (int)to_number(line+date); getline (myfile,line);
					key_p_LUNCHBREAK =  (int)to_number(line+date); getline (myfile,line);
					key_p_PROXIMITYFACTOR =  (int)to_number(line+date); getline (myfile,line);
					key_ZONE_DESCR =  (int)to_number(line+date); getline (myfile,line);
					key_a_mediumshortdistance =  (int)to_number(line+date); getline (myfile,line);
					key_a_shorttriptime = (int)to_number(line+date); getline (myfile,line);
					key_a_longtriptime = (int)to_number(line+date); getline (myfile,line);
					key_a_mediumtriptime =  (int)to_number(line+date); getline (myfile,line);
					key_a_mediumlongdistance =  (int)to_number(line+date); getline (myfile,line);
					key_a_extra_loadtime =  (int)to_number(line+date); getline (myfile,line);
					key_OPENSEGSTHRESHOLD=  (int)to_number(line+date); getline (myfile,line);
					key_numberofedges =  (int)to_number(line+date); getline (myfile,line);
					key_SLACKTHRESHOLD =  (int)to_number(line+date); getline (myfile,line);
					key_ACALCULATE_GCOUNT_WC =  (int)to_number(line+date); getline (myfile,line);
					key_PERCENTAGETOSTOPBATCH =  (int)to_number(line+date); getline (myfile,line);
					keyrnum = (int)to_number(line+date); getline (myfile,line);
					keyrid = (int)to_number(line+date); getline (myfile,line);
					keyrlatlong = (int)to_number(line+date); getline (myfile,line);
					keyrdist = (int)to_number(line+date); getline (myfile,line);
					keyredge = (int)to_number(line+date); getline (myfile,line);
					keyrtripidx = (int)to_number(line+date); getline (myfile,line);
					keyfunc = (int)to_number(line+date); getline (myfile,line);
					keytime = (int)to_number(line+date); getline (myfile,line);
					key_shared_process = (int)to_number(line+date); getline (myfile,line);
					key_number_of_edges = (int)to_number(line+date); getline (myfile,line);
					key_EXTRAGRPTT = (int)to_number(line+date); getline (myfile,line);
					key_USEREVERSECALC = (int)to_number(line+date); getline (myfile,line);
					key_MAXDEADHEADVARIANCE = (int)to_number(line+date); getline (myfile,line);
					key_XTRTRAVTIME = (int)to_number(line+date); getline (myfile,line);
					key_headhome = (int)to_number(line+date); getline (myfile,line);
					key_exclusioninclusion = (int)to_number(line+date); getline (myfile,line);
					key_exclusioninclusionlist = (int)to_number(line+date); getline (myfile,line);
					key_sameoutboundpreassignment = (int)to_number(line+date); getline (myfile,line);
					key_maxstopnum = (int)to_number(line+date); getline (myfile,line);
					keyrtime = (int)to_number(line+date); getline (myfile,line);
					key_fb_threshold = (int)to_number(line+date); getline (myfile,line);
					key_extra_slack  = (int)to_number(line+date); getline (myfile,line);
					key_relax_constraints  = (int)to_number(line+date); getline (myfile,line);
					key_cs_cap_agency =(int)to_number(line+date); getline (myfile,line);
					key_cs_cap_vol =(int)to_number(line+date); getline (myfile,line);
					key_bs_cap_agency =(int)to_number(line+date); getline (myfile,line);
					key_bs_cap_vol =(int)to_number(line+date); getline (myfile,line);
					key_dw_sml =(int)to_number(line+date); getline (myfile,line);
					key_dw_med =(int)to_number(line+date); getline (myfile,line);
					key_dw_lng =(int)to_number(line+date); getline (myfile,line);
					key_avl_tops = (int)to_number(line+date); getline (myfile,line); //Hui, 01-FEB-21
					siteSize = line; getline (myfile,line);

					/*
            osrm_shm = line; getline (myfile,line);
            initosrmshm(osrm_shm);*/
					username = line; getline (myfile,line);
					password = line; getline (myfile,line);
					FIXEDBOOL = line; getline (myfile,line);
					port = line;
					// string tempstr = ip+":1521/"+servicename;
					string tempstr = ip+port+servicename;
					strcpy(connectString,tempstr.c_str());
					if(DEBUG == 1) gse << "ConnectString = " << connectString << endl;



					/*DEBUG = 1;
					DEBUGSTATE = 1;
					try {
						// cout << "connectString: " << connectString << " ~ username:" << username << " ~ password: " << password << endl;
						Environment *env = Environment::createEnvironment();
						Connection *conn = env->createConnection(username, password, connectString);
						//Hui, this is the original: string command = "SELECT featureid, featurevalue FROM itms_oe_registry WHERE  FEATUREID = 'DEBUG_FLAG'";
						string command = "SELECT featureid, featurevalue FROM itms_oe_registry WHERE  FEATUREID in ('DEBUG_FLAG', 'DEBUGSTATE_FLAG')";
						// if(DEBUG == 1) gse <<command << endl;
						Statement * stmt = conn->createStatement (command);
						ResultSet * rs = stmt->executeQuery();
						while(rs->next()){
							if(rs->getString(1) == "DEBUG_FLAG")
								DEBUG = rs->getInt(2);
							if(rs->getString(1) == "DEBUGSTATE_FLAG")
								DEBUGSTATE = rs->getInt(2);
						}
						stmt->closeResultSet(rs);
						conn->terminateStatement(stmt);
						env->terminateConnection(conn);
						env->terminateEnvironment(env);
					} catch(SQLException ex)
					{
						gse << ex.getMessage() << endl;
					} */ //JDC


					// if(DEBUG == 1) gse << "The debug flag " << DEBUG << endl;
					//cout << "Set site trip size : " <<siteTripSize <<  endl;
				}
			}
		}

		myfile.close();
	}



	if(!foundclient){
		if(DEBUG == 1) gse << "That client does not exist in the config file" << endl;
		return false;
	}
	else
		return true;
}


bool checkdaily(string date){

	ifstream logfile (CONFIGLOGS);
	string line;
	string client;
	bool foundclient = false;
	bool foundFlag = false;
	if (logfile.is_open())
	{
		while(getline (logfile,line)){

			if(line == "DIRECTORIES"){
				getline (logfile,line);
				LOGDIR = line; getline (logfile,line);
				MAPDIR = line; getline (logfile,line);
			}

			if(line == "CLIENT"){
				getline (logfile,line);
				client = line;
				foundclient = true;
				pid_t pid = getpid();
				string requestName;
				string processName;
				/*//JDC "ps -p <pid> -o comm=" sometimes returns "sh" as the process, depending on how the process was launched.
				  //JDC Seems to occur with the use of "nohup".  Also, ps (ubuntu linux) has a longstanding problem of truncating
				  //JDC process names to 15 characters.  Both of these necessitate the use of a different approach
				  //JDC to acquiring the process name.
				requestName = "ps -p " + to_string(pid) +  " -o comm=";
				processName = GetStdoutFromCommand(requestName); //JDC This always leaves a \n at the end of the string
				processName.erase(std::remove(processName.begin(), processName.end(), '\n'), processName.end());
				*/
				string throwaway;

				requestName = "ps " + to_string(pid) + " | grep 'GSE_'"; //JDC LIMITATION: This assumes processes are run from a folder that begins with "GSE_"
				processName = GetStdoutFromCommand(requestName);
				throwaway=getNextToken(&(processName),"GSE_"); //JDC Launched processes include the Path, e.g., /usr/local/bin/GSE_LARGE
				throwaway=getNextToken(&(processName),"/");
				processName = getNextToken(&(processName)," "); //JDC This assumes there is always a space at the end of the process name.
				processName.erase(std::remove(processName.begin(), processName.end(), '\n'), processName.end()); //JDC If there is no space then there will be a \n
				string candidateName;

				getline (logfile,line);
				candidateName=getNextToken(&(line),"=");
				DEBUG = (int) to_number(getNextToken(&(line),";"));
				getline(logfile,line);
				candidateName=getNextToken(&(line),"=");
				DEBUGSTATE = (int) to_number(getNextToken(&(line),";"));
				string debugFlag;
				int flagValue;
				while(getline (logfile,line)){
					candidateName = getNextToken(&(line),":");
					debugFlag = getNextToken(&(line),"=");
					flagValue = (int) to_number(getNextToken(&(line),";"));
					if (candidateName == processName) {
						if (debugFlag == "DEBUGACCESS"){
							DEBUGACCESS=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGLAUNCHER"){
							DEBUGLAUNCHER=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGBATCH"){
							DEBUGBATCH=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGBUILDGRPS"){
							DEBUGBUILDGRPS=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCALC"){
							DEBUGCALC=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCHECKINCL"){
							DEBUGCHECKINCL=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCLEANALL"){
							DEBUGCLEANALL=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGCLEARSCR"){
							DEBUGCLEARSCR=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSYSSERV"){
							DEBUGSYSSERV=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGDBWRITE"){
							DEBUGDBWRITE=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGFB"){
							DEBUGFB=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGFB2"){
							DEBUGFB2=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGFINAL"){
							DEBUGFINAL=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLALLFIXED"){
							DEBUGKILLALLFIXED=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLALLPROG"){
							DEBUGKILLALLPROG=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLCLIENTDATE"){
							DEBUGKILLCLIENTDATE=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGKILLPROC"){
							DEBUGKILLPROC=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGMONITOR"){
							DEBUGMONITOR=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGORACLEBAT"){
							DEBUGORACLEBAT=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGPRINT"){
							DEBUGPRINT=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGPRINTXML"){
							DEBUGPRINTXML=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGRESTARTDB"){
							DEBUGRESTARTDB=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGREVERSE"){
							DEBUGREVERSE=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSEARCHNOTRIP"){
							DEBUGSEARCHNOTRIP=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSLACK"){
							DEBUGSLACK=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSWITCHBRD"){
							DEBUGSWITCHBRD=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGSYNC"){
							DEBUGSYNC=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGTIMEBATCH"){
							DEBUGTIMEBATCH=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGVERSION"){
							DEBUGVERSION=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGVIEWSCR"){
							DEBUGVIEWSCR=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGVIEWTAB"){
							DEBUGVIEWTAB=flagValue;
							foundFlag = true;
							break;
						}
						if (debugFlag == "DEBUGROUTED"){
							DEBUGROUTED=flagValue;
							foundFlag = true;
							break;
						}
					}
				}
			}
			if (foundFlag) {break;}
		}
		logfile.close();
	}


	ifstream myfile (CONFIGFILE);
	//string line;
	//string client;
	//bool foundclient = false;
	foundclient = false;
	if (myfile.is_open())
	{

		while(getline (myfile,line)){

			if(line == "DIRECTORIES"){
				getline (myfile,line);
				LOGDIR = line; getline (myfile,line);
				MAPDIR = line; getline (myfile,line);
				BATCHMACHINE = line; getline (myfile,line);
				//APPLICATIONDIR = line; getline (myfile,line);
			}
			if(line == "CLIENT"){
				getline (myfile,line);
				client = line; getline (myfile,line);
				table_itms_segments = line;  getline (myfile,line);
				table_itms_trips = line; getline (myfile,line);
				ip = line; getline (myfile,line);
				servicename = line; getline (myfile,line);
				keyreq =  (int)to_number(line+date); getline (myfile,line);
				keyu =  (int)to_number(line+date); getline (myfile,line);
				key =  (int)to_number(line+date); getline (myfile,line);
				keyd =  (int)to_number(line+date); getline (myfile,line);
				keyf =  (int)to_number(line+date); getline (myfile,line);
				keys =  (int)to_number(line+date); getline (myfile,line);
				keye =  (int)to_number(line+date); getline (myfile,line);
				keyt =  (int)to_number(line+date); getline (myfile,line);
				keytc =  (int)to_number(line+date); getline (myfile,line);
				keyr =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_PT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_WT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_LT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_ET =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_NT =  (int)to_number(line+date); getline (myfile,line);
				key_V_VEL_HT =  (int)to_number(line+date); getline (myfile,line);
				key_velocityMaxDist  =  (int)to_number(line+date); getline (myfile,line);
				key_velocityMinDist =  (int)to_number(line+date); getline (myfile,line);
				key_zone =  (int)to_number(line+date); getline (myfile,line);
				key_starttime  =  (int)to_number(line+date); getline (myfile,line);
				key_endtime  =  (int)to_number(line+date); getline (myfile,line);
				key_IGNORE_DEPOTS_CUTOFF =  (int)to_number(line+date); getline (myfile,line);
				key_p_WHEELLOAD =  (int)to_number(line+date);getline (myfile,line);
				key_p_AMBLOAD =  (int)to_number(line+date); getline (myfile,line);
				key_p_MAXEARLYDROPOFFFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_DIALRIDEEARLYPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_DIALRIDELATEPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_OTHEREARLYPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_p_OTHERLATEPICKFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_ignorepu =  (int)to_number(line+date); getline (myfile,line);
				key_p_SHORTBREAK =  (int)to_number(line+date); getline (myfile,line);
				key_p_LUNCHBREAK =  (int)to_number(line+date); getline (myfile,line);
				key_p_PROXIMITYFACTOR =  (int)to_number(line+date); getline (myfile,line);
				key_ZONE_DESCR =  (int)to_number(line+date); getline (myfile,line);
				key_a_mediumshortdistance =  (int)to_number(line+date); getline (myfile,line);
				key_a_shorttriptime = (int)to_number(line+date); getline (myfile,line);
				key_a_longtriptime = (int)to_number(line+date); getline (myfile,line);
				key_a_mediumtriptime =  (int)to_number(line+date); getline (myfile,line);
				key_a_mediumlongdistance =  (int)to_number(line+date); getline (myfile,line);
				key_a_extra_loadtime =  (int)to_number(line+date); getline (myfile,line);
				key_OPENSEGSTHRESHOLD=  (int)to_number(line+date); getline (myfile,line);
				key_numberofedges =  (int)to_number(line+date); getline (myfile,line);
				key_SLACKTHRESHOLD =  (int)to_number(line+date); getline (myfile,line);
				key_ACALCULATE_GCOUNT_WC =  (int)to_number(line+date); getline (myfile,line);
				key_PERCENTAGETOSTOPBATCH =  (int)to_number(line+date); getline (myfile,line);
				keyrnum = (int)to_number(line+date); getline (myfile,line);
				keyrid = (int)to_number(line+date); getline (myfile,line);
				keyrlatlong = (int)to_number(line+date); getline (myfile,line);
				keyrdist = (int)to_number(line+date); getline (myfile,line);
				keyredge = (int)to_number(line+date); getline (myfile,line);
				keyrtripidx = (int)to_number(line+date); getline (myfile,line);
				keyfunc = (int)to_number(line+date); getline (myfile,line);
				keytime = (int)to_number(line+date); getline (myfile,line);
				key_shared_process = (int)to_number(line+date); getline (myfile,line);
				key_number_of_edges = (int)to_number(line+date); getline (myfile,line);
				key_EXTRAGRPTT = (int)to_number(line+date); getline (myfile,line);
				key_USEREVERSECALC = (int)to_number(line+date); getline (myfile,line);
				key_MAXDEADHEADVARIANCE = (int)to_number(line+date); getline (myfile,line);
				key_XTRTRAVTIME = (int)to_number(line+date); getline (myfile,line);
				key_headhome = (int)to_number(line+date); getline (myfile,line);
				key_exclusioninclusion = (int)to_number(line+date); getline (myfile,line);
				key_exclusioninclusionlist = (int)to_number(line+date); getline (myfile,line);
				key_sameoutboundpreassignment = (int)to_number(line+date); getline (myfile,line);
				key_maxstopnum = (int)to_number(line+date); getline (myfile,line);
				keyrtime = (int)to_number(line+date); getline (myfile,line);
				key_fb_threshold = (int)to_number(line+date); getline (myfile,line);
				key_extra_slack  = (int)to_number(line+date); getline (myfile,line);
				key_relax_constraints  = (int)to_number(line+date); getline (myfile,line);
				key_cs_cap_agency =(int)to_number(line+date); getline (myfile,line);
				key_cs_cap_vol =(int)to_number(line+date); getline (myfile,line);
				key_bs_cap_agency =(int)to_number(line+date); getline (myfile,line);
				key_bs_cap_vol =(int)to_number(line+date); getline (myfile,line);
				key_dw_sml =(int)to_number(line+date); getline (myfile,line);
				key_dw_med =(int)to_number(line+date); getline (myfile,line);
				key_dw_lng =(int)to_number(line+date); getline (myfile,line);
				key_avl_tops = (int)to_number(line+date); getline (myfile,line); //Hui, 01-FEB-21
				siteSize = line; getline (myfile,line);

				/*
            osrm_shm = line; getline (myfile,line);
            initosrmshm(osrm_shm);*/
				username = line; getline (myfile,line);
				password = line; getline (myfile,line);
				FIXEDBOOL = line; getline (myfile,line);
				port = line;
				// string tempstr = ip+":1521/"+servicename;
				string tempstr = ip+port+servicename;
				strcpy(connectString,tempstr.c_str());


				if(FIXEDBOOL == "DAILY"){
					string dateday = date.substr(0,2);
					string datemonth = date.substr(2,2);
					string dateyear = date.substr(4,2);


					if(datemonth == "01")
						datemonth = "JAN";
					if(datemonth == "02")
						datemonth = "FEB";
					if(datemonth == "03")
						datemonth = "MAR";
					if(datemonth == "04")
						datemonth = "APR";
					if(datemonth == "05")
						datemonth = "MAY";
					if(datemonth == "06")
						datemonth = "JUN";
					if(datemonth == "07")
						datemonth = "JUL";
					if(datemonth == "08")
						datemonth = "AUG";
					if(datemonth == "09")
						datemonth = "SEP";
					if(datemonth == "10")
						datemonth = "OCT";
					if(datemonth == "11")
						datemonth = "NOV";
					if(datemonth == "12")
						datemonth = "DEC";


					string date2 = dateday+"-"+datemonth+"-"+dateyear;

					if(DEBUG == 1) gse << "Launching Daily Client " << client  << " For date " << date2 << endl;




					/*DEBUG = 1;
					Environment *env = Environment::createEnvironment();
					Connection *conn = env->createConnection(username, password, connectString);
					string command = "SELECT featureid, featurevalue FROM itms_oe_registry WHERE  FEATUREID = 'DEBUG_FLAG'";
					// if(DEBUG == 1) gse <<command << endl;
					Statement * stmt = conn->createStatement (command);
					ResultSet * rs = stmt->executeQuery();
					while(rs->next()){
						if(rs->getString(1) == "DEBUG_FLAG")
							DEBUG = rs->getInt(2);
					}
					stmt->closeResultSet(rs);
					conn->terminateStatement(stmt);
					env->terminateConnection(conn);
					env->terminateEnvironment(env);
					*/ //JDC
					string syncstring = "nohup /usr/local/bin/GSE_"+siteSize+"/gse_batch SYNC." + client + " " +date2 + " ALL ALL &";
					if(DEBUG == 1) gse << syncstring << endl;
					std::system(syncstring.c_str());
					sleep(1);
				}

			}
		}

		myfile.close();
	}

	return true;
}


int64_t starttimer(int display){
	char buffer[30];
	struct timeval tv;
	//time_t currenttime;

	gettimeofday(&tv, NULL);
	time_t curtime=tv.tv_sec;

	//currenttime=tv.tv_usec;

	strftime(buffer,30,"%m-%d-%Y  %T.",localtime(&curtime));

	int64_t now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	//  if(DEBUG == 1) gse << "Testing in starttimer " <<  now << std::endl;

	if(display ==1){

		cout << " the start time " <<  buffer  << tv.tv_usec << endl;
	}
	else{

		if(DEBUG == 1) gse << " the start time " <<  buffer  << tv.tv_usec << endl;
	}
	return now;

}





int64_t endtimer(int64_t origtime, int display){

	char buffer[30];
	struct timeval tv;
	//time_t currenttime;

	gettimeofday(&tv, NULL);
	//   if(DEBUG == 1) gse << "1" << endl;
	time_t curtime=tv.tv_sec;

	strftime(buffer,30,"%m-%d-%Y  %T.",localtime(&curtime));
	//   if(DEBUG == 1) gse << "2"  << endl;

	int64_t now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	//   if(DEBUG == 1) gse << "3" << endl;
	int64_t elapsedtime = now - origtime;
	//   if(DEBUG == 1) gse << "4" << endl;
	//  if(DEBUG == 1) gse << "Orig: " << origtime << " curr: " << now << endl;


	if(display ==1){
		cout << "The processing time  = " << elapsedtime << " ms" << endl;
		cout << " the end time " <<  buffer  << tv.tv_usec << endl;
	}
	else{
		if(DEBUG == 1) gse << "The processing time  = " << elapsedtime << " ms" << endl;
		if(DEBUG == 1) gse << " the end time " <<  buffer << tv.tv_usec << endl;
	}

	return elapsedtime; //in milliseconds



}





std::string trim(const std::string& str,
		const std::string& whitespace = " \t")
{
	const auto strBegin = str.find_first_not_of(whitespace);
	if (strBegin == std::string::npos)
		return ""; // no content

	const auto strEnd = str.find_last_not_of(whitespace);
	const auto strRange = strEnd - strBegin + 1;

	return str.substr(strBegin, strRange);
}



string F_GET_CORE_CITY(string P_CITY ) {
	string CITY;
	std::transform(P_CITY.begin(), P_CITY.end(), P_CITY.begin(), ::toupper);
	CITY = P_CITY;
	if(CITY.substr(0,2)=="N.") {
		CITY=trim(CITY.substr(2, CITY.length()));
	}
	else if (CITY.substr(0,5)=="NORTH"){
		CITY=trim(CITY.substr(7, CITY.length()));
	}
	return CITY;
}

bool foundMobilityExclusion(int * local_s_tab, int counter, string excludedmob1, string excludedmob2){
	if(DEBUG == 1) gse << "Begin foundMobilityExclusion, counter: " << counter << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;
	if(excludedmob1 == "" || excludedmob2 == ""){
		if(DEBUG == 1) gse << "Excluded mobilities returning false, excludedmob1 or excludedmob2 is empty. excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;
		return false;
	}
	int size1 = sizeof(schd_tab)/sizeof(schd_tab[0]);
	int size2 = sizeof(local_s_tab)/sizeof(local_s_tab[0]);
	if(DEBUG == 1) gse << "size1: " << size1 << ", size2: " << size2 << endl;
	for(int a = 0; a < size1; a++){
		for(int b = 0; b < size2; b++){
			if(DEBUG == 1) gse << "local_s_tab[" << b <<"]: " << local_s_tab[b] << endl;
			if(DEBUG == 1) gse << "schd_tab[local_s_tab[" << b <<"][" << a << "]: " << schd_tab[local_s_tab[b]][a] << endl;
		}
	}
	if(DEBUG == 1) gse << "Excluded mobilities  " << excludedmob1 << " " << excludedmob2 << endl;
	for(int y = 0; y < counter; y++){
		string trip = schd_tab[local_s_tab[y]][3];
		string stoptype = schd_tab[local_s_tab[y]][7];
		string mobility = schd_tab[local_s_tab[y]][12];
		string disposition = schd_tab[local_s_tab[y]][DISPOSITION];
		if(DEBUG == 1) gse << "Inside for loop y. counter:  " << counter << ", y: " << y << ", trip: " << trip << ", stoptype: " << stoptype << ", mobility: " << mobility << ", disposition: " << disposition << endl;
		if(disposition != "N" && stoptype == "P" && (mobility.find(excludedmob1,0)!=string::npos || mobility.find(excludedmob2,0)!=string::npos)){
			string exmob;
			if(mobility.find(excludedmob1,0)!=string::npos)
				exmob = excludedmob1;
			else
				exmob = excludedmob2;
			if(DEBUG == 1) gse << "Conditon in loop y is true. disposition: " << disposition << ", stoptype: " << stoptype << ", mobility: " << mobility << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << ", exmob: " << exmob << endl;
			for(int x = y+1; x < counter; x++){
				string trip2 = schd_tab[local_s_tab[x]][3];
				string stoptype2 = schd_tab[local_s_tab[x]][7];
				string mobility2 = schd_tab[local_s_tab[x]][12];
				string disposition2 = schd_tab[local_s_tab[x]][DISPOSITION];
				if(DEBUG == 1) gse << "Inside for loop x. counter:  " << counter << ", y: " << y << ", x:" << x << ", trip2: " << trip2 << ", stoptype2: " << stoptype2 << ", mobility2: " << mobility2 << ", disposition2: " << disposition2 << endl;
				if( disposition2 != "N" && stoptype2 == "P" && (mobility2.find(excludedmob1,0)!=string::npos || mobility2.find(excludedmob2,0)!=string::npos)){
					string exmob2;
					if(mobility2.find(excludedmob1,0)!=string::npos)
						exmob2 = excludedmob1;
					else
						exmob2 = excludedmob2;
					int ambocc = (int)to_number(schd_tab[local_s_tab[x-1]][31]);
					int wcocc = (int)to_number(schd_tab[local_s_tab[x-1]][32]);
					if(DEBUG == 1) gse << "First conditon in loop x is true. disposition2: " << disposition2 << ", stoptype2: " << stoptype2 << ", mobility2: " << mobility2 << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << ", exmob2: " << exmob2 << ", ambocc: " << ambocc << ", wcocc: " << wcocc << endl;
					if((ambocc >= 1 || wcocc >= 1) && exmob2 != exmob){
						if(DEBUG == 1) gse << "Second conditon in loop x is true. ambocc: " << ambocc << ", wcocc: " << wcocc << ", exmob2: " << exmob2 << ", exmob: " << exmob << endl;
						for(int z = y+1; z <= x; z++){
							string trip11 = schd_tab[local_s_tab[z]][3];
							string stoptype11 = schd_tab[local_s_tab[z]][7];
							if(DEBUG == 1) gse << "Inside for loop z. counter:  " << counter << ", y: " << y << ", x:" << x << ", z: " << z << ", trip11: " << trip11 << ", stoptype11: " << stoptype11 << endl;
							if(trip11 == trip && stoptype11 == "D"){
								if(DEBUG == 1) gse << "Conditon in loop z is true. trip11: " << trip11 << ", trip: " << trip << ", stoptype11: " << stoptype11 << endl;
								if(DEBUG == 1) gse << "The drop off is before the next excluded mobility type so we're safe for now" << endl;
								break;
							}
							else if(z+1 == x || z == x){
								if(DEBUG == 1) gse << "Conditon in loop z is false. But z+1 == x. trip11: " << trip11 << ", trip: " << trip << ", stoptype11: " << stoptype11 << ", z: " << z << ", x: " << x << endl;
								if(DEBUG == 1) gse << "There's someone on the bus when we're trying to pick up an exluded mobility type so skipping this insert!" << endl;
								if(DEBUG == 1) gse << "End foundMobilityExclusion, returning true." << endl;
								return true;
							}else{
								if(DEBUG == 1) gse << "Conditon in loop z is false. And z+1 != x. trip11: " << trip11 << ", trip: " << trip << ", stoptype11: " << stoptype11 << ", z: " << z << ", x: " << x << endl;
							}
						}
					}else{
						if(DEBUG == 1) gse << "Second conditon in loop x is false. ambocc: " << ambocc << ", wcocc: " << wcocc << ", exmob2: " << exmob2 << ", exmob: " << exmob << endl;
					}
				}else{
					if(DEBUG == 1) gse << "First conditon in loop x is false. disposition2: " << disposition2 << ", stoptype2: " << stoptype2 << ", mobility2: " << mobility2 << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;
				}
			}
		}else{
			if(DEBUG == 1) gse << "Conditon in loop y is false. disposition: " << disposition << ", stoptype: " << stoptype << ", mobility: " << mobility << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;
		}
	}
	if(DEBUG == 1) gse << "End foundMobilityExclusion, returning false." << endl;
	return false;
}


bool foundMobilityExclusion_NIU(int * local_s_tab, int counter, string excludedmob1, string excludedmob2){
	if(DEBUG == 1) gse << "Begin foundMobilityExclusion, counter: " << counter << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;

	if(excludedmob1 == "" || excludedmob2 == ""){
		if(DEBUG == 1) gse << "Excluded mobilities returning false, excludedmob1 or excludedmob2 is empty. excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;
		return false;
	}

	/*
    bool furthercheck = false;
    for(int y = 0; y < counter; y++){
        //string disability1 = schd_tab[local_s_tab[y]][12];
        string trip = schd_tab[local_s_tab[y]][3];
        string stoptype = schd_tab[local_s_tab[y]][7];
        string mobility = schd_tab[local_s_tab[y]][12];
        if(stoptype == "P" && (mobility.find(excludedmob1,0)!=string::npos || mobility.find(excludedmob2,0)!=string::npos)){
            for(int x = y; x < counter; x++){
                string trip2 = schd_tab[local_s_tab[x]][3];
                string stoptype2 = schd_tab[local_s_tab[x]][7];
                string mobility2 = schd_tab[local_s_tab[x]][12];
                if(stoptype == "P" && (mobility2.find(excludedmob1,0)!=string::npos || mobility2.find(excludedmob2,0)!=string::npos)){
                    int ambocc = (int)to_number(schd_tab[local_s_tab[x]][31]);
                    int wcocc = (int)to_number(schd_tab[local_s_tab[x]][32]);

                        if(ambocc > 1 || wcocc > 1){
                            furthercheck =true;
                        }

                }
                if (furthercheck)
                    break;

            }

        }
        if (furthercheck)
            break;
    }
	 */


	//if(furthercheck){
	for(int a = 0; a < 500; a++){
		if(DEBUG == 1) gse << "local_s_tab[" << a <<"]: " << local_s_tab[a] << endl;
	}
	/* for(int a = 0; a < 100; a++){
            for(int b = 0; b < 200; b++){
                if(DEBUG == 1) gse << "schd_tab[" << a << "][" << b << "]: " << schd_tab[a][b] << endl;
            }
        } */

	if(DEBUG == 1) gse << "Excluded mobilities  " << excludedmob1 << " " << excludedmob2 << endl;
	for(int y = 0; y < counter; y++){
		string trip = schd_tab[local_s_tab[y]][3];
		string stoptype = schd_tab[local_s_tab[y]][7];
		string mobility = schd_tab[local_s_tab[y]][12];
		string disposition = schd_tab[local_s_tab[y]][DISPOSITION];


		if(DEBUG == 1) gse << "Inside for loop y. counter:  " << counter << ", y: " << y << ", trip: " << trip << ", stoptype: " << stoptype << ", mobility: " << mobility << ", disposition: " << disposition << endl;

		if(disposition != "N" && stoptype == "P" && (mobility.find(excludedmob1,0)!=string::npos || mobility.find(excludedmob2,0)!=string::npos)){

			string exmob;
			if(mobility.find(excludedmob1,0)!=string::npos)
				exmob = excludedmob1;
			else
				exmob = excludedmob2;

			if(DEBUG == 1) gse << "Conditon in loop y is true. disposition: " << disposition << ", stoptype: " << stoptype << ", mobility: " << mobility << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << ", exmob: " << exmob << endl;

			for(int x = y+1; x < counter; x++){
				string trip2 = schd_tab[local_s_tab[x]][3];
				string stoptype2 = schd_tab[local_s_tab[x]][7];
				string mobility2 = schd_tab[local_s_tab[x]][12];
				string disposition2 = schd_tab[local_s_tab[x]][DISPOSITION];
				if(DEBUG == 1) gse << "Inside for loop x. counter:  " << counter << ", y: " << y << ", x:" << x << ", trip2: " << trip2 << ", stoptype2: " << stoptype2 << ", mobility2: " << mobility2 << ", disposition2: " << disposition2 << endl;
				if( disposition2 != "N" && stoptype2 == "P" && (mobility2.find(excludedmob1,0)!=string::npos || mobility2.find(excludedmob2,0)!=string::npos)){
					string exmob2;
					if(mobility2.find(excludedmob1,0)!=string::npos)
						exmob2 = excludedmob1;
					else
						exmob2 = excludedmob2;

					int ambocc = (int)to_number(schd_tab[local_s_tab[x-1]][31]);
					int wcocc = (int)to_number(schd_tab[local_s_tab[x-1]][32]);

					if(DEBUG == 1) gse << "First conditon in loop x is true. disposition2: " << disposition2 << ", stoptype2: " << stoptype2 << ", mobility2: " << mobility2 << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << ", exmob2: " << exmob2 << ", ambocc: " << ambocc << ", wcocc: " << wcocc << endl;

					if((ambocc >= 1 || wcocc >= 1) && exmob2 != exmob){
						if(DEBUG == 1) gse << "Second conditon in loop x is true. ambocc: " << ambocc << ", wcocc: " << wcocc << ", exmob2: " << exmob2 << ", exmob: " << exmob << endl;
						for(int z = y+1; z <= x; z++){
							string trip11 = schd_tab[local_s_tab[z]][3];
							string stoptype11 = schd_tab[local_s_tab[z]][7];
							if(DEBUG == 1) gse << "Inside for loop z. counter:  " << counter << ", y: " << y << ", x:" << x << ", z: " << z << ", trip11: " << trip11 << ", stoptype11: " << stoptype11 << endl;
							if(trip11 == trip && stoptype11 == "D"){
								if(DEBUG == 1) gse << "Conditon in loop z is true. trip11: " << trip11 << ", trip: " << trip << ", stoptype11: " << stoptype11 << endl;
								if(DEBUG == 1) gse << "The drop off is before the next excluded mobility type so we're safe for now" << endl;
								break;
							}
							else if(z+1 >= x){
								if(DEBUG == 1) gse << "Conditon in loop z is false. But z+1 == x. trip11: " << trip11 << ", trip: " << trip << ", stoptype11: " << stoptype11 << ", z: " << z << ", x: " << x << endl;
								if(DEBUG == 1) gse << "There's someone on the bus when we're trying to pick up an exluded mobility type so skipping this insert!" << endl;
								if(DEBUG == 1) gse << "End foundMobilityExclusion, returning true." << endl;
								return true;
							}else{
								if(DEBUG == 1) gse << "Conditon in loop z is false. And z+1 != x. trip11: " << trip11 << ", trip: " << trip << ", stoptype11: " << stoptype11 << ", z: " << z << ", x: " << x << endl;
							}

						}
					}else{
						if(DEBUG == 1) gse << "Second conditon in loop x is false. ambocc: " << ambocc << ", wcocc: " << wcocc << ", exmob2: " << exmob2 << ", exmob: " << exmob << endl;
					}
				}else{
					if(DEBUG == 1) gse << "First conditon in loop x is false. disposition2: " << disposition2 << ", stoptype2: " << stoptype2 << ", mobility2: " << mobility2 << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;
				}
			}
		}else{
			if(DEBUG == 1) gse << "Conditon in loop y is false. disposition: " << disposition << ", stoptype: " << stoptype << ", mobility: " << mobility << ", excludedmob1: " << excludedmob1 << ", excludedmob2: " << excludedmob2 << endl;
		}

	}
	if(DEBUG == 1) gse << "End foundMobilityExclusion, returning false." << endl;
	return false;
	//}
	//else{
	// return false;
	//}







}



int F_GET_TRAVEL_TIME (int P_TRIP_TIME , string time_zone, string time_zone2)//, int VEL_PT, int VEL_WT, int  VEL_LT, int  VEL_ET,int  VEL_NT,int  VEL_HT)
{
	/* int  V_VEL_PT    = VEL_PT ;
      int V_VEL_WT   = VEL_WT   ;
      int V_VEL_LT   = VEL_LT ;
     int  V_VEL_ET    = VEL_ET  ;
      int V_VEL_NT  = VEL_NT   ;
      int V_VEL_HT   = VEL_HT   ; 
	 */
	if(DEBUG == 1) gse << "inside calculator.h - F_GET_TRAVEL_TIME(), time_zone: " << time_zone << ", P_TRIP_TIME: " << P_TRIP_TIME << endl;
	int v = 0;
	//  if(DEBUG == 1) gse << "P_TRIP_TIME is " << P_TRIP_TIME << endl;



	/* c[002] */

	/*return the amount of minutes a trip takes at certain time of the day*/

	/* if (P_TRIP_TIME == NULL)
      THEN
         RAISE_APPLICATION_ERROR (-20000, 'Invalid time');
      END if;*/

	/* c[002] */

	//  if(DEBUG == 1) gse << " time zone_ " << time_zone << endl;

	if (time_zone == "*")
		return 0;




	// if(DEBUG == 1) gse << "VEL  "  << V_VEL_PT[2] << endl;


	/* if (time_zone2!= "*")
      {
         time_zone = time_zone2;
      }*/

	/*-- Peak time AM*/

	//  if(DEBUG == 1) gse << ( 0/V_VEL_NT[v])*60 << endl;


	//  if(DEBUG == 1) gse << "Time zone " << time_zone << " " << P_TRIP_DISTANCE << " " << V_VEL_PT[v] <<endl;

	if (time_zone == "PTA"){
		// if(DEBUG == 1) gse << " PTa " << V_VEL_PT[v] << " " << v << endl;
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning ceil((P_TRIP_TIME * V_VEL_PT[0]) ) = " << ceil((P_TRIP_TIME * V_VEL_PT[0]) ) << endl;
		return ceil((P_TRIP_TIME * V_VEL_PT[0]) );
	}
	/*-- Peak time PM*/
	else if (time_zone == "PTP"){
		// if(DEBUG == 1) gse << " PTP " << V_VEL_PT[v] << " " << v << endl;
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning ceil((P_TRIP_TIME * V_VEL_PT[0])) = " << ceil((P_TRIP_TIME * V_VEL_PT[0])) << endl;
		return ceil((P_TRIP_TIME * V_VEL_PT[0]));
	}
	/*-- Work time*/

	else if (time_zone == "WT"){
		//  if(DEBUG == 1) gse << " PTP " << V_VEL_WT[v] << " " << v << endl;
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning ceil((P_TRIP_TIME * V_VEL_WT[0])) = " << ceil((P_TRIP_TIME * V_VEL_WT[0])) << endl;
		return ceil((P_TRIP_TIME * V_VEL_WT[0]));
	}
	/*-- Leisure time*/
	else if (time_zone == "LT"){
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning ceil((P_TRIP_TIME * V_VEL_LT[0])) = " << ceil((P_TRIP_TIME * V_VEL_LT[0])) << endl;
		return ceil((P_TRIP_TIME * V_VEL_LT[0]));
	/*-- Night time AM*/
	}
	else if (time_zone == "NTA"){
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning ceil((P_TRIP_TIME * V_VEL_NT[0])) = " << ceil((P_TRIP_TIME * V_VEL_NT[0])) << endl;
		return ceil((P_TRIP_TIME * V_VEL_NT[0]));
	}
	/*-- Night time PM*/
	else if (time_zone == "NTP"){
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning ceil((P_TRIP_TIME * V_VEL_NT[0])) = " << ceil((P_TRIP_TIME * V_VEL_NT[0])) << endl;
		return ceil((P_TRIP_TIME * V_VEL_NT[0]));
	/*-- Early time*/
	}
	else if (time_zone == "ET"){
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning ceil((P_TRIP_TIME * V_VEL_ET[0])) = " << ceil((P_TRIP_TIME * V_VEL_ET[0])) << endl;
		return ceil((P_TRIP_TIME * V_VEL_ET[0]));
	}
	else{
		if(DEBUG == 1) gse << "end calculator.h - time_zone  == " << time_zone << ", returning 0, RAISE_APPLICATION_ERROR(-20000,'Invalid time zone')" << endl;
		return 0;  /*--RAISE_APPLICATION_ERROR(-20000,'Invalid time zone');*/
	}

}





/*int F_GET_TRAVEL_TIME (double P_TRIP_DISTANCE , string time_zone, string time_zone2)//, int VEL_PT, int VEL_WT, int  VEL_LT, int  VEL_ET,int  VEL_NT,int  VEL_HT)
{

      int v = 0;


      for(int i = 0;i<VELOCITY;i++)  {       
            if( P_TRIP_DISTANCE >= velocityMinDist[i] && P_TRIP_DISTANCE < velocityMaxDist[i]){            
                v=i; break;
            }
      }

     //  if(DEBUG == 1) gse << " time zone_ " << time_zone << endl;

        if (time_zone == "*")
             return 0;




// if(DEBUG == 1) gse << "VEL  "  << V_VEL_PT[2] << endl;




  //  if(DEBUG == 1) gse << ( 0/V_VEL_NT[v])*60 << endl;


   //  if(DEBUG == 1) gse << "Time zone " << time_zone << " " << P_TRIP_DISTANCE << " " << V_VEL_PT[v] <<endl;

      if (time_zone == "PTA"){
      // if(DEBUG == 1) gse << " PTa " << V_VEL_PT[v] << " " << v << endl;
         return round((P_TRIP_DISTANCE / V_VEL_PT[v]) * 60);
      }

      else if (time_zone == "PTP"){
      // if(DEBUG == 1) gse << " PTP " << V_VEL_PT[v] << " " << v << endl;
         return round((P_TRIP_DISTANCE / V_VEL_PT[v]) * 60);
      }


      else if (time_zone == "WT")
     //  if(DEBUG == 1) gse << " PTP " << V_VEL_WT[v] << " " << v << endl;
         return round((P_TRIP_DISTANCE / V_VEL_WT[v]) * 60);

      else if (time_zone == "LT")
         return round((P_TRIP_DISTANCE / V_VEL_LT[v]) * 60);

      else if (time_zone == "NTA"){

         return round((P_TRIP_DISTANCE / V_VEL_NT[v]) * 60);
      }

      else if (time_zone == "NTP")

         return round((P_TRIP_DISTANCE / V_VEL_NT[v]) * 60);

      else if (time_zone == "ET")

         return round((P_TRIP_DISTANCE / V_VEL_ET[v]) * 60);
      else
         return 0;  


}
 */






bool CheckifBreak2(string spl, string ttype ) {

	if (spl.substr(0,1)=="BT" || (ttype == "BRK" || ttype =="LNCH" )) 
		return true;
	else
		return false;

}



int itms_to_minutes (string TM ) {
	int IN_HH;
	int IN_MM;
	string temphours ((TM.substr(0,2)));
	stringstream temphours2(temphours);
	temphours2 >> IN_HH;
	// if(DEBUG == 1) gse << " itmstominutes 1" << endl;
	string tempmin;
	try {
		tempmin =((TM.substr(2,2)));
	}
	catch(...)
	{
		if(DEBUG == 1) gse << "TM " << TM << endl;
	}

	//  if(DEBUG == 1) gse << " itmstominutes 2" << endl;
	stringstream tempmin2(tempmin);
	tempmin2 >> IN_MM;
	return (IN_HH*60)+IN_MM;
}





string itms_minutes_to_ampm(int TIM){
	int TM  = TIM;
	int TM1;
	int TM2  = TIM;
	char AMPM  = 'A';
	string TM1str="";
	string TMstr="";

	// if(DEBUG == 1) gse << "TIM " << TIM << endl;

	if (TIM < 0 || TIM > 1439 /*2359*/) {
		if (MILITARYTIME == 'F') {
			//  if(DEBUG == 1) gse << "returning 0000A" << endl;
			return "1159P"; // return the last minute of the day
		}
		else
			return "2359";

	}
	if (MILITARYTIME == 'F'){
		if (TM > 1440) {
			TM = 1430;
		}
		TM1 = floor(TM/60);
		if (TM1 - 13 >= 0) {
			TM = TM - 720; /* EQUIV. TO 1200HRS, IN MINUTES */
			TM1 = TM1 - 12;
			AMPM = 'P';
		}
		else if (TM1 == 12) {
			AMPM = 'P';
		}

		if(TM1 < 10) {TM1str = "0" + to_string(TM1);}else{TM1str=to_string(TM1);}
		if((TM - TM1*60) < 10) {TMstr = "0" + to_string((TM - TM1*60));}else{TMstr=to_string((TM - TM1*60));}

		return TM1str +TMstr+AMPM ;
	}
	else{
		TM1 = floor(TM/60);
		if (to_string(TM1)+to_string(TIM - TM1*60) < "2400"){

			return (to_string(TM1)+to_string(TM2 - TM1*60));
		}
		else{
			return "2359";
		}

	}

}

/*
bool isVolSegment(string segmentid, string travel_date, string driverid){

    string segmenttype = "";

    Environment *env = Environment::createEnvironment();
    Connection *conn = env->createConnection(username, password, connectString);

        string command1 = "SELECT segment_type FROM itms_segment WHERE driverid = '"+driverid+"' AND travel_date = '"+travel_date+"' AND segmentid = '"+segmentid+"'";
            Statement *stmt = conn->createStatement (command1);
             ResultSet *rs = stmt->executeQuery();

            while(rs->next()){
                segmenttype = rs->getString(1); //save into appropriate shared memory
            }


  stmt->closeResultSet(rs);
  conn->terminateStatement(stmt);

    if(segmenttype == "VOL"){


        env->terminateConnection(conn);
        env->terminateEnvironment(env);
        return true;
    }
    else{


        env->terminateConnection(conn);
        env->terminateEnvironment(env);
        return false;
    }


}
 */

void getCS_CY_cap(int &cs_cap, int &bs_cap, string segmenttype){
	/*
    Environment *env = Environment::createEnvironment();
    Connection *conn = env->createConnection(username, password, connectString);

        string command1 = "select featureid, featurevalue from itms_oe_registry where featureid = 'CS_CAP_AGENCY' or featureid ='CS_CAP_VOL' or featureid = 'CY_CAP_AGENCY' or featureid ='CY_CAP_VOL'";
          if(DEBUG == 1) gse << command1 <<endl;

            Statement *stmt = conn->createStatement (command1);
             ResultSet *rs = stmt->executeQuery();

            while(rs->next()){
                if(isVol){
                    if(rs->getString(1) == "CS_CAP_VOL"){
                        cs_cap = rs->getInt(2);
                    }
                    if(rs->getString(1) == "CY_CAP_VOL"){
                        bs_cap = rs->getInt(2);
                    }
                } 
                else{
                    if(rs->getString(1) == "CS_CAP_AGENCY"){
                        cs_cap = rs->getInt(2);
                    }
                    if(rs->getString(1) == "CY_CAP_AGENCY"){
                        bs_cap = rs->getInt(2);
                    }
                }
            }


  stmt->closeResultSet(rs);
  conn->terminateStatement(stmt);

    env->terminateConnection(conn);
    env->terminateEnvironment(env);
	 */

	if(segmenttype == "VOL"){
		cs_cap = cs_cap_vol[0];
		bs_cap = bs_cap_vol[0];
	}
	else{
		cs_cap = cs_cap_agency[0];
		bs_cap = bs_cap_agency[0];
	}
	if(cs_cap == 0){
		cs_cap = 999;
		if(DEBUG == 1) gse << "There was no registry value for child seat so setting to maximum " << endl;
	}
	if(bs_cap == 0){
		bs_cap = 999;
		if(DEBUG == 1) gse << "There was no registry value for booster seat so setting to maximum " << endl;
	}

	/*if(segmenttype == "VOL")
     if(DEBUG == 1) gse << "The child seat capacity is " << cs_cap << " and the booster seat capacity is " << bs_cap << " because it is a VOL segment." << endl;
else
 if(DEBUG == 1) gse << "The child seat capacity is " << cs_cap << " and the booster seat capacity is " << bs_cap << " because it is an AGENCY segment." << endl;
	 */
	return;


}



string ampm2fullhrs(string in_time){

	int IN_HH  ;
	int IN_MM   ;
	string IN_AP  ;



	if  (in_time != "0000" && ((in_time.find(':',0)== string::npos) && (in_time.find('.',0)== string::npos))) {
		if (MILITARYTIME == 'F'){
			string temphours ((in_time.substr(0,2)));

			stringstream temphours2(temphours);
			temphours2 >> IN_HH;
			string tempmin;

			try {
				tempmin =  ((in_time.substr(2,2)));
			}
			catch(...)
			{
				//  if(DEBUG == 1) gse << "In time " << in_time << endl;
				tempmin = "00";
			}


			stringstream tempmin2(tempmin);
			tempmin2 >> IN_MM;
			//IN_AP = in_time.substr(4,1) ;

			try {
				IN_AP = in_time.substr(4,1) ;
			}
			catch(...)
			{
				//   if(DEBUG == 1) gse << "In AP " <<  IN_AP << endl;
				IN_AP = "A";

			}

			/*** THIS IS FOR WILL CALL TIME 0000A OR 0000P ***/
			if (IN_HH==0 && IN_MM==0) {
				return "0000";//to_string(IN_HH)+to_string(IN_MM)+" " ;
			}
			if (IN_AP == "A") {
				if (IN_HH == 12) {
					IN_HH = 0 ;
				}
			}
			else{
				if (IN_HH != 12) {
					IN_HH = IN_HH + 12 ;
				}
			}
			string IN_HHstr = to_string(IN_HH);
			if(IN_HH < 10) {IN_HHstr = "0" + IN_HHstr;}
			string IN_MMstr = to_string(IN_MM);
			if(IN_MM < 10) {IN_MMstr = "0" + IN_MMstr;}


			return IN_HHstr+IN_MMstr  ;
		}

		else{
			// if(DEBUG == 1) gse << "returned " <<endl;
			return in_time;
		}

	}

	return "0000";

}







void getVelocity(Environment* env ,Connection* conn){

	// if(DEBUG == 1) gse << " here I am ";
	/*
int i = 0;
string command = "SELECT  MINDIST,MAXDIST,VEL_PT, VEL_WT,VEL_LT ,VEL_ET,VEL_NT,VEL_HT FROM  ITMS_TIME_PARAMETER";// WHERE "  + dist + " >= mindist AND "  + dist + " < maxdist union select 0 from  ITMS_TIME_PARAMETER WHERE not exists (SELECT  VEL_PT  FROM  ITMS_TIME_PARAMETER WHERE "  + dist + " >= mindist AND "  + dist + " < maxdist) and rownum <= 1";


               Statement* stmt = conn->createStatement (command);
               ResultSet * rset = stmt->executeQuery();
                while(rset->next()){
                    velocityMinDist[i] = rset->getInt(1);
                    velocityMaxDist[i] = rset->getInt(2);
                     V_VEL_PT[i] = (rset->getInt(3)); 
                     V_VEL_WT[i] = (rset->getInt(4));
                     V_VEL_LT[i] = rset->getInt(5);
                     V_VEL_ET[i] = rset->getInt(6);
                     V_VEL_NT[i] = rset->getInt(7);
                      V_VEL_HT[i] = rset->getInt(8);
                      i++;
                      // if(DEBUG == 1) gse << "in loop " <<  V_VEL_PT[i] << endl;
                }
                stmt->closeResultSet(rset);
                conn->terminateStatement(stmt);
                //for(int p = 0; p < i; p ++)
                   //  if(DEBUG == 1) gse << velocityMinDist[p] << " " << velocityMaxDist[p] << " " <<  V_VEL_PT[p] << " "<< V_VEL_WT[p] << " " << V_VEL_LT[p] << " " <<  V_VEL_ET[p] <<  " " <<  V_VEL_NT[p] << " " <<V_VEL_HT[p]<< endl; 
	 */

	double defaultosrm = 0.85;

	string command1 = "select featureid, featurevalue from itms_oe_registry where featureid = 'OSRMVELOCITYFACTOR'";

	Statement *stmt = conn->createStatement (command1);
	ResultSet *rs = stmt->executeQuery();

	while(rs->next()){
		if(rs->getString(1) == "OSRMVELOCITYFACTOR"){ //if this registry value is pulled from DB
			V_VEL_PT[0] =  rs->getDouble(2);
			V_VEL_WT[0] =  rs->getDouble(2);
			V_VEL_LT[0] =  rs->getDouble(2);
			V_VEL_ET[0] =  rs->getDouble(2);
			V_VEL_NT[0] =  rs->getDouble(2);
			V_VEL_HT[0] =  rs->getDouble(2); //save into appropriate shared memory
		}
	}

	if(V_VEL_PT[0] == 0){
		V_VEL_PT[0] =  defaultosrm;
		V_VEL_WT[0] =  defaultosrm;
		V_VEL_LT[0] =  defaultosrm;
		V_VEL_ET[0] =  defaultosrm;
		V_VEL_NT[0] =  defaultosrm;
		V_VEL_HT[0] =  defaultosrm; //save into appropriate shared memory
	}

	stmt->closeResultSet(rs);
	conn->terminateStatement(stmt);
}



bool ignore_depot(string segid, string p_customer, string ignore_depots_cutoff) 
{
	return false;
	int segidint;
	string segid1 ((segid.substr(0,segid.length())));
	stringstream segid2(segid1);
	segid2 >> segidint;

	int depots_cutoff;
	stringstream depots_cutoff2(ignore_depots_cutoff);
	depots_cutoff2 >> depots_cutoff;



	if ((p_customer == "ESSTS" &&  segidint >= 5300) || 
			(p_customer == "MART" &&  segidint >= 5000) ||  (p_customer == "DMR" &&  segidint >= 5000) ||
			(p_customer == "HLT" && segidint > 2000) ||
			segidint > depots_cutoff) {
		return true;
	}
	return false;

}



bool ignore_pu_time (string igputime){
	if(igputime == "")
		return false;

	if (igputime == ("I") || igputime == "T")
		return true;
	else
		return false;

	return false;
}



void updateRequest(int i, string value, string type){

	if(type == "FUNC"){
		strcpy(request_function[i], value.c_str());
	}
	if(type == "TIMESTAMP"){
		strcpy(request_timestamp[i], value.c_str());
	}
	if(type == "NUM"){
		strcpy(request_number[i], value.c_str());
	}
	if(type == "ID"){
		strcpy(request_id[i], value.c_str());
	}
	if(type == "LATLONG"){
		strcpy(request_latlon[i], value.c_str());
	}
	if(type == "DISTANCE"){
		strcpy(request_distance[i], value.c_str());
	}
	if(type == "TIME"){
		strcpy(request_time[i], value.c_str());
	}
	if(type == "EDGES"){
		strcpy(request_edges[i], value.c_str());
	}
	if(type == "TRIPIDX"){
		strcpy(request_tripidx[i], value.c_str());
	}
	if(type == "NUMBEROFEDGES"){ //changed to radius in meters
		strcpy(request_numberofedges[i], value.c_str());
	}

}

string fetchRequest(int i, string type){ // fetches osrm data from SHM, if it returns null, then there's no data in SHM

	if(type == "NUM"){
		return request_number[i];
	}
	if(type == "ID"){
		return request_id[i];
	}
	if(type == "LATLONG"){
		return request_latlon[i];
	}
	if(type == "FUNC"){
		return request_function[i];
	}
	if(type == "DISTANCE"){
		return request_distance[i];
	}
	if(type == "TIME"){
		return request_time[i];
	}
	if(type == "EDGES"){
		return request_edges[i];
	}
	if(type == "TRIPIDX"){
		return request_tripidx[i];
	}
	if(type == "NUMBEROFEDGES"){
		return request_numberofedges[i];
	}

	return "";

}



bool requestIsEmpty(int i){

	string empty = "";
	if(strcmp(request_function[i],empty.c_str()) == 0 && strcmp(request_timestamp[i],empty.c_str()) == 0
			&& strcmp(request_number[i],empty.c_str()) == 0 && strcmp(request_id[i],empty.c_str())==0 &&
			strcmp(request_latlon[i],empty.c_str())==0 && strcmp(request_distance[i], empty.c_str())==0 && strcmp(request_time[i], empty.c_str())==0 &&
			strcmp(request_edges[i], empty.c_str())==0 && strcmp(request_tripidx[i], empty.c_str())==0 &&
			strcmp(request_numberofedges[i], empty.c_str())==0){
		return true;
	}
	else
		return false;


}

void clearRequest(int i){
	string empty = "";

	strcpy(request_function[i],empty.c_str());
	strcpy(request_timestamp[i], empty.c_str());
	strcpy(request_number[i], empty.c_str());
	strcpy(request_id[i],empty.c_str());
	strcpy(request_latlon[i], empty.c_str());
	strcpy(request_distance[i], empty.c_str());
	strcpy(request_time[i], empty.c_str());
	strcpy(request_edges[i], empty.c_str());
	strcpy(request_tripidx[i], empty.c_str());
	strcpy(request_numberofedges[i], empty.c_str());
}





void getTimeZone(Environment* env ,Connection* conn){

	int i = 0;
	string zonestr;




	string command = "SELECT  ZONE, starttime, endtime FROM   ITMS_TIME_ZONES where zone not like '%-%'"      ;// WHERE " +  to_string(itms_to_minutes (ampm2fullhrs (p_eta))) + " BETWEEN starttime AND endtime union select '*' from    ITMS_TIME_ZONES WHERE  not exists (SELECT  ZONE FROM   ITMS_TIME_ZONES WHERE " +   to_string(itms_to_minutes (ampm2fullhrs (p_eta))) + " BETWEEN starttime AND endtime) and rownum <= 1";

	Statement* stmt = conn->createStatement (command);
	ResultSet * rset = stmt->executeQuery();

	while(rset->next()){
		zonestr = rset->getString(1);
		strcpy(zone[i], zonestr.c_str());
		starttime[i] = rset->getInt(2);
		endtime[i] = rset->getInt(3);
		//  if(DEBUG == 1) gse << rset->getInt(3) << endl;
		i++;


	}

	/*for(int p = 0; p < i;p++){
                                 if(DEBUG == 1) gse << zone[p] << " " << p << " " << starttime[p] << " " <<  endtime[p] << endl;
                            }*/


	stmt->closeResultSet(rset);
	conn->terminateStatement(stmt);



}

string timeZones(string p_eta, string p_promised_time){
	if(DEBUG == 1) gse << "begin calculator.h - timeZones(), p_promised_time: " << p_promised_time << endl;

	int timeint;
	string time_zone;



	/* if (p_promised_time.substr(0, 4) == "0000")
                {

                       stringstream p_etass(to_string(itms_to_minutes (ampm2fullhrs (p_eta))));
                     p_etass >> timeint;
                }*/
	//else{

	stringstream p_etass(to_string(itms_to_minutes (ampm2fullhrs (p_promised_time))));
	p_etass >> timeint;
	//}

	if(DEBUG == 1) gse << "begin calculator.h - timeZones(), timeint: " << timeint << endl;




	/*if (p_promised_time.substr(0, 4) == "0000")
                         {
                             if (timeint > 1439){ ///////////////////why?
                            p_eta = "1439";
                             }

                             int petainteger = itms_to_minutes (ampm2fullhrs (p_eta));
                             int z = 0;
                             for (int k = 0; k<15;k++){
                                    if(petainteger < endtime[k] && petainteger >= starttime[k]){
                                            z = k;
                                            break;
                                    }
                            }

                            time_zone = zone[z];
                           //  if(DEBUG == 1) gse << " Z  1 is " << z << " " << time_zone <<  endl;

                         }*/
	//else{
	if (timeint > 1439){
		p_promised_time = "1439";
	}


	int promiseinteger = itms_to_minutes (ampm2fullhrs (p_promised_time));

	int z = 0;
	for (int k = 0; k<MAXZONES;k++){
		if(promiseinteger <= endtime[k] && promiseinteger >= starttime[k]){

			// if(DEBUG == 1) gse << starttime[k] << " " << endtime[k] << endl;
			z = k;
			if(DEBUG == 1) gse << "calculator.h - timeZones() z = k = " << z << ", promiseinteger:" << promiseinteger << 
				", endtime[k]: " << endtime[k] << ", starttime[k]: " << starttime[k] << endl;
			break;
		}
	}

	time_zone = zone[z];
	// if(DEBUG == 1) gse << " Z 2 is " <<  z << " " << time_zone << endl;
	// }

	return time_zone;
	if(DEBUG == 1) gse << "end calculator.h - timeZones() returning: " << time_zone << endl;
}

#include <occi.h>

void gse_update(string client, string date){



	if(DEBUG == 1) gse << "Trying to connect to database " << endl;
	//  if(DEBUG == 1) gse << p_AMBLOAD[0] <<endl;
	// These will be passed as a parameter and not hard-coded
	Environment* env = Environment::createEnvironment();
	Connection* conn = env->createConnection( username, password, connectString );

	if(DEBUG == 1) gse << "Environment and Connection created" << endl;

	string aLabel = "";
	string  command = "SELECT * FROM itms_registry WHERE VARIABLEDATE = '01-JAN-2001' order by scheduler"; ////////for all zones
	int cc = 0;
	Statement * stmt;
	ResultSet * rs;
	try {
		if(DEBUG == 1) gse << command << endl;
		stmt = conn->createStatement (command);
		aLabel = "before executing above query";
		rs = stmt->executeQuery();
		aLabel = "after executing above query";
		if(DEBUG == 1) gse << aLabel << endl;
		if(DEBUG == 1) gse << rs->status() << " ;row count:" << rs->getNumArrayRows() << endl;
		int y = 0;
		int wl = 0;
		size_t aSize = sizeof(V_VEL_PT)/sizeof(V_VEL_PT[0]);
		if(DEBUG == 1) gse << "aSize: " << aSize << endl;
		for(size_t i = 0; i < aSize; i++)
		{
			// if(DEBUG == 1) gse << "V_VEL_PT[i]: " << V_VEL_PT[i] << endl;
		}
		size_t bSize = sizeof(starttime)/sizeof(starttime[0]);
		if(DEBUG == 1) gse << "bSize: " << bSize << endl;
		for(size_t i = 0; i < bSize; i++)
		{
			// if(DEBUG == 1) gse << "starttime[i]: " <<  starttime[i] << endl;
		}
		size_t cSize = sizeof(p_WHEELLOAD)/sizeof(p_WHEELLOAD[0]);
		if(DEBUG == 1) gse << "cSize: " << cSize << endl;
		try{
		while(rs->next()){
			cc = 0;
			try {
				// if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				// if(DEBUG == 1) gse << rs->getString(1).c_str() << endl;
				// if(DEBUG == 1) gse << rs->getString(2).c_str() << endl;
				// if(DEBUG == 1) gse << rs->getString(3).c_str() << endl;
				// if(DEBUG == 1) gse << rs->getString(4).c_str() << endl;
				// if(DEBUG == 1) gse << rs->getString(5).c_str() << endl;
				// if(DEBUG == 1) gse << rs->getInt(6) << endl;
				// if(DEBUG == 1) gse << rs->getString(7).c_str() << endl;
				// wl = rs->getInt(6);
				// if(DEBUG == 1) gse << "wl: " << wl << endl;
				// starttime[0] = 1;
				// if(DEBUG == 1) gse << "starttime[0]: " << starttime[0] << endl;
				// endtime[0] = 2;
				// if(DEBUG == 1) gse << "endtime[0]: " << endtime[0] << endl;
				// p_WHEELLOAD[y] = wl;
				// if(DEBUG == 1) gse << "assigned p_WHEELLOAD" << endl;
				// y++;
				// cc++;
				// continue;
				p_WHEELLOAD[y] = rs->getInt(6);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_AMBLOAD[y] = rs->getInt(7);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_MAXEARLYDROPOFFFACTOR[y] = rs->getInt(11);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_DIALRIDEEARLYPICKFACTOR[y] = rs->getInt(15);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_DIALRIDELATEPICKFACTOR[y] = rs->getInt(16);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_OTHEREARLYPICKFACTOR[y] = rs->getInt(17);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_OTHERLATEPICKFACTOR[y] = rs->getInt(18);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				strcpy(ignorepu[y], rs->getString(38).c_str());
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_SHORTBREAK[y] = rs->getInt(39);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_LUNCHBREAK[y] = rs->getInt(40);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				p_PROXIMITYFACTOR[y] = rs->getInt(42);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				strcpy(ZONE_DESCR[y],rs->getString(43).c_str());
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				a_mediumshortdistance[y] = to_number(rs->getString(10));
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				a_shorttriptime[y] = rs->getInt(9);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				a_longtriptime[y] = rs->getInt(8);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				a_mediumlongdistance[y] = to_number(rs->getString(32));
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				a_mediumtriptime[y] = rs->getInt(33);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				a_extra_loadtime[y] = rs->getInt(47);
				cc++;
				if(DEBUG == 1) gse << "y is " << y << "; cc is " << cc << endl;
				y++;
			}
			catch(...)
			{
				if(DEBUG == 1) gse << "Exception parsing result from - " << command << " ; y is " << y << "; cc is " << cc << endl;
			}
		}
		}catch(...){
			if(DEBUG == 1) gse << "error fetching data from itms_registry in gse_update()" << endl;
		}
		aLabel = "parsed all dataset, before closing result set";
		if(DEBUG == 1) gse << aLabel << endl;

		stmt->closeResultSet(rs);
		aLabel = "before terminating statement";
		conn->terminateStatement(stmt);
		aLabel = "after terminating statement";
	}
	catch(...)
	{
		if(DEBUG == 1) gse << "Exception executing query - " << command << "; aLabel is " << aLabel << endl;
	}



	string usenewcommands = "N";
	command = "select featureid, featurevalue from itms_oe_registry where featureid = 'UPDATEDBGSE'";
	if(DEBUG == 1) gse << command <<endl;

	stmt = conn->createStatement (command);
	rs = stmt->executeQuery();

	try{
	while(rs->next()){
		if(rs->getString(1) == "UPDATEDBGSE") //if this registry value is pulled from DB
			usenewcommands = rs->getString(2); //save into appropriate shared memory
	}
	}catch(...){
		if(DEBUG == 1) gse << "error fetching data from itms_oe_registry in gse_update()" << endl;
	}

	stmt->closeResultSet(rs);
	conn->terminateStatement(stmt);

	command = "SELECT featureid, featurevalue FROM itms_oe_registry WHERE FEATUREID = 'DW_VARIANCE_CHECK_SML'  OR FEATUREID = 'DW_VARIANCE_CHECK_MED' OR FEATUREID = 'DW_VARIANCE_CHECK_LNG' OR FEATUREID = 'StraightLineForSlack' or  FEATUREID='SAMEOUTBOUNDPREASSIGNMENT' OR FEATUREID='MAXSTOPNUM' OR FEATUREID='SAMEOUTBOUNDPREASSIGNMENT' or FEATUREID='USE_REVERSE_CALC' or FEATUREID = 'XTRTRAVTIME' or FEATUREID = 'HEADHOMETHRESHOLD' or   FEATUREID='MAXDEADHEADVARIANCE' or  FEATUREID='CALCULATE_GCOUNT_WC' or  featureid = 'EXTRA_GRP_TT' or featureid = 'PercentageToStopBatch' or featureid='OpenSegThreshold' or featureid='IGNORE_DEPOTS_CUTOFF' or featureid='NumberOfEdgesForNearest'";
	if(DEBUG == 1) gse << command << endl;

	DW_VARIANCE_CHECK_SML[0] = 0.5;
	DW_VARIANCE_CHECK_MED[0] = 0.4;
	DW_VARIANCE_CHECK_LNG[0] = 0.3;

	OPEN_SEG_THRESHOLD[0] = 0.5; //setting default values
	NUMBER_OF_EDGES[0] = 2000;
	strcpy(ACALCULATE_GCOUNT_WC[0], "Y");
	PERCENTAGETOSTOPBATCH[0] = 0.01;
	EXTRAGRPTT[0] = 0;
	MAXDEADHEADVARIANCE[0] = 1;
	//   if(DEBUG == 1) gse << "Before opening  " << endl;
	strcpy(USEREVERSECALC[0], "N");
	XTRTRAVTIME[0] = 1.2;
	HEADHOMETHRESHOLD[0]= .25;
	strcpy(SAMEOUTBOUNDPREASSIGNMENT[0],"N");
	strcpy(MAXSTOPNUM[0],"999");
	//  if(DEBUG == 1) gse << "After opening  " << endl;


	//   if(DEBUG == 1) gse << command << endl;

	stmt = conn->createStatement (command);
	rs = stmt->executeQuery();
	try{
	while(rs->next()){
		//  if(DEBUG == 1) gse << rs->getString(1) << endl;
		if(rs->getString(1) == "MAXSTOPNUM") //if this registry value is pulled from DB
			strcpy(MAXSTOPNUM[0],rs->getString(2).c_str()); //save into appropriate shared memory
		if(rs->getString(1) == "CALCULATE_GCOUNT_WC") //if this registry value is pulled from DB
			strcpy(ACALCULATE_GCOUNT_WC[0], rs->getString(2).c_str()); //save into appropriate shared memory
		if(rs->getString(1) == "IGNORE_DEPOTS_CUTOFF")
			strcpy(IGNORE_DEPOTS_CUTOFF[0], rs->getString(2).c_str());
		if(rs->getString(1) == "USE_REVERSE_CALC")
			strcpy(USEREVERSECALC[0], rs->getString(2).c_str());
		if(rs->getString(1) == "SAMEOUTBOUNDPREASSIGNMENT")
			strcpy(SAMEOUTBOUNDPREASSIGNMENT[0], rs->getString(2).c_str());
		if(rs->getString(1) == "OpenSegThreshold")
			OPEN_SEG_THRESHOLD[0] = rs->getDouble(2);
		if(usenewcommands == "N"){
			SLACK_THRESHOLD[0] = 20.0;
			if(rs->getString(1) == "StraightLineForSlack")
				SLACK_THRESHOLD[0] = rs->getDouble(2);
		}
		if(rs->getString(1) == "PercentageToStopBatch")
			PERCENTAGETOSTOPBATCH[0] = rs->getDouble(2);
		if(rs->getString(1) == "MAXDEADHEADVARIANCE")
			MAXDEADHEADVARIANCE[0] = rs->getDouble(2);
		if(rs->getString(1) == "XTRTRAVTIME")
			XTRTRAVTIME[0] = rs->getDouble(2);
		if(rs->getString(1) == "HEADHOMETHRESHOLD")
			HEADHOMETHRESHOLD[0] = rs->getDouble(2);


		if(rs->getString(1) == "DW_VARIANCE_CHECK_SML")
			DW_VARIANCE_CHECK_SML[0] = rs->getDouble(2);
		if(rs->getString(1) == "DW_VARIANCE_CHECK_MED")
			DW_VARIANCE_CHECK_MED[0] = rs->getDouble(2);
		if(rs->getString(1) == "DW_VARIANCE_CHECK_LNG")
			DW_VARIANCE_CHECK_LNG[0] = rs->getDouble(2);


		if(rs->getString(1) == "NumberOfEdgesForNearest")
			NUMBER_OF_EDGES[0] = rs->getInt(2);
		if(rs->getString(1) == "EXTRA_GRP_TT")
			EXTRAGRPTT[0] = rs->getInt(2);
	}
	}catch(...){
		if(DEBUG == 1) gse << "error fetching data from itms_oe_registry in gse_update() - 2" << endl;
	}


	stmt->closeResultSet(rs);
	conn->terminateStatement(stmt);


	string command1 = "select featureid, featurevalue from itms_oe_registry where featureid = 'CS_CAP_AGENCY' or featureid ='CS_CAP_VOL' or featureid = 'CY_CAP_AGENCY' or featureid ='CY_CAP_VOL'";
	if(DEBUG == 1) gse << command1 <<endl;

	stmt = conn->createStatement (command1);
	rs = stmt->executeQuery();

	try{
	while(rs->next()){
		if(rs->getString(1) == "CS_CAP_VOL")
			cs_cap_vol[0] = rs->getInt(2);

		if(rs->getString(1) == "CY_CAP_VOL")
			bs_cap_vol[0] = rs->getInt(2);

		if(rs->getString(1) == "CS_CAP_AGENCY")
			cs_cap_agency[0] = rs->getInt(2);

		if(rs->getString(1) == "CY_CAP_AGENCY")
			bs_cap_agency[0] = rs->getInt(2);
	}
	}catch(...){
		if(DEBUG == 1) gse << "error fetching data from itms_oe_registry in gse_update() - 3" << endl;
	}


	stmt->closeResultSet(rs);
	conn->terminateStatement(stmt);



	getVelocity(env, conn);

	//   if(DEBUG == 1) gse << "Velocity" << endl;
	//  if(DEBUG == 1) gse << "Found " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;
	getTimeZone(env,conn);

	//  if(DEBUG == 1) gse << "time" << endl;
	//   if(DEBUG == 1) gse << "Found " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;
	env->terminateConnection(conn);
	env->terminateEnvironment(env);

	if(DEBUG == 1) gse << "Finished updating " << endl;


	return;
}


void overwriteexclusionwithinclusion(int tripidx, int (*tempexclu_inclu)[MAXTRIPIDX][MAXSEGMENTS], string route){

	string include = route;

	if(include != "N/A"){
		if(DEBUG == 1) gse << "checking include" << endl;
		string temp = include;

		for(int m = 0; m < MAXSEGMENTS; m++){
			if(s_tab[m][0] == 0){
				break;
			}
			if(exclu_inclu[tripidx][m]!=1)
				exclu_inclu[tripidx][m] = 2; /////because there are included routes initialize all segments for that trip to 2 (will overwrite with 1 for the included routes in s_tab)
		}



		while(temp != ""){
			string token = getNextToken(&(temp),",");
			token = token.substr(1,token.length());
			int routeint = (int)to_number(token);
			int s_tab_index = -1;
			for(int m = 0; m < MAXSEGMENTS; m++){
				if(s_tab[m][0] == 0){
					break;
				}

				if(s_tab[m][0] == routeint){
					s_tab_index = m;
					break;
				}
			}
			if(s_tab_index != -1){
				(*tempexclu_inclu)[tripidx][s_tab_index] = 1;
			}
		}
	}

	return;
}

void populate_exclu_inclu_array(int tripidx){
	///exclu_inclu[TRIPIDIDX][S_TAB_INDEX];
	string tripid;
	string include;
	string exclude;


	//for(int k = 1; k < MAXTRIPIDX; k++){
	//if(strcmp((schd_tab[tripidx][10]), "") == 0 || strcmp((schd_tab[tripidx][37]), "") == 0){
	//break;
	//}
	include = "";
	exclude = "";
	tripid = schd_tab[tripidx][3];
	if(DEBUG == 1) gse << "In populate 1 " << tripid << " " << schd_tab[tripidx][7] << endl;
	tripid = tripid.substr(0,1);
	//tripidx = k;

	if(DEBUG == 1) gse << "In populate 2 " << tripid << " " << schd_tab[tripidx][7] << endl;

	if(tripid != "S" && strcmp((schd_tab[tripidx][7]), "P") == 0 /*&& exclu_inclu[tripidx][0] != 1 && exclu_inclu[tripidx][0] != 2*/){
		if(DEBUG == 1) gse << "Building matrix for " << schd_tab[tripidx][3] << endl;

		string alreadybuild = schd_tab[tripidx][BUILTEXCLUSION];
		if(alreadybuild == "Y"){
			if(DEBUG == 1) gse << "We already build the matrix so exiting" << endl;
			return;
		}

		include = exclusioninclusionlist[tripidx][INCLUDESEG];
		exclude = exclusioninclusionlist[tripidx][EXCLUDESEG];

		if(DEBUG == 1) gse << "include " << include << endl;
		if(DEBUG == 1) gse << "exclude "<< exclude << endl;

		if(include != "N/A"){
			if(DEBUG == 1) gse << "checking include" << endl;
			string temp = include;




			for(int m = 0; m < MAXSEGMENTS; m++){
				if(s_tab[m][0] == 0){
					break;
				}
				exclu_inclu[tripidx][m] = 2; /////because there are included routes initialize all segments for that trip to 2 (will overwrite with 1 for the included routes in s_tab)
			}

			while(temp != ""){
				string token = getNextToken(&(temp),",");
				token = token.substr(1,token.length());
				int routeint = (int)to_number(token);
				int s_tab_index = -1;
				for(int m = 0; m < MAXSEGMENTS; m++){
					if(s_tab[m][0] == 0){
						break;
					}

					if(s_tab[m][0] == routeint){
						s_tab_index = m;
						break;
					}
				}
				if(s_tab_index != -1){
					exclu_inclu[tripidx][s_tab_index] = 1;
				}
			}
		}
		else if(include == "N/A" && exclude != "N/A"){
			//  if(DEBUG == 1) gse << "checking exclude" << endl;

			for(int m = 0; m < MAXSEGMENTS; m++){
				if(s_tab[m][0] == 0){
					break;
				}
				exclu_inclu[tripidx][m] = 1; //because there are excluded routes initialize all segments for that trip to 'X' (will overwrite with 'E' for the included routes in s_tab)
			}

			string temp = exclude;

			while(temp != ""){
				string token = getNextToken(&(temp),",");
				token = token.substr(1,token.length());
				int routeint = (int)to_number(token);
				/// if(DEBUG == 1) gse << "Token " << routeint << endl;
				int s_tab_index = -1;
				for(int m = 0; m < MAXSEGMENTS; m++){
					if(s_tab[m][0] == 0){
						break;
					}
					if(s_tab[m][0] == routeint){
						// if(DEBUG == 1) gse << "Found index " << m << endl;
						s_tab_index = m;
						break;
					}
				}
				if(s_tab_index != -1){
					exclu_inclu[tripidx][s_tab_index] = 2;
				}
			}
		}
		else{

			for(int m = 0; m < MAXSEGMENTS; m++){
				if(s_tab[m][0] == 0){
					break;
				}
				exclu_inclu[tripidx][m] = 1; //initalize all to null for that tripid because there are no include or exclude;
			}
		}


	}

	strcpy(schd_tab[tripidx][BUILTEXCLUSION],"Y");

	//}
}

bool skipsegment(int tripidx, string route){

	//  if(DEBUG == 1) gse << "skipsegment " << tripidx << " " << route << endl;

	int routeint = (int)to_number(route.substr(1,route.length()));
	int s_tab_index = -1;

	for(int i = 0; i < MAXSEGMENTS; i++){
		if(s_tab[i][0] == routeint){
			s_tab_index = i;
			//  if(DEBUG == 1) gse << " index " << i << endl;
			break;
		}
	}

	if(s_tab_index == -1){
		if(DEBUG == 1) gse << "There was an error in skipsegment " << routeint << endl;
		return false;
	}

	if(exclu_inclu[tripidx][s_tab_index] == 1){
		if(DEBUG == 1) gse << "skipsegment: not skipping  " << schd_tab[tripidx][3] << " " << route << " "<< s_tab_index <<  " " <<  exclu_inclu[tripidx][s_tab_index] << endl;
		return false;
	}
	else{
		if(DEBUG == 1) gse << "skipsegment: skipping  " << schd_tab[tripidx][3] << " " << route << " "<< s_tab_index << endl;
		return true;
	}

}

bool skipsegmenttemp(int tripidx, string route, int (*tempinclusion)[MAXTRIPIDX][MAXSEGMENTS]){


	//   if(DEBUG == 1) gse << "skipsegment " << tripidx << " " << route << endl;

	int routeint = (int)to_number(route.substr(1,route.length()));
	int s_tab_index = -1;

	for(int i = 0; i < MAXSEGMENTS; i++){
		if(s_tab[i][0] == routeint){
			s_tab_index = i;
			if(DEBUG == 1) gse << " index " << i << endl;
			break;
		}
	}



	if(s_tab_index == -1){
		//  if(DEBUG == 1) gse << "There was an error in skipsegment " << routeint << endl;
		return false;
	}

	if((*tempinclusion)[tripidx][s_tab_index] == 1){
		if(DEBUG == 1) gse << "skipsegment: not skipping  " << schd_tab[tripidx][3] << " " << route << " "<< s_tab_index <<  " " <<  (*tempinclusion)[tripidx][s_tab_index] << endl;
		return false;
	}
	else{
		if(DEBUG == 1) gse << "skipsegment: skipping  " << schd_tab[tripidx][3] << " " << route << " "<< s_tab_index << endl;
		return true;
	}

}

bool hasincludedsegment(int tripidx){
	string include = exclusioninclusionlist[tripidx][INCLUDESEG];
	if(include != "N/A"){
		return true;
	}
	else{
		return false;
	}
}
bool hasincludedsegmenttemp(int tripidx, int (tempinclu)[MAXTRIPIDX][MAXSEGMENTS], string tempinclusr[MAXTRIPIDX]){


	string include = exclusioninclusionlist[tripidx][INCLUDESEG];
	if(include != "N/A"){
		return false;
	}
	else{

		if(tempinclusr[tripidx] != ""){
			return true;
		}

		return false;

	}

}







#include <boost/config.hpp> /* keep it first to prevent nasty warns in MSVC */
#include <algorithm>
#include <boost/algorithm/string/find.hpp>
#include <boost/interprocess/allocators/allocator.hpp>
#include <boost/interprocess/containers/string.hpp>
#include <boost/interprocess/managed_mapped_file.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>
#include <boost/interprocess/sync/scoped_lock.hpp>
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/member.hpp>
#include <iostream>
#include <iterator>
#include <sstream>
#include <tuple>
#include <string>

string getNextToken2ndPlace(string *str, string delimiter){

	size_t pos = 0;
	std::string token;
	int distances = 0;
	string tempstr = *str;

	iterator_range<string::iterator> r = find_nth(tempstr, ",", 1);
	distances = distance(tempstr.begin(), r.begin());

	if(distances != tempstr.length()){
		token = tempstr.substr(0, distances);
		str->erase(0,distances + delimiter.length());
	}
	else{
		token = *str;
		str->erase(0, str->length());
	}
	return token;

}


string padStr(string str){
	int toint;
	stringstream ss(str);
	ss >> toint;

	char buffer [50];
	sprintf (buffer, "%04d", toint);
	str = buffer;

	return str;
}


bool isSameLocation(int tripidx1, int tripidx2){
	double blat = to_number(schd_tab[tripidx1][10]);
	double gridlat = to_number(schd_tab[tripidx2][10]);
	double blon = to_number(schd_tab[tripidx1][37]);
	double gridlon = to_number(schd_tab[tripidx2][37]);
	double dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
	dist = sqrt(dist)*3959.0 * 3.1415/180;
	if(dist <= 0.056818182){
		try{
			if(DEBUG == 1) gse << "isSameLocation(" << tripidx1 << ", " << tripidx2 << ") returning true, dist = " << dist <<endl;
		}catch(...){
			if(DEBUG == 1) gse << "isSameLocation returning true, Exception printing" << endl;
		}
		return true;
	}
	else{
		try{
			if(DEBUG == 1) gse << "isSameLocation(" << tripidx1 << ", " << tripidx2 << ") returning false, dist = " << dist <<endl;
		}catch(...){
			if(DEBUG == 1) gse << "isSameLocation returning false, Exception printing" << endl;
		}
		return false;
	}
}

bool isSameLocation_passedLatLong(double lat, double lon, int tripidx2){
	double blat = lat;
	double gridlat = to_number(schd_tab[tripidx2][10]);
	double blon = lon;
	double gridlon = to_number(schd_tab[tripidx2][37]);
	double dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
	dist = sqrt(dist)*3959.0 * 3.1415/180;

	if(dist <= 0.056818182){
		return true;
	}
	else
		return false;
}

bool isSameLocation_onlyLatLong(double lat, double lon, double lat2, double lon2){
	double blat = lat;
	double gridlat = lat2;
	double blon = lon;
	double gridlon = lon2;
	double dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
	dist = sqrt(dist)*3959.0 * 3.1415/180;

	if(dist <= 0.056818182){
		return true;
	}
	else
		return false;
}





void groupSameLocationTrips(){
	if(DEBUG == 1) gse << "Finding same groups to ignore for findbest" <<endl;
	int groupindex = 0;

	for(int i = 1; i < MAXTRIPIDX; i++){
		if(strcmp(schd_tab[i][GROUPNUMBER],"")==0 && strcmp(schd_tab[i][0],"")==0 && strcmp(schd_tab[i][7],"P")==0){
			for(int j = i+1; j < MAXTRIPIDX; j++){

				int timeslot1 = (int)to_number(schd_tab[i][41]);
				int timeslot2 = (int)to_number(schd_tab[j][41]);
				if(strcmp(schd_tab[j][GROUPNUMBER],"")==0 && strcmp(schd_tab[j][0],"")==0 && strcmp(schd_tab[j][7],"P")==0 && isSameLocation(i,j) && isSameLocation(i+1,j+1) && (timeslot2 == timeslot1+1 || timeslot2 == timeslot1-1 || timeslot2 == timeslot1) /*&& strcmp(schd_tab[j][41],schd_tab[i][41])==0*/){
					strcpy(schd_tab[i][GROUPNUMBER],to_string(groupindex).c_str());
					strcpy(schd_tab[j][GROUPNUMBER],to_string(groupindex).c_str());
				}
				else if(strcmp(schd_tab[j][GROUPNUMBER],"")==0  && strcmp(schd_tab[j][7],"P")==0 &&  strcmp(schd_tab[i][17],schd_tab[j][17])==0 && strcmp(schd_tab[i][17],"")!=0 && strcmp(schd_tab[j][17],"")!=0){
					strcpy(schd_tab[i][GROUPNUMBER],to_string(groupindex).c_str());
					strcpy(schd_tab[j][GROUPNUMBER],to_string(groupindex).c_str());
				}

			}
			groupindex++;
		}

	}


	/*
int groupid = 1;

    for(int s = 0; s < MAXSEGMENTS; s++){
        if(s_tab[s][0] == 0)
            break;
        for(int k = 1; k <MAXSTOPS; k++){
            if(s_tab[s][k] == 0)
                break;

            if(strcmp(schd_tab[s_tab[s][k]][2],"999")!=0){
            if(strcmp(schd_tab[s_tab[s][k]][7],"D")==0 && strcmp(schd_tab[s_tab[s][k]][7],"D")==0  ){
                strcpy(schd_tab[s_tab[s][k]][GRPIDX],to_string(groupid).c_str());
                strcpy(schd_tab[(int)to_number(schd_tab[s_tab[s][k]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
                //int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
                //grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
            }
            if(strcmp(schd_tab[s_tab[s][k]][7],"D")==0 && strcmp(schd_tab[s_tab[s][k]][7],"P")==0 ){
                groupid++;
            }
        }

        }

    }
	 */
	if(DEBUG == 1) gse << "done finding same groups to ignore for findbest" <<endl;
}

int getTravTimeNoID(double lat, double lon, int do_aftershmid, string eta){



	string time_zone = timeZones("",itms_minutes_to_ampm((int)to_number(eta)));






	string running = "RUNNINGCALC";
	strcpy(shared_process_tab[WRITINGFB][0], running.c_str());


	int waitingforosrm = 0;
	int q;


	//if(strcmp(schd_tab[s_tab[i][g]][0], "")==0 || (strcmp(schd_tab[local_s_tab[g+1]][0], "")==0  && strcmp(schd_tab[s_tab[i][g]][2], MAXSTOPNUM[0])!=0) ){
	string lat1 = to_string(lat);
	string lon1 = to_string(lon);
	string lat2 = schd_tab[do_aftershmid][10];
	string lon2 = schd_tab[do_aftershmid][37];

	string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;

	for (int d = 0; d < MAXREQUESTS; d++)
	{

		if (requestIsEmpty(d))
		{
			//usleep(10);
			if (requestIsEmpty(d))
			{
				q = d;
				break;
			}
		}
		if (d + 1 == MAXREQUESTS)
			d = -1;
	}
	//  if(DEBUG == 1) gse << "q is " << q << endl;

	string function = "CalcDist";

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	char timebuffer[100];
	sprintf(timebuffer, "%s", asctime(&tm));
	string localtimestr = timebuffer;
	localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());

	updateRequest(q, "getTravTimeNoID", "NUM");
	updateRequest(q, function, "FUNC");
	updateRequest(q, localtimestr, "TIMESTAMP");
	updateRequest(q, to_string(0), "ID");
	updateRequest(q, osrm, "LATLONG");
	updateRequest(q, to_string(do_aftershmid), "TRIPIDX");

	waitingforosrm++;

	//}




	strcpy(shared_process_tab[WRITINGFB][0], "READY");
	int datafromosrm = 0;
	int timebetween = 0;
	while (true)
	{

		if (fetchRequest(q, "DISTANCE") != "" &&  fetchRequest(q, "TIME") != "" &&/*fetchRequest(q, "ID") == to_string(g) &&*/ fetchRequest(q, "NUM") == "getTravTimeNoID"&& fetchRequest(q, "FUNC") == "CalcDist")
		{
			timebetween = (int)to_number(fetchRequest(q, "TIME"));
			clearRequest(q);

			while(!requestIsEmpty(q)){
			}
			//f++;
			//g++;
			datafromosrm++;
			break;
		}



	}


	int trav_time = F_GET_TRAVEL_TIME (timebetween , time_zone, "*");







	return trav_time;
}

double getCost(int tripidx, int pu_aftershmid){
	double totalcost;
	double blat = to_number(schd_tab[tripidx][10]);
	double gridlat= to_number(schd_tab[pu_aftershmid][10]);
	double blon = to_number(schd_tab[tripidx][37]);
	double gridlon =to_number(schd_tab[pu_aftershmid][37]);
	double dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
	dist = sqrt(dist)*3959.0 * 3.1415/180;
	//double dist = (acos(1.0*sin(blat)*sin(gridlat)+cos(blat)*cos(gridlat)*cos(blon-gridlon)))*3959.87;
	totalcost = dist;
	return totalcost;
}

int getTime(int tripidx, int pu_aftershmid){
	string running = "RUNNINGCALC";
	strcpy(shared_process_tab[WRITINGFB][0], running.c_str());



	int waitingforosrm = 0;
	int q;


	//if(strcmp(schd_tab[s_tab[i][g]][0], "")==0 || (strcmp(schd_tab[local_s_tab[g+1]][0], "")==0  && strcmp(schd_tab[s_tab[i][g]][2], MAXSTOPNUM[0])!=0) ){
	string lat1 = schd_tab[tripidx][10];
	string lon1 = schd_tab[tripidx][37];
	string lat2 = schd_tab[pu_aftershmid][10];
	string lon2 = schd_tab[pu_aftershmid][37];

	string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;




	if(DEBUG == 1) gse << osrm << endl;

	for (int d = 0; d < MAXREQUESTS; d++)
	{

		if (requestIsEmpty(d))
		{
			//usleep(10);
			if (requestIsEmpty(d))
			{
				q = d;
				break;
			}
		}
		if (d + 1 == MAXREQUESTS)
			d = -1;
	}
	//  if(DEBUG == 1) gse << "q is " << q << endl;

	string function = "CalcDist";

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	char timebuffer[100];
	sprintf(timebuffer, "%s", asctime(&tm));
	string localtimestr = timebuffer;
	localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());

	updateRequest(q, "getTime", "NUM");
	updateRequest(q, function, "FUNC");
	updateRequest(q, localtimestr, "TIMESTAMP");
	updateRequest(q, to_string(0), "ID");
	updateRequest(q, osrm, "LATLONG");
	updateRequest(q, to_string(tripidx), "TRIPIDX");

	waitingforosrm++;

	//}




	strcpy(shared_process_tab[WRITINGFB][0], "READY");
	int datafromosrm = 0;
	int timebetween = 0;
	while (true)
	{

		if (fetchRequest(q, "DISTANCE") != "" &&   fetchRequest(q, "TIME") != "" &&/*fetchRequest(q, "ID") == to_string(g) &&*/ fetchRequest(q, "NUM") == "getTime"&& fetchRequest(q, "FUNC") == "CalcDist")
		{
			timebetween = (int)to_number(fetchRequest(q, "TIME"));
			clearRequest(q);
			while(!requestIsEmpty(q)){
			}
			//f++;
			//g++;
			datafromosrm++;
			break;
		}



	}




	return timebetween;
}
double getDist(int tripidx, int pu_aftershmid){
	string running = "RUNNINGCALC";
	strcpy(shared_process_tab[WRITINGFB][0], running.c_str());



	int waitingforosrm = 0;
	int q;


	//if(strcmp(schd_tab[s_tab[i][g]][0], "")==0 || (strcmp(schd_tab[local_s_tab[g+1]][0], "")==0  && strcmp(schd_tab[s_tab[i][g]][2], MAXSTOPNUM[0])!=0) ){
	string lat1 = schd_tab[tripidx][10];
	string lon1 = schd_tab[tripidx][37];
	string lat2 = schd_tab[pu_aftershmid][10];
	string lon2 = schd_tab[pu_aftershmid][37];

	string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;

	for (int d = 0; d < MAXREQUESTS; d++)
	{

		if (requestIsEmpty(d))
		{
			//usleep(10);
			if (requestIsEmpty(d))
			{
				q = d;
				break;
			}
		}
		if (d + 1 == MAXREQUESTS)
			d = -1;
	}
	//  if(DEBUG == 1) gse << "q is " << q << endl;

	string function = "NEEDDist";

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	char timebuffer[100];
	sprintf(timebuffer, "%s", asctime(&tm));
	string localtimestr = timebuffer;
	localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());

	updateRequest(q, "getDist", "NUM");
	updateRequest(q, function, "FUNC");
	updateRequest(q, localtimestr, "TIMESTAMP");
	updateRequest(q, to_string(0), "ID");
	updateRequest(q, osrm, "LATLONG");
	updateRequest(q, to_string(tripidx), "TRIPIDX");

	waitingforosrm++;

	//}




	strcpy(shared_process_tab[WRITINGFB][0], "READY");
	int datafromosrm = 0;
	double dist1 = 0;
	while (true)
	{

		if (fetchRequest(q, "DISTANCE") != "" && fetchRequest(q, "TIME") != "" &&/*fetchRequest(q, "ID") == to_string(g) &&*/ fetchRequest(q, "NUM") == "getDist"&& fetchRequest(q, "FUNC") == "NEEDDist")
		{
			dist1= to_number(fetchRequest(q, "DISTANCE"));
			clearRequest(q);
			while(!requestIsEmpty(q)){
			}
			//f++;
			//g++;
			datafromosrm++;
			break;
		}



	}



	return dist1;
}
double getDistNoID(double lat, double lon, int do_aftershmid){




	string running = "RUNNINGCALC";
	strcpy(shared_process_tab[WRITINGFB][0], running.c_str());


	int waitingforosrm = 0;
	int q;


	//if(strcmp(schd_tab[s_tab[i][g]][0], "")==0 || (strcmp(schd_tab[local_s_tab[g+1]][0], "")==0  && strcmp(schd_tab[s_tab[i][g]][2], MAXSTOPNUM[0])!=0) ){
	string lat1 = to_string(lat);
	string lon1 = to_string(lon);
	string lat2 = schd_tab[do_aftershmid][10];
	string lon2 = schd_tab[do_aftershmid][37];

	string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;

	for (int d = 0; d < MAXREQUESTS; d++)
	{

		if (requestIsEmpty(d))
		{
			//usleep(10);
			if (requestIsEmpty(d))
			{
				q = d;
				break;
			}
		}
		if (d + 1 == MAXREQUESTS)
			d = -1;
	}
	//  if(DEBUG == 1) gse << "q is " << q << endl;

	string function = "NEEDDist";

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	char timebuffer[100];
	sprintf(timebuffer, "%s", asctime(&tm));
	string localtimestr = timebuffer;
	localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());

	updateRequest(q, "getDistNoID", "NUM");
	updateRequest(q, function, "FUNC");
	updateRequest(q, localtimestr, "TIMESTAMP");
	updateRequest(q, to_string(0), "ID");
	updateRequest(q, osrm, "LATLONG");
	updateRequest(q, to_string(do_aftershmid), "TRIPIDX");

	waitingforosrm++;

	//}




	strcpy(shared_process_tab[WRITINGFB][0], "READY");
	int datafromosrm = 0;
	int dist1 = 0;
	while (true)
	{

		if (fetchRequest(q, "DISTANCE") != ""  &&  fetchRequest(q, "TIME") != "" && /*fetchRequest(q, "ID") == to_string(g) &&*/ fetchRequest(q, "NUM") == "getDistNoID"&& fetchRequest(q, "FUNC") == "NEEDDist")
		{
			dist1 = (int)to_number(fetchRequest(q, "DISTANCE"));
			clearRequest(q);
			while(!requestIsEmpty(q)){
			}
			//f++;
			//g++;
			datafromosrm++;
			break;
		}



	}










	return dist1;
}

double getCost_notripid(double lat, double lon, int pu_aftershmid){
	double totalcost;
	double blat = lat;
	double gridlat= to_number(schd_tab[pu_aftershmid][10]);
	double blon = lon;
	double gridlon =to_number(schd_tab[pu_aftershmid][37]);
	double dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
	dist = sqrt(dist)*3959.0 * 3.1415/180;
	//double dist = (acos(1.0*sin(blat)*sin(gridlat)+cos(blat)*cos(gridlat)*cos(blon-gridlon)))*3959.87;
	totalcost = dist;
	return totalcost;
}

double getCost_latlong(double lat, double lon, double lat1, double lon1){
	double totalcost;
	double blat = lat;
	double gridlat= lat1;
	double blon = lon;
	double gridlon =lon1;
	double dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
	dist = sqrt(dist)*3959.0 * 3.1415/180;
	//double dist = (acos(1.0*sin(blat)*sin(gridlat)+cos(blat)*cos(gridlat)*cos(blon-gridlon)))*3959.87;
	totalcost = dist;
	return totalcost;
}

void set_registry_values( int & p_WHEELLOAD1, int & p_AMBLOAD1,
		int & p_MAXEARLYDROPOFFFACTOR1,int & p_DIALRIDEEARLYPICKFACTOR1,int & p_DIALRIDELATEPICKFACTOR1,int & p_OTHEREARLYPICKFACTOR1, int & p_OTHERLATEPICKFACTOR1,string & IGNOREPUTIMES1,int & p_SHORTBREAK1,int & p_LUNCHBREAK1, int & p_PROXIMITYFACTOR1, int & a_mediumshortdistance1,int & a_mediumlongdistance1,int & a_shorttriptime1,
		int & a_longtriptime1,int & a_mediumtriptime1,int & a_extra_loadtime1, string & ZONE_DESCR1,string & IGNORE_DEPOTS_CUTOFF1, string pReturn_trip, string pDisability, string p_trip_type1){

	if (pDisability.find("OT", 0) != string::npos)
	{
		for (int z = 0; z < MAXZONES; z++)
		{
			if (strcmp("OT", ZONE_DESCR[z]) == 0)
			{
				p_WHEELLOAD1 = p_WHEELLOAD[z];
				p_AMBLOAD1 = p_AMBLOAD[z];
				p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z];
				p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z];
				p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
				p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z];
				p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z];
				IGNOREPUTIMES1 = ignorepu[z];
				p_SHORTBREAK1 = p_SHORTBREAK[z];
				p_LUNCHBREAK1 = p_LUNCHBREAK[z];
				p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z];
				a_mediumshortdistance1 = a_mediumshortdistance[z];
				a_mediumlongdistance1 = a_mediumlongdistance[z];
				a_shorttriptime1 = a_shorttriptime[z];
				a_longtriptime1 = a_longtriptime[z];
				a_mediumtriptime1 = a_mediumtriptime[z];
				a_extra_loadtime1 = a_extra_loadtime[z];
				ZONE_DESCR1 = ZONE_DESCR[z];
				IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
				break;
			}
			if (z + 1 == MAXZONES)
			{
				for (int b = 0; b < MAXZONES; b++)
				{

					if (strcmp("ALL", ZONE_DESCR[b]) == 0)
					{
						p_WHEELLOAD1 = p_WHEELLOAD[b];
						p_AMBLOAD1 = p_AMBLOAD[b];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b];
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b];
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b];
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b];
						IGNOREPUTIMES1 = ignorepu[b];
						p_SHORTBREAK1 = p_SHORTBREAK[b];
						p_LUNCHBREAK1 = p_LUNCHBREAK[b];
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b];
						a_mediumshortdistance1 = a_mediumshortdistance[b];
						a_mediumlongdistance1 = a_mediumlongdistance[b];
						a_shorttriptime1 = a_shorttriptime[b];
						a_longtriptime1 = a_longtriptime[b];
						a_mediumtriptime1 = a_mediumtriptime[b];
						a_extra_loadtime1 = a_extra_loadtime[b];
						ZONE_DESCR1 = ZONE_DESCR[b];
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
						break;
					}
				}
			}
		}
	}
	else if (pDisability.find("OT", 0) == string::npos)
	{
		for (int z = 0; z < MAXZONES; z++)
		{
			if (strcmp(p_trip_type1.c_str(), ZONE_DESCR[z]) == 0)
			{
				p_WHEELLOAD1 = p_WHEELLOAD[z];
				p_AMBLOAD1 = p_AMBLOAD[z];
				p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z];
				p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z];
				p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
				p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z];
				p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z];
				IGNOREPUTIMES1 = ignorepu[z];
				p_SHORTBREAK1 = p_SHORTBREAK[z];
				p_LUNCHBREAK1 = p_LUNCHBREAK[z];
				p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z];
				a_mediumshortdistance1 = a_mediumshortdistance[z];
				a_mediumlongdistance1 = a_mediumlongdistance[z];
				a_shorttriptime1 = a_shorttriptime[z];
				a_longtriptime1 = a_longtriptime[z];
				a_mediumtriptime1 = a_mediumtriptime[z];
				a_extra_loadtime1 = a_extra_loadtime[z];
				ZONE_DESCR1 = ZONE_DESCR[z];
				IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
				break;
			}
			if (z + 1 == MAXZONES)
			{
				for (int b = 0; b < MAXZONES; b++)
				{
					if (strcmp("ALL", ZONE_DESCR[b]) == 0)
					{
						p_WHEELLOAD1 = p_WHEELLOAD[b];
						p_AMBLOAD1 = p_AMBLOAD[b];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b];
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b];
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b];
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b];
						IGNOREPUTIMES1 = ignorepu[b];
						p_SHORTBREAK1 = p_SHORTBREAK[b];
						p_LUNCHBREAK1 = p_LUNCHBREAK[b];
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b];
						a_mediumshortdistance1 = a_mediumshortdistance[b];
						a_mediumlongdistance1 = a_mediumlongdistance[b];
						a_shorttriptime1 = a_shorttriptime[b];
						a_longtriptime1 = a_longtriptime[b];
						a_mediumtriptime1 = a_mediumtriptime[b];
						a_extra_loadtime1 = a_extra_loadtime[b];
						ZONE_DESCR1 = ZONE_DESCR[b];
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];

						//   if(DEBUG == 1) gse << "using all " << b << " " <<  a_shorttriptime[b] << " " << a_mediumtriptime[b] << " " << a_longtriptime[b] << endl;
						break;
					}
				}
			}
		}
	}

	return;


}


void set_p_perf_time(string pDisposition,string pDisability,int & p_perf_time, int  p_WHEELLOAD1, int p_AMBLOAD1, int a_extra_loadtime1){


	if(pDisposition == "N"){
		p_perf_time = 0;
		return;
	}
	else{
		if (pDisability.find("WC", 0) != string::npos || pDisability.find("SC", 0) != string::npos || pDisability.find("DOSLOW", 0) != string::npos)
		{
			p_perf_time = p_WHEELLOAD1;
		}
		else if (pDisability.find("XLT", 0) != string::npos)
		{
			p_perf_time = a_extra_loadtime1; //p_EXTRA_LOADTIME;
		}
		else
		{
			p_perf_time = p_AMBLOAD1;
		}

		return ;
	}
}


int getActualDistance(int tripidx, int do_aftershmid){





	string running = "RUNNINGCALC";
	strcpy(shared_process_tab[WRITINGFB][0], running.c_str());

	int waitingforosrm = 0;
	int q;


	//if(strcmp(schd_tab[s_tab[i][g]][0], "")==0 || (strcmp(schd_tab[local_s_tab[g+1]][0], "")==0  && strcmp(schd_tab[s_tab[i][g]][2], MAXSTOPNUM[0])!=0) ){
	string lat1 = schd_tab[tripidx][10];
	string lon1 = schd_tab[tripidx][37];
	string lat2 = schd_tab[do_aftershmid][10];
	string lon2 = schd_tab[do_aftershmid][37];

	string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;

	for (int d = 0; d < MAXREQUESTS; d++)
	{

		if (requestIsEmpty(d))
		{
			//usleep(10);
			if (requestIsEmpty(d))
			{
				q = d;
				break;
			}
		}
		if (d + 1 == MAXREQUESTS)
			d = -1;
	}
	//  if(DEBUG == 1) gse << "q is " << q << endl;

	string function = "CalcDist";

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	char timebuffer[100];
	sprintf(timebuffer, "%s", asctime(&tm));
	string localtimestr = timebuffer;
	localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());

	updateRequest(q, "getTravTime", "NUM");
	updateRequest(q, function, "FUNC");
	updateRequest(q, localtimestr, "TIMESTAMP");
	updateRequest(q, to_string(0), "ID");
	updateRequest(q, osrm, "LATLONG");
	updateRequest(q, to_string(tripidx), "TRIPIDX");

	waitingforosrm++;

	//}




	strcpy(shared_process_tab[WRITINGFB][0], "READY");
	int datafromosrm = 0;
	int timebetween = 0;
	while (true)
	{

		if (fetchRequest(q, "DISTANCE") != "" &&  fetchRequest(q, "TIME") != "" &&/*fetchRequest(q, "ID") == to_string(g) &&*/ fetchRequest(q, "NUM") == "getTravTime"&& fetchRequest(q, "FUNC") == "CalcDist")
		{
			timebetween = (int)to_number(fetchRequest(q, "DISTANCE"));
			clearRequest(q);
			while(!requestIsEmpty(q)){
			}
			//f++;
			//g++;
			datafromosrm++;
			break;
		}


	}

	//  if(DEBUG == 1) gse << "The time zone is : " << time_zone << " " << trav_time << " " << dist  << endl;




	return timebetween;
}

int getTravTime_passedEta(int tripidx, int do_aftershmid, string eta, string eta2){

	//  if(DEBUG == 1) gse <<"Gettng travel time start : " << endl;
	//int64_t osrmtime = starttimer(FILE1);
	double dist;


	/*if(strcmp(schd_tab[tripidx][0],"")==0 && strcmp(schd_tab[do_aftershmid][0],"")==0){
                                        dist = to_number(schd_tab[tripidx][21]);
                                    }
                                    else{

                                        double blat = to_number(schd_tab[tripidx][10]);
                                        double gridlat = to_number(schd_tab[do_aftershmid][10]);
                                        double blon = to_number(schd_tab[tripidx][37]);
                                        double gridlon = to_number(schd_tab[do_aftershmid][37]);
                                        dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
                                        dist = sqrt(dist)*3959.0 * 3.1415/180;
                                    //double dist = (acos(1.0*sin(blat)*sin(gridlat)+cos(blat)*cos(gridlat)*cos(blon-gridlon)))*3959.87;
                                    //getTimeZone(env ,conn);
                                    }*/
	string time_zone = timeZones("",itms_minutes_to_ampm((int)to_number(eta)));
	string time_zone2 = timeZones("",itms_minutes_to_ampm((int)to_number(eta2)));



	string running = "RUNNINGCALC";
	strcpy(shared_process_tab[WRITINGFB][0], running.c_str());

	//  if(DEBUG == 1) gse <<"Gettng writing osrm : " << endl;
	//endtimer(osrmtime, FILE1);

	int waitingforosrm = 0;
	int q;


	//if(strcmp(schd_tab[s_tab[i][g]][0], "")==0 || (strcmp(schd_tab[local_s_tab[g+1]][0], "")==0  && strcmp(schd_tab[s_tab[i][g]][2], MAXSTOPNUM[0])!=0) ){
	string lat1 = schd_tab[tripidx][10];
	string lon1 = schd_tab[tripidx][37];
	string lat2 = schd_tab[do_aftershmid][10];
	string lon2 = schd_tab[do_aftershmid][37];

	string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;

	for (int d = 0; d < MAXREQUESTS; d++)
	{

		if (requestIsEmpty(d))
		{
			//usleep(10);
			if (requestIsEmpty(d))
			{
				q = d;
				break;
			}
		}
		if (d + 1 == MAXREQUESTS)
			d = -1;
	}
	//  if(DEBUG == 1) gse << "q is " << q << endl;

	string function = "CalcDist";

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	char timebuffer[100];
	sprintf(timebuffer, "%s", asctime(&tm));
	string localtimestr = timebuffer;
	localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());

	updateRequest(q, "getTravTime_passedEta", "NUM");
	updateRequest(q, function, "FUNC");
	updateRequest(q, localtimestr, "TIMESTAMP");
	updateRequest(q, to_string(0), "ID");
	updateRequest(q, osrm, "LATLONG");
	updateRequest(q, to_string(tripidx), "TRIPIDX");

	waitingforosrm++;

	//}




	strcpy(shared_process_tab[WRITINGFB][0], "READY");


	//  if(DEBUG == 1) gse <<"Gettng reading osrm : " << endl;
	//endtimer(osrmtime, FILE1);
	int datafromosrm = 0;
	int timebetween = 0;
	while (true)
	{

		if (fetchRequest(q, "DISTANCE") != "" &&  fetchRequest(q, "TIME") != "" &&/*fetchRequest(q, "ID") == to_string(g) &&*/ fetchRequest(q, "NUM") == "getTravTime_passedEta" && fetchRequest(q, "FUNC") == "CalcDist")
		{
			timebetween = (int)to_number(fetchRequest(q, "TIME"));
			clearRequest(q);
			while(!requestIsEmpty(q)){
			}
			//f++;
			//g++;
			datafromosrm++;
			break;
		}



	}

	//  if(DEBUG == 1) gse <<"Gettng f_gettravtime : " << endl;
	//endtimer(osrmtime, FILE1);


	int trav_time = F_GET_TRAVEL_TIME (timebetween , time_zone, "*");
	int trav_time2 = F_GET_TRAVEL_TIME (timebetween , time_zone2, "*");



	//  if(DEBUG == 1) gse << "The time zone is : " << time_zone << " " << trav_time << " " << dist  << endl;


	//  if(DEBUG == 1) gse <<"Gettng travel time end : " << endl;
	//endtimer(osrmtime, FILE1);

	if(trav_time > trav_time2)
		return trav_time;
	else
		return trav_time2;
}


void clearSlack(int timeslot, int cluster, int tripidx){

	bool tripFound = false;
	int tripcnt;
	// int starttm = starttimer(MONITOR1);

	tripcnt = ts_tab[timeslot][cluster][SLACK][0];
	// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;
	tripFound = false;
	for(int i = 1; i <= tripcnt; i++){
		// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
		if(abs(ts_tab[timeslot][cluster][SLACK][i])== tripidx){
			tripFound = true;
			for(int z = i; z <= tripcnt;z ++){
				ts_tab[timeslot][cluster][SLACK][z] = ts_tab[timeslot][cluster][SLACK][z+1];
			}
			break;
		}

	}
	if(tripFound){
		ts_tab[timeslot][cluster][SLACK][0] = tripcnt-1;
		ts_tab[timeslot][cluster][SLACK][tripcnt] = 0;
	}


	//  if(DEBUG == 1) gse << "Cleared Slack for Trip "<< tripidx << " for clusterid " << clusterid << endl;
}

//////////////////////////searchtimeslotclustermatch/////////////////
bool searchtimeslotclustermatch(string route, string wc,string inslack,double outsideofellipsevar, double maxdeviationfromstop_slack, string tripids, double maxfirststopdeadhead ){ //s_tab[m][1] : search to see if this route has any unassigned trips that can fit on it




	if(DEBUG == 1) gse << "in searchtimeslotclustermatch " <<  route << endl;

	int tripidx;
	int triptimeslot ;
	int tripcluster ;
	string tripneighbors ;
	int cid;
	string routeneighbors;
	string temp;
	int cidroute;
	string a_route = route;
	int routeint = (int)to_number(a_route.substr(1,a_route.length()));
	int p_WHEELLOAD1;
	int p_AMBLOAD1;
	int p_MAXEARLYDROPOFFFACTOR1;
	int p_DIALRIDEEARLYPICKFACTOR1;
	int p_DIALRIDELATEPICKFACTOR1;
	int p_OTHEREARLYPICKFACTOR1;
	int p_OTHERLATEPICKFACTOR1;
	string IGNOREPUTIMES1;
	int p_SHORTBREAK1;
	int p_LUNCHBREAK1;
	int p_PROXIMITYFACTOR1;
	int a_mediumshortdistance1;
	int a_mediumlongdistance1;
	int a_shorttriptime1;
	int a_longtriptime1;
	int a_mediumtriptime1;
	int a_extra_loadtime1;
	string ZONE_DESCR1;
	string IGNORE_DEPOTS_CUTOFF1;






	for(int m = 0; m < MAXSEGMENTS; m++){
		if(s_tab[m][0] == routeint){ // find the route
			//  if(DEBUG == 1) gse << "Found the route " << endl;
		for(int k = 1; k < MAXSTOPS; k++){ // for every stop on route
			if(s_tab[m][k]==0)
				break;


			int t1;
			int t2;

			//  if(DEBUG == 1) gse << "k is " << k << endl;

			if(strcmp(schd_tab[s_tab[m][k]][2],"1")!=0){ //if not the first stop

				string pReturn_trip1 = schd_tab[s_tab[m][k - 1]][18];
				string pDisability1 = schd_tab[s_tab[m][k - 1]][12];
				string p_trip_type1 = schd_tab[s_tab[m][k - 1]][8];


				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type1);


				int aEarlypickup;
				int aEarlydropoff;
				int aLatepickup;





				if (pDisability1.find("LP",0) != string::npos){
					aEarlypickup = 0;
					aEarlydropoff = 0;
				}
				else{
					if (pReturn_trip1 == "Y"){
						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
						/* C[006] */
						//   if(DEBUG == 1) gse << "here5 " << endl;
					}
					else{
						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
						//   if(DEBUG == 1) gse << "here4 " << endl;
					}
				}





				string pDisability = schd_tab[s_tab[m][k]][12];
				string pReturn_trip = schd_tab[s_tab[m][k]][18];
				string p_trip_type = schd_tab[s_tab[m][k]][8];

				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type);


				if (pDisability.find("OT",0) != string::npos)
				{
					if (pReturn_trip == "Y"){

						aLatepickup = p_OTHERLATEPICKFACTOR1;
						//   if(DEBUG == 1) gse << "here5 " << endl;
					}
					else{

						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
						//   if(DEBUG == 1) gse << "here4 " << endl;
					}
				}
				else if (pDisability.find("LP",0) != string::npos){

					aLatepickup = 0;
					//  if(DEBUG == 1) gse << "here3 " << endl;
				}
				else{
					//aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
					//aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

					if (pReturn_trip == "Y"){


						aLatepickup = p_OTHERLATEPICKFACTOR1;
						//    if(DEBUG == 1) gse << "here2 " << endl;
					}
					else{

						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
						//  if(DEBUG == 1) gse << "here1 " << endl;
					}
				}


				if(strcmp(schd_tab[s_tab[m][k-1]][7],"P")==0){
					t1 = (int)ceil((to_number(schd_tab[s_tab[m][k-1]][4]) - aEarlypickup) ); // eta
				}
				else{
					t1 = (int)ceil((to_number(schd_tab[s_tab[m][k-1]][4]) - aEarlydropoff) ); // eta
				}

				if((int)ceil(to_number(schd_tab[s_tab[m][k-1]][30])) > t1){
					t1 = (int)ceil(to_number(schd_tab[s_tab[m][k-1]][30]));

				}

				if(strcmp(schd_tab[s_tab[m][k]][7],"P")==0){
					if((int)to_number(schd_tab[s_tab[m][k]][26]) > 0){
						t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][26]));
					}
					else{
						t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][30]));
					}
				}
				else{
					if((int)to_number(schd_tab[s_tab[m][k]][27]) > 0){
						t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][27]));
					}
					else{
						t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][30]));
					}
				}

				if((int)ceil(to_number(schd_tab[s_tab[m][k]][4])) > t2){
					t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][4]));
				}

				//int t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][4])/15); // promise time

				int segmentstart = s_tab[m][1];
				int segmentend;

				for(int z = 1; z < MAXSTOPS; z++){
					if(s_tab[m][z] == 0){
						segmentend = s_tab[m][z-1];
						break;
					}
				}

				//  if(DEBUG == 1) gse << "new verison" << endl;


				if(t1 > (int)to_number(schd_tab[segmentend][4]))
					t1 = (int)to_number(schd_tab[segmentend][4]);


				if(t2 > (int)to_number(schd_tab[segmentend][4]))
					t2 = (int)to_number(schd_tab[segmentend][4]);

				if(DEBUG == 1) gse << "New stop " << k << endl;
				//int etd = (int)to_number(schd_tab[s_tab[m][k-1]][30]);
				// int prom = (int)to_number(schd_tab[s_tab[m][k]][4]);
				int slack = t2 - t1;
				int endofsegtime = 0;
				if(strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])==0){
					endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][4]);
					if(DEBUG == 1) gse << "The trip before is " << schd_tab[s_tab[m][k-1]][3]  << " " << schd_tab[s_tab[m][k-1]][7] << " With time " << schd_tab[s_tab[m][k-1]][4] << endl;
					if(DEBUG == 1) gse << "The trip after is " << schd_tab[s_tab[m][k]][3] << " " << schd_tab[s_tab[m][k]][7] <<  " With time " << endofsegtime<<  endl;
				}
				else{
					if(strcmp(schd_tab[s_tab[m][k]][7], "P")==0){
						if((int)to_number(schd_tab[s_tab[m][k]][26])>0)
							endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][26]) + aLatepickup ;
						else
							endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][4])  + aLatepickup ;

						if(DEBUG == 1) gse << "The trip before is " << schd_tab[s_tab[m][k-1]][3]  << " " << schd_tab[s_tab[m][k-1]][7] << " With time " << schd_tab[s_tab[m][k-1]][4] << endl;
						if(DEBUG == 1) gse << "The trip after is " << schd_tab[s_tab[m][k]][3] << " " << schd_tab[s_tab[m][k]][7] <<  " With time " << endofsegtime - aLatepickup << " " << aLatepickup << endl;
					}
					else{
						if((int)to_number(schd_tab[s_tab[m][k]][27])>0)
							endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][27]);
						else
							endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][4]);

						if(DEBUG == 1) gse << "The trip before is " << schd_tab[s_tab[m][k-1]][3]  << " " << schd_tab[s_tab[m][k-1]][7] << " With time " << schd_tab[s_tab[m][k-1]][4] << endl;
						if(DEBUG == 1) gse << "The trip after is " << schd_tab[s_tab[m][k]][3]  << " " << schd_tab[s_tab[m][k]][7] << " With time " << endofsegtime << endl;

					}

				}



				//  if(DEBUG == 1) gse << "End of seg time is " << endofsegtime << endl;
				t2 = ceil(t2/15);
				t1 = ceil(t1/15);

				int wc_cap = (int)to_number(schd_tab[s_tab[m][1]][34]);
				int amb_cap = (int)to_number(schd_tab[s_tab[m][1]][33]);
				int cs_cap;
				int cy_cap;


				getCS_CY_cap(cs_cap, cy_cap, schd_tab[s_tab[m][1]][SEGMENTTYPE]);


				//t2 = (int)to_number(schd_tab[s_tab[m][k]][4])/15;
				//t1 = (int)to_number(schd_tab[s_tab[m][k-1]][29])/15;

				if(t2-t1 >= 0){ // if there's slack

					//  if(DEBUG == 1) gse << "Theres slack " << endl;

					for (int i = 1; i < MAXTRIPIDX;i++){

						if(strcmp(schd_tab[i][10],"")==0)
							break;

						string trip = schd_tab[i][3];
						if(tripids!= "" && tripids.find(trip,0)==string::npos)
							continue;

						if ( strcmp(schd_tab[i][0],"")==0 && strcmp(schd_tab[i][7],"P")==0){ // if it's a pickup and unassigned trip
							string  p_disability = schd_tab[i][12];
							if((wc == "WC" && (p_disability.find("WC", 0) != string::npos || wc == "WC" && p_disability.find("SC", 0) != string::npos || wc == "WC" && p_disability.find("DOSLOW", 0) != string::npos) ) || wc != "WC" ){
								tripidx = i;
								int timethreshold = (segmentend - segmentstart)*HEADHOMETHRESHOLD[0];
								timethreshold = segmentend - timethreshold;
								int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));

								triptimeslot = (int)to_number(schd_tab[tripidx][41]);
								tripcluster = (int)to_number(schd_tab[tripidx][42]);
								tripneighbors = schd_tab[tripidx][NEIGHBORS];
								int aLatepickup2;
								int prechecktime;

								if(strcmp(schd_tab[s_tab[m][k]][7],"P")==0){
									string pReturn_trip12 = schd_tab[s_tab[m][k]][18];
									string pDisability12 = schd_tab[s_tab[m][k]][12];
									string p_trip_type12 = schd_tab[s_tab[m][k]][8];


									set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
											p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
											a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip12,  pDisability12,p_trip_type12);


									if (pDisability12.find("OT",0) != string::npos)
									{
										if (pReturn_trip12 == "Y"){

											aLatepickup2 = p_OTHERLATEPICKFACTOR1;
											//   if(DEBUG == 1) gse << "here5 " << endl;
										}
										else{

											aLatepickup2 = p_DIALRIDELATEPICKFACTOR1;
											//   if(DEBUG == 1) gse << "here4 " << endl;
										}
									}
									else if (pDisability12.find("LP",0) != string::npos){

										aLatepickup2 = 0;
										//  if(DEBUG == 1) gse << "here3 " << endl;
									}
									else{
										//aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
										//aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

										if (pReturn_trip12 == "Y"){


											aLatepickup2 = p_OTHERLATEPICKFACTOR1;
											//    if(DEBUG == 1) gse << "here2 " << endl;
										}
										else{

											aLatepickup2 = p_DIALRIDELATEPICKFACTOR1;
											//  if(DEBUG == 1) gse << "here1 " << endl;
										}
									}
									if((int)to_number(schd_tab[s_tab[m][k]][26]) ==0){
										prechecktime =  (int)to_number(schd_tab[s_tab[m][k]][4]) +  90 - getCost(tripidx+1,s_tab[m][k]);
									}
									else{
										prechecktime = (int)to_number(schd_tab[s_tab[m][k]][4]) + aLatepickup2 + floor((RELAXCONSTRAINTS[0] - 1)*50) - getCost(tripidx+1,s_tab[m][k]);
									}


								}
								else{
									if((int)to_number(schd_tab[s_tab[m][k]][27]) ==0 && (int)to_number(schd_tab[s_tab[m][k]][2]) != (int)to_number(MAXSTOPNUM[0])){
										prechecktime =  (int)to_number(schd_tab[s_tab[m][k]][4]) +  90 - getCost(tripidx+1,s_tab[m][k]);
									}
									else{
										prechecktime = (int)to_number(schd_tab[s_tab[m][k]][4]) + floor((RELAXCONSTRAINTS[0] - 1)*50) - getCost(tripidx+1,s_tab[m][k]);
									}
								}


								int segmenttimebefore = (int)to_number(schd_tab[s_tab[m][k - 1]][41]);
								//  if(DEBUG == 1) gse << "Segment time before = " << segmenttimebefore << endl;
								if(triptimeslot >= segmenttimebefore -1 && (int)to_number(schd_tab[tripidx+1][4]) <= prechecktime
										//&& (int)to_number(schd_tab[s_tab[m][k]][31]) == 0 && (int)to_number(schd_tab[s_tab[m][k]][32]) == 0
								){ //if not the first stop

									//  if(DEBUG == 1) gse << "Examining trip  " << schd_tab[tripidx][3] << " " << schd_tab[tripidx][4] <<  endl;





									pDisability = schd_tab[tripidx][12];
									pReturn_trip = schd_tab[tripidx][18];
									p_trip_type1 = schd_tab[tripidx][8];
									set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
											p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
											a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);
									int p_perf_time;
									string pDisposition = schd_tab[tripidx][DISPOSITION];
									set_p_perf_time(pDisposition,pDisability,p_perf_time,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);



									string est_traveltime1 = schd_tab[tripidx][22];

									if (pDisability.find("LP",0) != string::npos){
										aEarlypickup = 0;
										aEarlydropoff = 0;
									}
									else{
										if (pReturn_trip == "Y"){
											aEarlypickup = p_OTHEREARLYPICKFACTOR1;
											aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
											/* C[006] */
											//   if(DEBUG == 1) gse << "here5 " << endl;
										}
										else{
											aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
											aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
											//   if(DEBUG == 1) gse << "here4 " << endl;
										}
									}

									if (pDisability.find("OT",0) != string::npos)
									{
										if (pReturn_trip == "Y"){

											aLatepickup = p_OTHERLATEPICKFACTOR1;
											//   if(DEBUG == 1) gse << "here5 " << endl;
										}
										else{

											aLatepickup = p_DIALRIDELATEPICKFACTOR1;
											//   if(DEBUG == 1) gse << "here4 " << endl;
										}
									}
									else if (pDisability.find("LP",0) != string::npos){

										aLatepickup = 0;
										//  if(DEBUG == 1) gse << "here3 " << endl;
									}
									else{
										//aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
										//aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

										if (pReturn_trip == "Y"){


											aLatepickup = p_OTHERLATEPICKFACTOR1;
											//    if(DEBUG == 1) gse << "here2 " << endl;
										}
										else{

											aLatepickup = p_DIALRIDELATEPICKFACTOR1;
											//  if(DEBUG == 1) gse << "here1 " << endl;
										}
									}





									/* int triptimeslot2 = (int)to_number(schd_tab[tripidx+1][41]);
                        int segtimeslot;
                        if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0){
                            segtimeslot = (int)to_number(schd_tab[s_tab[m][k]][41]);
                        }
                       else{
                           segtimeslot = (int)to_number(schd_tab[s_tab[m][k]][41])  + (aLatepickup2/15)+1;
                       }*/


									if( triptimeslot >=t1 && triptimeslot <= t2 /*&& triptimeslot2 <= segtimeslot*/)
										if(DEBUG == 1) gse << "Examining trip  " << schd_tab[tripidx][3] << " " << schd_tab[tripidx][4] << " " << schd_tab[tripidx+1][4] <<   endl;
										else
											continue;




									for(int t = t1; t <=t2; t++){

										if(triptimeslot == t){ //if there's slack in the timeslot for the trip



											int extraperftime = 0;
											int wc_occ = (int)to_number(schd_tab[s_tab[m][k-1]][32]);
											int amb_occ = (int)to_number(schd_tab[s_tab[m][k-1]][31]);
											int cs_occ = (int)to_number(schd_tab[s_tab[m][k-1]][CS_OCC]);
											int cy_occ = (int)to_number(schd_tab[s_tab[m][k-1]][BS_OCC]);


											string pReturn_trip = schd_tab[tripidx][18];
											string pDisability = schd_tab[tripidx][12];
											string p_trip_type1 = schd_tab[tripidx][8];

											int escort = (int)to_number(schd_tab[tripidx][13]);

											if (pDisability.find("WC",0)!= string::npos || pDisability.find("SC",0)!= string::npos){
												wc_occ = wc_occ + 1;
												amb_occ = amb_occ + escort + 1;
											}

											else if (pDisability.find("CS",0)!= string::npos ){
												amb_occ = amb_occ + escort + 1;
												cs_occ++;
											}

											else if (pDisability.find("CY",0)!= string::npos ){
												amb_occ = amb_occ + escort + 1;
												cy_occ++;
											}
											else{
												amb_occ = amb_occ + escort + 1;
											}

											bool skiproute1 = false;
											int groupnumber = 0;

											for(int u = 1; u < MAXTRIPIDX; u++){
												if(strcmp(schd_tab[u][10],"")==0)
													break;

												if(strcmp(schd_tab[u][0],"")==0 && strcmp(schd_tab[u][7],"P")==0  && u!= tripidx &&  ((isSameLocation(u,tripidx) && isSameLocation(u+1,tripidx+1)&&strcmp(schd_tab[u][41],schd_tab[tripidx][41])==0) || (strcmp(schd_tab[u][GRPIDX],"")!=0 &&strcmp(schd_tab[u][GRPIDX],schd_tab[tripidx][GRPIDX])==0 ))){

													if(DEBUG == 1) gse << "Same location or group id as " << schd_tab[tripidx][3] << " --- " << schd_tab[u][3] << " group id " << schd_tab[u][GRPIDX] << endl;
													groupnumber++;

													skiproute1 = skipsegment(u, schd_tab[s_tab[m][k]][0]);
													if(skiproute1){
														break;
													}

													string pReturn_trip = schd_tab[u][18];
													string pDisability = schd_tab[u][12];
													string p_trip_type1 = schd_tab[u][8];

													int escort = (int)to_number(schd_tab[u][13]);

													if (pDisability.find("WC",0)!= string::npos || pDisability.find("SC",0)!= string::npos){
														wc_occ = wc_occ + 1;
														amb_occ = amb_occ + escort;
													}

													else if (pDisability.find("CS",0)!= string::npos ){
														amb_occ = amb_occ + escort + 1;
														cs_occ++;
													}

													else if (pDisability.find("CY",0)!= string::npos ){
														amb_occ = amb_occ + escort + 1;
														cy_occ++;
													}
													else{
														amb_occ = amb_occ + escort + 1;
													}

													set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
															p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
															a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);
													int p_perf_time;

													string pDisposition = schd_tab[u][DISPOSITION];
													set_p_perf_time(pDisposition,pDisability,p_perf_time,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
													extraperftime = extraperftime + p_perf_time;


												}

											}

											if(skiproute1){
												if(DEBUG == 1) gse << "Conflicting exclusion/inclusion" << endl;
												break;
											}
											if(wc_occ > wc_cap || amb_occ > amb_cap || cs_occ > cs_cap || cy_occ > cy_cap){

												if(DEBUG == 1) gse << "no space " << endl;
												if(DEBUG == 1) gse << wc_occ  << " > " <<  wc_cap << " or " << amb_occ  << " > " << amb_cap << " or " << cs_occ  << " > " <<  cs_cap << " or " << cy_occ  << " > " <<  cy_cap <<endl;
												break;

											}


											if(DEBUG == 1) gse << "We are starting to examine " << schd_tab[tripidx][3] << " direct pu clusters " << schd_tab[tripidx][42] << " " << schd_tab[s_tab[m][k-1]][42] << " direct do clusters " << schd_tab[tripidx+1][42] << " " << schd_tab[s_tab[m][k]][42]
																																																																									  << " neighbors " << schd_tab[s_tab[m][k-1]][NEIGHBORS] << " / " << schd_tab[s_tab[m][k]][NEIGHBORS] << endl;


											if(strcmp(schd_tab[tripidx][42],schd_tab[s_tab[m][k-1]][42])==0){
												string tempneighbors =  schd_tab[s_tab[m][k]][NEIGHBORS];
												int tripcluster2 = (int)to_number(schd_tab[tripidx+1][42]);
												while(tempneighbors != ""){
													int cidroute = (int)to_number(getNextToken(&(tempneighbors),","));
													if(tripcluster2 == cidroute || tripcluster2 == (int)to_number(schd_tab[s_tab[m][k]][42])){


														//  if(DEBUG == 1) gse << "The clusters directly match!" << endl;
														bool skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
														if(!skiproute){

															if(strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0){
																if(DEBUG == 1) gse << "We are exmaining the first stop so checking distance!"<< endl;
																double distance = getActualDistance(s_tab[m][k-1],tripidx);
																if(distance > maxfirststopdeadhead && ((inslack == "Y" && (strcmp(schd_tab[s_tab[m][k-1]][2],"1")!=0 || strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0))|| (inslack == "E"))){
																	if(DEBUG == 1) gse << "There's too much deadhead in the beginning of the segment" << endl;
																	continue;
																}
															}

															string starttime1 = schd_tab[tripidx][26];
															string endtime1 = schd_tab[tripidx][27];
															int est_time;

															if((int)to_number(starttime1)!= 0){
																est_time = (int)to_number(starttime1);
															}
															else{
																est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
															}
															int trav_time =   (int)to_number(schd_tab[s_tab[m][k-1]][30]) + getTravTime_passedEta(s_tab[m][k-1],tripidx, to_string(est_time),"0");
															int tripstarttime = (int)to_number(schd_tab[tripidx][26]);

															if(DEBUG == 1) gse << "starting with time "<< (int)to_number(schd_tab[s_tab[m][k-1]][30]) << " " <<  trav_time - (int)to_number(schd_tab[s_tab[m][k-1]][30]) << endl;


															if (trav_time < tripstarttime + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50) && tripstarttime > 0){


																if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																	trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}
																else{
																	trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}


																if (to_number(schd_tab[tripidx][27]) > 0)
																{
																	if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																	if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																	{
																		break;
																	}

																}


																if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																	trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																}

																if((int)to_number(endtime1)!= 0)
																	est_time = (int)to_number(endtime1);
																else{
																	est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																}
																trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																if(endofsegtime > 0  ){

																	if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																		if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																			int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																			int doeta1 = trav_time;
																			int actualTT = doeta1 - puetd1;
																			if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																			string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																			string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																			double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																			string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																			string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																			//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																			int groupcnter = 1;
																			routeint = (int)to_number(a_route.substr(1, a_route.length()));
																			//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																			for (int i = 0; i < MAXSEGMENTS; i++)
																			{
																				if (s_tab[i][0] == routeint)
																				{
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[i][g] == s_tab[m][k-1])
																						{

																							while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																								groupcnter++;
																								g--;
																							}
																							//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																							break;
																						}
																					}
																					break;
																				}
																			}
																			groupcnter = groupcnter + groupnumber;



																			int aAllowedTT;
																			if(estdisttrip < a_mediumshortdistance1)
																				aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																				aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else
																				aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																			if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																				aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																			}

																			if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																				//
																				if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																				if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																				break; ////to ensure that the insertion will not make the stop before which I insert late.

																			}


																		}
																		//  if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																		int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																		int segend;
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[m][g] == 0)
																			{
																				segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																				break;

																			}
																		}
																		int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																		int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																		timethreshold = segend - timethreshold;
																		bool docalc = true;

																		if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																				|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																		){


																			double threshold;

																			if(inslack == "Y"){
																				threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																			}
																			else{
																				threshold = EXTRASLACK[0];
																			}


																			double pudev;
																			double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}


																			docalc = false;

																			if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																				double distpu =  getCost(tripidx, s_tab[m][k]);
																				double distdo = getCost(tripidx+1, s_tab[m][k]);
																				if(isSameLocation(tripidx+1,s_tab[m][k])){
																					distdo = 0;
																				}
																				double cost = getCost(tripidx, s_tab[m][k-1]);

																				if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																					distpu = 0;
																					if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																						//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																							distdo = 0;
																						}
																					}

																					if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																						if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}
																					else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																						if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}

																			}
																			else{

																				double distdo = getCost(tripidx+1, s_tab[m][k]);

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}

																				if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																					if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																					docalc = true;

																				}
																			}

																			if(!docalc){
																				break;
																			}


																		}

																		bool isLate = false;
																		int w = k;
																		int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																		while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																			string pDisability2 = schd_tab[s_tab[m][w]][12];
																			string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																			string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																			int p_perf_time2;
																			string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);







																			if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																			if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																				AGRPCOUNTER = AGRPCOUNTER + 1;
																			else{
																				if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																				{
																					APRVGRPCOUNTER = AGRPCOUNTER + 1;
																				}
																				AGRPCOUNTER = 0;
																			}


																			if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																					if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}


																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																			else{

																				if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}

																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																			}

																			}







																			int aEarlypickup;
																			int aEarlydropoff;
																			int t1;

																			if (pDisability2.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip2 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}


																			string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																			string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																			string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																			int p_perf_time3;
																			pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																			if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																				if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}
																			else{
																				if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}


																			int p_eta;
																			if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																				p_eta = previouseta;
																			}
																			else{
																				p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																			}

																			nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																			if (pDisability3.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}

																			int aLatepickup;
																			if (pDisability3.find("OT",0) != string::npos)
																			{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{

																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			else if (pDisability3.find("LP",0) != string::npos){
																				aLatepickup = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{
																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}




																			bool preassigntripchange = true;

																			int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																			int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																			if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																			}
																			string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																			if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																				preassigntripchange = false;
																				if ((p_stop_type == "P") && starttime1 != 0  ) {
																					if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																					{
																						int dev =  p_eta - (starttime1 + aLatepickup);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}

																					}
																				}


																				if ((p_stop_type == "D") && (endtime1) != 0)
																				{
																					if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																					{
																						int dev =  p_eta - (endtime1);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}
																					}
																				}
																			}




																			if(preassigntripchange){
																				if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																						isLate = true;
																						break;
																					}

																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																					//break;
																					//}
																				}
																				else{

																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																						isLate = true;
																						break;
																					}
																					else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							isLate = true;
																							break;}
																					}
																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																						//  break;
																						//}

																				}
																			}
																			else{
																				if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																			}
																			w++; previouseta = p_eta;
																		}

																		if(isLate){
																			break;
																		}



																		/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/

																		if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;

																		return true;








																	}

																}
																else{

																	if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																		int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																		int doeta1 = trav_time;
																		int actualTT = doeta1 - puetd1;
																		if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																		string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																		string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																		double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																		string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																		string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																		//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																		int groupcnter = 1;
																		routeint = (int)to_number(a_route.substr(1, a_route.length()));
																		//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																		for (int i = 0; i < MAXSEGMENTS; i++)
																		{
																			if (s_tab[i][0] == routeint)
																			{
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[i][g] == s_tab[m][k-1])
																					{

																						while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																							groupcnter++;
																							g--;
																						}
																						//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																						break;
																					}
																				}
																				break;
																			}
																		}
																		groupcnter = groupcnter + groupnumber;
																		int aAllowedTT;
																		if(estdisttrip < a_mediumshortdistance1)
																			aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																			aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else
																			aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																		}

																		if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																			//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																			//
																			if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																			if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																			break; ////to ensure that the insertion will not make the stop before which I insert late.

																		}


																	}
																	//  if(DEBUG == 1) gse << "No end time " << endl;
																	int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																	int segend;
																	for (int g = 1; g < MAXSTOPS; g++)
																	{
																		if (s_tab[m][g] == 0)
																		{
																			segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																			break;

																		}
																	}
																	int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																	int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																	timethreshold = segend - timethreshold;
																	bool docalc = true;

																	if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																			|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																	){
																		double threshold;

																		if(inslack == "Y"){
																			threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																		}
																		else{
																			threshold = EXTRASLACK[0];
																		}


																		double pudev;
																		double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																		if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																			if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																				pudev = getCost(pickupafterstop,puid);
																				dodev = getCost(doid,  dropoffafterstop);
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																				dodev = pudev;

																			}
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid);
																			dodev = 0;
																		}


																		docalc = false;

																		if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																			double distpu =  getCost(tripidx, s_tab[m][k]);
																			double distdo = getCost(tripidx+1, s_tab[m][k]);
																			if(isSameLocation(tripidx+1,s_tab[m][k])){
																				distdo = 0;
																			}
																			double cost = getCost(tripidx, s_tab[m][k-1]);

																			if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																				if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																				distpu = 0;
																				if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																					//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																						distdo = 0;
																					}
																				}

																				if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																					if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}
																				else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																					if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}

																		}else{

																			double distdo = getCost(tripidx+1, s_tab[m][k]);

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}

																			if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																				if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																				docalc = true;

																			}
																		}

																		if(!docalc){
																			break;
																		}}

																	bool isLate = false;
																	int w = k;
																	int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																	while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																		string pDisability2 = schd_tab[s_tab[m][w]][12];
																		string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																		string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																		int p_perf_time2;
																		string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																		set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																		if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																		if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																			AGRPCOUNTER = AGRPCOUNTER + 1;
																		else{
																			if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																			{
																				APRVGRPCOUNTER = AGRPCOUNTER + 1;
																			}
																			AGRPCOUNTER = 0;
																		}


																		if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																			if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																				if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																				p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																			}


																			if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																				APRVGRPCOUNTER = 0;
																			}
																		}
																		else{

																			if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}

																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																		}

																		}
																		int aEarlypickup;
																		int aEarlydropoff;
																		int t1;

																		if (pDisability2.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip2 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}


																		string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																		string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																		string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																		int p_perf_time3;
																		pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																		set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																		if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																			if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}
																		else{
																			if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}


																		int p_eta;
																		if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																			p_eta = previouseta;
																		}
																		else{
																			p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																		}

																		nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);

																		if (pDisability3.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}


																		int aLatepickup;
																		if (pDisability3.find("OT",0) != string::npos)
																		{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{

																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}
																		else if (pDisability3.find("LP",0) != string::npos){
																			aLatepickup = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{
																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}

																		bool preassigntripchange = true;

																		int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																		int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																		if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																			endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																		}
																		string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																		if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																			preassigntripchange = false;
																			if ((p_stop_type == "P") && starttime1 != 0  ) {
																				if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																				{
																					int dev =  p_eta - (starttime1 + aLatepickup);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}

																				}
																			}


																			if ((p_stop_type == "D") && (endtime1) != 0)
																			{
																				if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																				{
																					int dev =  p_eta - (endtime1);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}
																				}
																			}
																		}

																		if(preassigntripchange){
																			if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																					isLate = true;
																					break;
																				}

																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																				//break;
																				//}
																			}
																			else{

																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																					isLate = true;
																					break;
																				}
																				else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						isLate = true;
																						break;}
																				}
																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																					//  break;
																					//}

																			}
																		}
																		else{
																			if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																		}
																		w++; previouseta = p_eta;
																	}

																	if(isLate){
																		break;
																	}



																	/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																	if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;

																	return true;
																}
															}
															else if(tripstarttime == 0) {
																//  if(DEBUG == 1) gse << "no start time " << endl;



																if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																	trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}
																else{
																	trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}

																if (to_number(schd_tab[tripidx][27]) > 0)
																{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																{
																	break;
																}

																}

																if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																	trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																}


																if((int)to_number(endtime1)!= 0)
																	est_time = (int)to_number(endtime1);
																else{
																	est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																}
																trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																if(endofsegtime > 0  ){

																	if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){


																		if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																			int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																			int doeta1 = trav_time;
																			int actualTT = doeta1 - puetd1;
																			if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																			string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																			string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																			double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																			string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																			string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																			//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																			int groupcnter = 1;
																			routeint = (int)to_number(a_route.substr(1, a_route.length()));
																			//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																			for (int i = 0; i < MAXSEGMENTS; i++)
																			{
																				if (s_tab[i][0] == routeint)
																				{
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[i][g] == s_tab[m][k-1])
																						{

																							while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																								groupcnter++;
																								g--;
																							}
																							//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																							break;
																						}
																					}
																					break;
																				}
																			}
																			groupcnter = groupcnter + groupnumber;
																			int aAllowedTT;
																			if(estdisttrip < a_mediumshortdistance1)
																				aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																				aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else
																				aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																			if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																				aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																			}

																			if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																				//
																				if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																				if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																				break; ////to ensure that the insertion will not make the stop before which I insert late.

																			}


																		}


																		int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																		int segend;
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[m][g] == 0)
																			{
																				segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																				break;

																			}
																		}
																		int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																		int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																		timethreshold = segend - timethreshold;
																		bool docalc = true;

																		if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																				|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																		){

																			double threshold;

																			if(inslack == "Y"){
																				threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																			}
																			else{
																				threshold = EXTRASLACK[0];
																			}

																			double pudev;
																			double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}


																			docalc = false;

																			if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																				double distpu =  getCost(tripidx, s_tab[m][k]);
																				double distdo = getCost(tripidx+1, s_tab[m][k]);
																				if(isSameLocation(tripidx+1,s_tab[m][k])){
																					distdo = 0;
																				}
																				double cost = getCost(tripidx, s_tab[m][k-1]);

																				if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																					distpu = 0;
																					if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																						//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																							distdo = 0;
																						}
																					}

																					if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																						if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}
																					else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																						if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}

																			}else{

																				double distdo = getCost(tripidx+1, s_tab[m][k]);

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}

																				if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																					if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																					docalc = true;

																				}
																			}

																			if(!docalc){
																				break;
																			}
																		}

																		bool isLate = false;
																		int w = k;
																		int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																		while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																			string pDisability2 = schd_tab[s_tab[m][w]][12];
																			string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																			string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																			int p_perf_time2;

																			string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																			if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																			if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																				AGRPCOUNTER = AGRPCOUNTER + 1;
																			else{
																				if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																				{
																					APRVGRPCOUNTER = AGRPCOUNTER + 1;
																				}
																				AGRPCOUNTER = 0;
																			}


																			if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																					if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}


																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																			else{

																				if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}

																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																			}

																			}
																			int aEarlypickup;
																			int aEarlydropoff;
																			int t1;

																			if (pDisability2.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip2 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}


																			string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																			string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																			string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																			int p_perf_time3;
																			pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																			if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																				if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}
																			else{
																				if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}


																			int p_eta;
																			if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																				p_eta = previouseta;
																			}
																			else{
																				p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																			}

																			nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																			if (pDisability3.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}
																			int aLatepickup;
																			if (pDisability3.find("OT",0) != string::npos)
																			{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{

																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			else if (pDisability3.find("LP",0) != string::npos){
																				aLatepickup = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{
																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}

																			bool preassigntripchange = true;

																			int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																			int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																			if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																			}
																			string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																			if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																				preassigntripchange = false;
																				if ((p_stop_type == "P") && starttime1 != 0  ) {
																					if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																					{
																						int dev =  p_eta - (starttime1 + aLatepickup);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}

																					}
																				}


																				if ((p_stop_type == "D") && (endtime1) != 0)
																				{
																					if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																					{
																						int dev =  p_eta - (endtime1);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}
																					}
																				}
																			}


																			if(preassigntripchange){
																				if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																						isLate = true;
																						break;
																					}

																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																					//break;
																					//}
																				}
																				else{

																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																						isLate = true;
																						break;
																					}
																					else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							isLate = true;
																							break;}
																					}
																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																						//  break;
																						//}

																				}
																			}else{
																				if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																			}
																			w++; previouseta = p_eta;
																		}

																		if(isLate){
																			break;
																		}



																		/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																		if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																		if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;

																		return true;

																	}

																}
																else{

																	if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																		int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																		int doeta1 = trav_time;
																		int actualTT = doeta1 - puetd1;
																		if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																		string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																		string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																		double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																		string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																		string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																		//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																		int groupcnter = 1;
																		routeint = (int)to_number(a_route.substr(1, a_route.length()));
																		//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																		for (int i = 0; i < MAXSEGMENTS; i++)
																		{
																			if (s_tab[i][0] == routeint)
																			{
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[i][g] == s_tab[m][k-1])
																					{

																						while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																							groupcnter++;
																							g--;
																						}
																						//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																						break;
																					}
																				}
																				break;
																			}
																		}
																		groupcnter = groupcnter + groupnumber;
																		int aAllowedTT;
																		if(estdisttrip < a_mediumshortdistance1)
																			aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																			aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else
																			aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																		}

																		if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																			//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																			//
																			if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																			if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																			break; ////to ensure that the insertion will not make the stop before which I insert late.

																		}


																	}
																	int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																	int segend;
																	for (int g = 1; g < MAXSTOPS; g++)
																	{
																		if (s_tab[m][g] == 0)
																		{
																			segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																			break;

																		}
																	}
																	int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																	int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																	timethreshold = segend - timethreshold;
																	bool docalc = true;

																	if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																			|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																	){

																		double threshold;

																		if(inslack == "Y"){
																			threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																		}
																		else{
																			threshold = EXTRASLACK[0];
																		}

																		double pudev;
																		double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																		if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																			if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																				pudev = getCost(pickupafterstop,puid);
																				dodev = getCost(doid,  dropoffafterstop);
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																				dodev = pudev;

																			}
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid);
																			dodev = 0;
																		}


																		docalc = false;

																		if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																			double distpu =  getCost(tripidx, s_tab[m][k]);
																			double distdo = getCost(tripidx+1, s_tab[m][k]);
																			if(isSameLocation(tripidx+1,s_tab[m][k])){
																				distdo = 0;
																			}
																			double cost = getCost(tripidx, s_tab[m][k-1]);

																			if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																				if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																				distpu = 0;
																				if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																					//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																						distdo = 0;
																					}
																				}

																				if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																					if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}
																				else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																					if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}

																		}else{

																			double distdo = getCost(tripidx+1, s_tab[m][k]);

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}

																			if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																				if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																				docalc = true;

																			}
																		}

																		if(!docalc){
																			break;
																		}

																	}

																	bool isLate = false;
																	int w = k;
																	int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																	while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																		string pDisability2 = schd_tab[s_tab[m][w]][12];
																		string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																		string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																		int p_perf_time2;
																		set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																		if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																		if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																			AGRPCOUNTER = AGRPCOUNTER + 1;
																		else{
																			if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																			{
																				APRVGRPCOUNTER = AGRPCOUNTER + 1;
																			}
																			AGRPCOUNTER = 0;
																		}


																		if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																			if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																				if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																				p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																			}


																			if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																				APRVGRPCOUNTER = 0;
																			}
																		}
																		else{

																			if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}

																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																		}

																		}
																		int aEarlypickup;
																		int aEarlydropoff;
																		int t1;

																		if (pDisability2.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip2 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}


																		string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																		string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																		string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																		int p_perf_time3;
																		pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																		set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																		if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																			if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}
																		else{
																			if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}


																		int p_eta;
																		if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																			p_eta = previouseta;
																		}
																		else{
																			p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																		}

																		nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																		if (pDisability3.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}

																		int aLatepickup;
																		if (pDisability3.find("OT",0) != string::npos)
																		{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{

																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}
																		else if (pDisability3.find("LP",0) != string::npos){
																			aLatepickup = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{
																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}
																		bool preassigntripchange = true;

																		int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																		int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																		if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																			endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																		}
																		string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																		if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																			preassigntripchange = false;
																			if ((p_stop_type == "P") && starttime1 != 0  ) {
																				if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																				{
																					int dev =  p_eta - (starttime1 + aLatepickup);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}

																				}
																			}


																			if ((p_stop_type == "D") && (endtime1) != 0)
																			{
																				if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																				{
																					int dev =  p_eta - (endtime1);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}
																				}
																			}
																		}



																		if(preassigntripchange){
																			if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){

																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																					isLate = true;
																					break;
																				}

																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																				//break;
																				//}
																			}
																			else{

																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																					isLate = true;
																					break;
																				}
																				else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						isLate = true;
																						break;}
																				}
																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																					//  break;
																					//}

																			}
																		}else{
																			if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																		}
																		w++; previouseta = p_eta;
																	}

																	if(isLate){
																		break;
																	}



																	/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																	if(DEBUG == 1) gse << "No end time " << endl;

																	if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;

																	return true;
																}
															}


														}

														break;
													} // if the clusters match

												}
											}


											//while(tripneighbors != ""){ // move on to neighbors if not found for original cluster
											//cid = (int)to_number(getNextToken(&(tripneighbors),","));
											temp = schd_tab[s_tab[m][k-1]][NEIGHBORS];


											//int temproutecluster  = (int)to_number( schd_tab[s_tab[m][k-1]][42]);
											string temp2 = schd_tab[s_tab[m][k]][NEIGHBORS];
											int tripcluster2 = (int)to_number(schd_tab[tripidx+1][42]);
											while(temp != ""){
												cidroute = (int)to_number(getNextToken(&(temp),","));
												if(tripcluster == cidroute){
													while(temp2 != ""){
														int cidroute2 = (int)to_number(getNextToken(&(temp2),","));
														if(tripcluster2 == cidroute2 || tripcluster2 == (int)to_number(schd_tab[s_tab[m][k]][42])){
															//if(cid == cidroute || cid == temproutecluster || cidroute  == tripcluster || tripcluster == temproutecluster)
															bool skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
															if(!skiproute){

																if(strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0){
																	if(DEBUG == 1) gse << "We are exmaining the first stop so checking distance!"<< endl;
																	double distance = getActualDistance(s_tab[m][k-1],tripidx);
																	if(distance > maxfirststopdeadhead && ((inslack == "Y" && (strcmp(schd_tab[s_tab[m][k-1]][2],"1")!=0 || strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0))|| (inslack == "E"))){
																		if(DEBUG == 1) gse << "There's too much deadhead in the beginning of the segment" << endl;
																		continue;
																	}
																}

																string starttime1 = schd_tab[tripidx][26];
																string endtime1 = schd_tab[tripidx][27];
																int est_time;
																if((int)to_number(starttime1)!= 0){
																	est_time = (int)to_number(starttime1);
																}
																else{
																	est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
																}
																int trav_time =   (int)to_number(schd_tab[s_tab[m][k-1]][30]) + getTravTime_passedEta(s_tab[m][k-1],tripidx, to_string(est_time),"0");
																int tripstarttime = (int)to_number(schd_tab[tripidx][26]);

																//if(DEBUG == 1) gse << "1:" << trav_time << endl;

																if (trav_time < tripstarttime + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50) && tripstarttime > 0){


																	if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																		trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																	}
																	else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																		trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																	}
																	else{
																		trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																	}

																	if (to_number(schd_tab[tripidx][27]) > 0)
																	{
																		if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																		if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																		{
																			break;
																		}

																	}

																	//if(DEBUG == 1) gse << "2:" << trav_time << endl;

																	if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																		trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																	}
																	else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																		trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																	}


																	if((int)to_number(endtime1)!= 0)
																		est_time = (int)to_number(endtime1);
																	else{
																		est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																	}
																	trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																	//if(DEBUG == 1) gse << "3:" << trav_time << endl;

																	if(endofsegtime > 0  ){

																		if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																			if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																				int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																				int doeta1 = trav_time;
																				int actualTT = doeta1 - puetd1;
																				if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																				string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																				string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																				double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																				string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																				string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																				//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																				int groupcnter = 1;
																				routeint = (int)to_number(a_route.substr(1, a_route.length()));
																				//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																				for (int i = 0; i < MAXSEGMENTS; i++)
																				{
																					if (s_tab[i][0] == routeint)
																					{
																						for (int g = 1; g < MAXSTOPS; g++)
																						{
																							if (s_tab[i][g] == s_tab[m][k-1])
																							{

																								while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																									groupcnter++;
																									g--;
																								}
																								//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																								break;
																							}
																						}
																						break;
																					}
																				}
																				groupcnter = groupcnter + groupnumber;
																				int aAllowedTT;
																				if(estdisttrip < a_mediumshortdistance1)
																					aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																					aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else
																					aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																				if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																					aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																				}

																				if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																					//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																					//
																					if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																					if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																					break; ////to ensure that the insertion will not make the stop before which I insert late.

																				}


																			}

																			int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																			int segend;
																			for (int g = 1; g < MAXSTOPS; g++)
																			{
																				if (s_tab[m][g] == 0)
																				{
																					segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																					break;

																				}
																			}
																			int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																			int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																			timethreshold = segend - timethreshold;
																			bool docalc = true;

																			if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																					|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																			){

																				double threshold;

																				if(inslack == "Y"){
																					threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																				}
																				else{
																					threshold = EXTRASLACK[0];
																				}

																				double pudev;
																				double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}


																				docalc = false;

																				if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																					double distpu =  getCost(tripidx, s_tab[m][k]);
																					double distdo = getCost(tripidx+1, s_tab[m][k]);
																					if(isSameLocation(tripidx+1,s_tab[m][k])){
																						distdo = 0;
																					}
																					double cost = getCost(tripidx, s_tab[m][k-1]);

																					if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																						distpu = 0;
																						if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																							//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																								distdo = 0;
																							}
																						}

																						if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																							if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}
																						else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																							if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}

																				}else{

																					double distdo = getCost(tripidx+1, s_tab[m][k]);

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}

																					if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																						if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																						docalc = true;

																					}
																				}

																				if(!docalc){
																					break;
																				}

																			}

																			bool isLate = false;
																			int w = k;
																			int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																			while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																				string pDisability2 = schd_tab[s_tab[m][w]][12];
																				string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																				string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																				int p_perf_time2;
																				string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																				if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																				if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																					AGRPCOUNTER = AGRPCOUNTER + 1;
																				else{
																					if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																					{
																						APRVGRPCOUNTER = AGRPCOUNTER + 1;
																					}
																					AGRPCOUNTER = 0;
																				}


																				if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																						if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}


																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																				else{

																					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}

																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																				}

																				}
																				int aEarlypickup;
																				int aEarlydropoff;
																				int t1;

																				if (pDisability2.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip2 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}


																				string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																				string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																				string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																				int p_perf_time3;
																				pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																				if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																					if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}
																				else{
																					if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}


																				int p_eta;
																				if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																					p_eta = previouseta;
																				}
																				else{
																					p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																				}

																				nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																				if (pDisability3.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}
																				int aLatepickup;
																				if (pDisability3.find("OT",0) != string::npos)
																				{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{

																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}
																				else if (pDisability3.find("LP",0) != string::npos){
																					aLatepickup = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{
																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}

																				bool preassigntripchange = true;

																				int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																				int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																				if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																				}
																				string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																				if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																					preassigntripchange = false;
																					if ((p_stop_type == "P") && starttime1 != 0  ) {
																						if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																						{
																							int dev =  p_eta - (starttime1 + aLatepickup);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}

																						}
																					}


																					if ((p_stop_type == "D") && (endtime1) != 0)
																					{
																						if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																						{
																							int dev =  p_eta - (endtime1);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}
																						}
																					}
																				}


																				if(preassigntripchange){
																					if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){

																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																							isLate = true;
																							break;
																						}

																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																						//break;
																						//}
																					}
																					else{

																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																							isLate = true;
																							break;
																						}
																						else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																								isLate = true;
																								break;}
																						}
																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																							//  break;
																							//}

																					}
																				}else{
																					if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																				}
																				w++; previouseta = p_eta;
																			}

																			if(isLate){
																				break;
																			}



																			/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																			if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																			if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																			return true;

																		}

																	}
																	else{

																		if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																			int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																			int doeta1 = trav_time;
																			int actualTT = doeta1 - puetd1;
																			if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																			string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																			string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																			double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																			string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																			string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																			//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																			int groupcnter = 1;
																			routeint = (int)to_number(a_route.substr(1, a_route.length()));
																			//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																			for (int i = 0; i < MAXSEGMENTS; i++)
																			{
																				if (s_tab[i][0] == routeint)
																				{
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[i][g] == s_tab[m][k-1])
																						{

																							while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																								groupcnter++;
																								g--;
																							}
																							//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																							break;
																						}
																					}
																					break;
																				}
																			}
																			groupcnter = groupcnter + groupnumber;
																			int aAllowedTT;
																			if(estdisttrip < a_mediumshortdistance1)
																				aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																				aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else
																				aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																			if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																				aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																			}

																			if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																				//
																				if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																				if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																				break; ////to ensure that the insertion will not make the stop before which I insert late.

																			}


																		}
																		int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																		int segend;
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[m][g] == 0)
																			{
																				segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																				break;

																			}
																		}
																		int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																		int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																		timethreshold = segend - timethreshold;
																		bool docalc = true;

																		if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																				|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																		){
																			double threshold;

																			if(inslack == "Y"){
																				threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																			}
																			else{
																				threshold = EXTRASLACK[0];
																			}


																			double pudev;
																			double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}


																			docalc = false;

																			if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																				double distpu =  getCost(tripidx, s_tab[m][k]);
																				double distdo = getCost(tripidx+1, s_tab[m][k]);
																				if(isSameLocation(tripidx+1,s_tab[m][k])){
																					distdo = 0;
																				}
																				double cost = getCost(tripidx, s_tab[m][k-1]);

																				if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																					distpu = 0;
																					if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																						//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																							distdo = 0;
																						}
																					}

																					if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																						if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}
																					else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																						if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}

																			}else{

																				double distdo = getCost(tripidx+1, s_tab[m][k]);

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}

																				if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																					if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																					docalc = true;

																				}
																			}

																			if(!docalc){
																				break;
																			}

																		}

																		bool isLate = false;
																		int w = k;
																		int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																		while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																			string pDisability2 = schd_tab[s_tab[m][w]][12];
																			string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																			string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																			int p_perf_time2;
																			string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																			if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																			if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																				AGRPCOUNTER = AGRPCOUNTER + 1;
																			else{
																				if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																				{
																					APRVGRPCOUNTER = AGRPCOUNTER + 1;
																				}
																				AGRPCOUNTER = 0;
																			}


																			if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																					if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}


																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																			else{

																				if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}

																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																			}

																			}
																			int aEarlypickup;
																			int aEarlydropoff;
																			int t1;

																			if (pDisability2.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip2 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}


																			string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																			string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																			string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																			int p_perf_time3;
																			pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																			if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																				if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}
																			else{
																				if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}


																			int p_eta;
																			if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																				p_eta = previouseta;
																			}
																			else{
																				p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																			}

																			nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																			if (pDisability3.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}
																			int aLatepickup;
																			if (pDisability3.find("OT",0) != string::npos)
																			{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{

																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			else if (pDisability3.find("LP",0) != string::npos){
																				aLatepickup = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{
																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}

																			bool preassigntripchange = true;

																			int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																			int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																			if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																			}
																			string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																			if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																				preassigntripchange = false;
																				if ((p_stop_type == "P") && starttime1 != 0  ) {
																					if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																					{
																						int dev =  p_eta - (starttime1 + aLatepickup);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}

																					}
																				}


																				if ((p_stop_type == "D") && (endtime1) != 0)
																				{
																					if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																					{
																						int dev =  p_eta - (endtime1);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}
																					}
																				}
																			}


																			if(preassigntripchange){
																				if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																						isLate = true;
																						break;
																					}

																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																					//break;
																					//}
																				}
																				else{

																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																						isLate = true;
																						break;
																					}
																					else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							isLate = true;
																							break;}
																					}
																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																						//  break;
																						//}

																				}
																			}else{
																				if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																			}
																			w++; previouseta = p_eta;
																		}

																		if(isLate){
																			break;
																		}



																		/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																		if(DEBUG == 1) gse << "No end time " << endl;

																		if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																		return true;
																	}
																}
																else if(tripstarttime == 0) {
																	if(DEBUG == 1) gse << "no start time " << endl;

																	if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																		trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																	}
																	else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																		trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																	}
																	else{
																		trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																	}

																	if (to_number(schd_tab[tripidx][27]) > 0)
																	{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																	if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																	{
																		break;
																	}

																	}

																	if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																		trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																	}
																	else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																		trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																	}


																	if((int)to_number(endtime1)!= 0)
																		est_time = (int)to_number(endtime1);
																	else{
																		est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																	}
																	trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																	if(endofsegtime > 0  ){

																		if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																			if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																				int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																				int doeta1 = trav_time;
																				int actualTT = doeta1 - puetd1;
																				if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																				string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																				string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																				double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																				string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																				string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																				//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																				int groupcnter = 1;
																				routeint = (int)to_number(a_route.substr(1, a_route.length()));
																				//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																				for (int i = 0; i < MAXSEGMENTS; i++)
																				{
																					if (s_tab[i][0] == routeint)
																					{
																						for (int g = 1; g < MAXSTOPS; g++)
																						{
																							if (s_tab[i][g] == s_tab[m][k-1])
																							{

																								while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																									groupcnter++;
																									g--;
																								}
																								//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																								break;
																							}
																						}
																						break;
																					}
																				}
																				groupcnter = groupcnter + groupnumber;
																				int aAllowedTT;
																				if(estdisttrip < a_mediumshortdistance1)
																					aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																					aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else
																					aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																				if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																					aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																				}

																				if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																					//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																					//
																					if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																					if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																					break; ////to ensure that the insertion will not make the stop before which I insert late.

																				}


																			}
																			int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																			int segend;
																			for (int g = 1; g < MAXSTOPS; g++)
																			{
																				if (s_tab[m][g] == 0)
																				{
																					segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																					break;

																				}
																			}
																			int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																			int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																			timethreshold = segend - timethreshold;
																			bool docalc = true;

																			if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																					|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																			){


																				double threshold;

																				if(inslack == "Y"){
																					threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																				}
																				else{
																					threshold = EXTRASLACK[0];
																				}

																				double pudev;
																				double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}


																				docalc = false;

																				if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																					double distpu =  getCost(tripidx, s_tab[m][k]);
																					double distdo = getCost(tripidx+1, s_tab[m][k]);
																					if(isSameLocation(tripidx+1,s_tab[m][k])){
																						distdo = 0;
																					}
																					double cost = getCost(tripidx, s_tab[m][k-1]);

																					if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																						distpu = 0;
																						if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																							//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																								distdo = 0;
																							}
																						}

																						if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																							if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}
																						else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																							if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}

																				}else{

																					double distdo = getCost(tripidx+1, s_tab[m][k]);

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}

																					if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																						if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																						docalc = true;

																					}
																				}

																				if(!docalc){
																					break;
																				}

																			}

																			bool isLate = false;
																			int w = k;
																			int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																			while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																				string pDisability2 = schd_tab[s_tab[m][w]][12];
																				string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																				string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																				int p_perf_time2;
																				string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																				if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																				if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																					AGRPCOUNTER = AGRPCOUNTER + 1;
																				else{
																					if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																					{
																						APRVGRPCOUNTER = AGRPCOUNTER + 1;
																					}
																					AGRPCOUNTER = 0;
																				}


																				if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																						if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}


																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																				else{

																					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}

																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																				}

																				}
																				int aEarlypickup;
																				int aEarlydropoff;
																				int t1;

																				if (pDisability2.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip2 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}


																				string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																				string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																				string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																				int p_perf_time3;
																				pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																				if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																					if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}
																				else{
																					if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}


																				int p_eta;
																				if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																					p_eta = previouseta;
																				}
																				else{
																					p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																				}

																				nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																				if (pDisability3.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}
																				int aLatepickup;
																				if (pDisability3.find("OT",0) != string::npos)
																				{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{

																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}
																				else if (pDisability3.find("LP",0) != string::npos){
																					aLatepickup = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{
																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}
																				bool preassigntripchange = true;

																				int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																				int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																				if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																				}
																				string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																				if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																					preassigntripchange = false;
																					if ((p_stop_type == "P") && starttime1 != 0  ) {
																						if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																						{
																							int dev =  p_eta - (starttime1 + aLatepickup);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}

																						}
																					}


																					if ((p_stop_type == "D") && (endtime1) != 0)
																					{
																						if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																						{
																							int dev =  p_eta - (endtime1);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}
																						}
																					}
																				}


																				if(preassigntripchange){
																					if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																							isLate = true;
																							break;
																						}

																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																						//break;
																						//}
																					}
																					else{

																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																							isLate = true;
																							break;
																						}
																						else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																								isLate = true;
																								break;}
																						}
																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																							//  break;
																							//}

																					}
																				}else{
																					if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																				}
																				w++; previouseta = p_eta;
																			}

																			if(isLate){
																				break;
																			}



																			/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																			if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																			if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																			return true;

																		}

																	}
																	else{
																		if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																			int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																			int doeta1 = trav_time;
																			int actualTT = doeta1 - puetd1;
																			if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																			string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																			string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																			double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																			string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																			string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																			//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																			int groupcnter = 1;
																			routeint = (int)to_number(a_route.substr(1, a_route.length()));
																			//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																			for (int i = 0; i < MAXSEGMENTS; i++)
																			{
																				if (s_tab[i][0] == routeint)
																				{
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[i][g] == s_tab[m][k-1])
																						{

																							while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																								groupcnter++;
																								g--;
																							}
																							//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																							break;
																						}
																					}
																					break;
																				}
																			}
																			groupcnter = groupcnter + groupnumber;
																			int aAllowedTT;
																			if(estdisttrip < a_mediumshortdistance1)
																				aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																				aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else
																				aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																			if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																				aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																			}

																			if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																				//
																				if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																				if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																				break; ////to ensure that the insertion will not make the stop before which I insert late.

																			}


																		}
																		int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																		int segend;
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[m][g] == 0)
																			{
																				segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																				break;

																			}
																		}
																		int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																		int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																		timethreshold = segend - timethreshold;
																		bool docalc = true;

																		if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																				|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																		){


																			double threshold;

																			if(inslack == "Y"){
																				threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																			}
																			else{
																				threshold = EXTRASLACK[0];
																			}

																			double pudev;
																			double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}


																			docalc = false;

																			if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																				double distpu =  getCost(tripidx, s_tab[m][k]);
																				double distdo = getCost(tripidx+1, s_tab[m][k]);
																				if(isSameLocation(tripidx+1,s_tab[m][k])){
																					distdo = 0;
																				}
																				double cost = getCost(tripidx, s_tab[m][k-1]);

																				if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																					distpu = 0;
																					if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																						//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																							distdo = 0;
																						}
																					}

																					if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																						if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}
																					else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																						if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}

																			}else{

																				double distdo = getCost(tripidx+1, s_tab[m][k]);

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}

																				if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																					if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																					docalc = true;

																				}
																			}

																			if(!docalc){
																				break;
																			}

																		}

																		bool isLate = false;
																		int w = k;
																		int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																		while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																			string pDisability2 = schd_tab[s_tab[m][w]][12];
																			string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																			string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																			int p_perf_time2;
																			string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																			if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																			if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																				AGRPCOUNTER = AGRPCOUNTER + 1;
																			else{
																				if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																				{
																					APRVGRPCOUNTER = AGRPCOUNTER + 1;
																				}
																				AGRPCOUNTER = 0;
																			}


																			if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																					if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}


																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																			else{

																				if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}

																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																			}

																			}
																			int aEarlypickup;
																			int aEarlydropoff;
																			int t1;

																			if (pDisability2.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip2 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}


																			string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																			string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																			string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																			int p_perf_time3;
																			pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																			if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																				if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}
																			else{
																				if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}


																			int p_eta;
																			if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																				p_eta = previouseta;
																			}
																			else{
																				p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																			}

																			nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																			if (pDisability3.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}
																			int aLatepickup;
																			if (pDisability3.find("OT",0) != string::npos)
																			{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{

																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			else if (pDisability3.find("LP",0) != string::npos){
																				aLatepickup = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{
																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			bool preassigntripchange = true;

																			int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																			int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																			if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																			}
																			string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																			if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																				preassigntripchange = false;
																				if ((p_stop_type == "P") && starttime1 != 0  ) {
																					if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																					{
																						int dev =  p_eta - (starttime1 + aLatepickup);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}

																					}
																				}


																				if ((p_stop_type == "D") && (endtime1) != 0)
																				{
																					if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																					{
																						int dev =  p_eta - (endtime1);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}
																					}
																				}
																			}

																			if(preassigntripchange){
																				if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																						isLate = true;
																						break;
																					}

																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																					//break;
																					//}
																				}
																				else{

																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																						isLate = true;
																						break;
																					}
																					else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							isLate = true;
																							break;}
																					}
																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																						//  break;
																						//}

																				}
																			}else{
																				if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																			}
																			w++; previouseta = p_eta;
																		}

																		if(isLate){
																			break;
																		}



																		/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																		if(DEBUG == 1) gse << "No end time " << endl;

																		if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																		return true;
																	}
																}


															}

															break;}
													}
													break;}
											}

											//}

											double distpu =  getCost(tripidx, s_tab[m][k-1]);
											double distdo = getCost(tripidx+1, s_tab[m][k]);
											int pickupafterstop = s_tab[m][k-1];
											bool skiproute = false;

											if(((distpu <= SLACK_THRESHOLD[0] && inslack == "E") || inslack == "Y") && strcmp(schd_tab[s_tab[m][k-1]][2], "1")==0 && strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])==0){
												//  if(DEBUG == 1) gse << "analysis " <<  schd_tab[s_tab[m][k-1]][0] << " " << schd_tab[tripidx][3] << " " << schd_tab[tripidx][12] << " " << getCost(tripidx,s_tab[m][k-1]) << endl;
												skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
												if(!skiproute){
													if(DEBUG == 1) gse << "It's an empty segment v2 " << schd_tab[s_tab[m][k]][0] << endl;
													return true;
												}
											}
											else if((/*timethreshold > slack ||*/ triptimethreshold <= timethreshold ) && inslack == "N" && (strcmp(schd_tab[s_tab[m][k-1]][2], "1")!=0  || strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])!=0) ){
												skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
												if(!skiproute)
													return true;
											}
											else if((/*timethreshold <= slack &&*/ triptimethreshold > timethreshold) && inslack == "N" && (strcmp(schd_tab[s_tab[m][k-1]][2], "1")!=0  || strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])!=0) && (distpu/to_number(schd_tab[pickupafterstop][6])) < MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[pickupafterstop][6])) < MAXDEADHEADVARIANCE[0]){
												skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
												if(!skiproute)
													return true;
											}
											else if((strcmp(schd_tab[s_tab[m][k-1]][2], "1")!=0  || strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])!=0) && ((distpu <= SLACK_THRESHOLD[0] && distdo <= SLACK_THRESHOLD[0] && inslack == "E") || inslack == "Y")){
												skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
												if(!skiproute){

													if(strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0){
														if(DEBUG == 1) gse << "We are exmaining the first stop so checking distance!"<< endl;
														double distance = getActualDistance(s_tab[m][k-1],tripidx);
														if(distance > maxfirststopdeadhead && ((inslack == "Y" && (strcmp(schd_tab[s_tab[m][k-1]][2],"1")!=0 || strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0))|| (inslack == "E"))){
															if(DEBUG == 1) gse << "There's too much deadhead in the beginning of the segment" << endl;
															continue;
														}
													}

													//if(DEBUG == 1) gse << "We are within the deadhead (or not considering it)"  << endl;

													string starttime1 = schd_tab[tripidx][26];
													string endtime1 = schd_tab[tripidx][27];
													int est_time;
													if((int)to_number(starttime1)!= 0){
														est_time = (int)to_number(starttime1);
													}
													else{
														est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
													}
													int trav_time =   (int)to_number(schd_tab[s_tab[m][k-1]][30]) +getTravTime_passedEta(s_tab[m][k-1],tripidx, to_string(est_time),"0");
													int tripstarttime = (int)to_number(schd_tab[tripidx][26]);

													if (trav_time < tripstarttime + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50) && tripstarttime > 0){

														if(DEBUG == 1) gse << trav_time << " " << tripstarttime << " " << aLatepickup << endl;


														if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
															trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
														}
														else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
															trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
														}
														else{
															trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
														}

														if (to_number(schd_tab[tripidx][27]) > 0)
														{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
														if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
														{
															continue;
														}

														}

														if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
															trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
														}
														else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
															trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
														}


														if((int)to_number(endtime1)!= 0)
															est_time = (int)to_number(endtime1);
														else{
															est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
														}
														trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

														if(endofsegtime > 0  ){

															if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																	int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																	int doeta1 = trav_time;
																	int actualTT = doeta1 - puetd1;
																	if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																	string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																	string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																	double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																	string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																	string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																	//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																	set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																			p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																			a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																	int groupcnter = 1;
																	routeint = (int)to_number(a_route.substr(1, a_route.length()));
																	//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																	for (int i = 0; i < MAXSEGMENTS; i++)
																	{
																		if (s_tab[i][0] == routeint)
																		{
																			for (int g = 1; g < MAXSTOPS; g++)
																			{
																				if (s_tab[i][g] == s_tab[m][k-1])
																				{

																					while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																						groupcnter++;
																						g--;
																					}
																					//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																					break;
																				}
																			}
																			break;
																		}
																	}
																	groupcnter = groupcnter + groupnumber;
																	int aAllowedTT;
																	if(estdisttrip < a_mediumshortdistance1)
																		aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																	else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																		aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																	else
																		aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																	if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																		aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																	}

																	if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																		//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																		//
																		if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																		if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																		break; ////to ensure that the insertion will not make the stop before which I insert late.

																	}


																}
																int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																int segend;
																for (int g = 1; g < MAXSTOPS; g++)
																{
																	if (s_tab[m][g] == 0)
																	{
																		segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																		break;

																	}
																}
																int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																timethreshold = segend - timethreshold;
																bool docalc = true;

																if(DEBUG == 1) gse << "Going to see if we are in the ellipse: " << schd_tab[s_tab[m][k-1]][31] << " " << schd_tab[s_tab[m][k-1]][32] << " " << triptimethreshold << " " << timethreshold <<" " <<schd_tab[s_tab[m][k]][7] << " " << schd_tab[s_tab[m][k]][2] << endl;

																if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																		|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																){

																	double threshold;

																	if(inslack == "Y"){
																		threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																	}
																	else{
																		threshold = EXTRASLACK[0];
																	}


																	double pudev;
																	double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																	if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																		if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																			pudev = getCost(pickupafterstop,puid);
																			dodev = getCost(doid,  dropoffafterstop);
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																			dodev = pudev;

																		}
																	}
																	else{
																		pudev = getCost(pickupafterstop,puid);
																		dodev = 0;
																	}


																	docalc = false;

																	if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																		double distpu =  getCost(tripidx, s_tab[m][k]);
																		double distdo = getCost(tripidx+1, s_tab[m][k]);
																		if(isSameLocation(tripidx+1,s_tab[m][k])){
																			distdo = 0;
																		}
																		double cost = getCost(tripidx, s_tab[m][k-1]);

																		if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																			if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																			distpu = 0;
																			if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																				if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																				//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																					distdo = 0;
																				}
																			}

																			if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																				if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																				docalc = true;
																			}
																			else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																				if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																				docalc = true;
																			}

																	}else{

																		double distdo = getCost(tripidx+1, s_tab[m][k]);

																		if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																			if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																				pudev = getCost(pickupafterstop,puid);
																				dodev = getCost(doid,  dropoffafterstop);
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																				dodev = pudev;

																			}
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid);
																			dodev = 0;
																		}

																		if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																			if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																			docalc = true;

																		}
																	}

																	if(!docalc){
																		break;
																	}

																}

																bool isLate = false;
																int w = k;
																int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																	string pDisability2 = schd_tab[s_tab[m][w]][12];
																	string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																	string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																	set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																			p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																			a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																	int p_perf_time2;
																	string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																	set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																	if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																	if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																		AGRPCOUNTER = AGRPCOUNTER + 1;
																	else{
																		if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																		{
																			APRVGRPCOUNTER = AGRPCOUNTER + 1;
																		}
																		AGRPCOUNTER = 0;
																	}


																	if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																		if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																			if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																			p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																		}


																		if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																			p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																			APRVGRPCOUNTER = 0;
																		}
																	}
																	else{

																		if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																			if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																			}

																			if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																				APRVGRPCOUNTER = 0;
																			}
																		}
																	}

																	}
																	int aEarlypickup;
																	int aEarlydropoff;
																	int t1;

																	if (pDisability2.find("LP",0) != string::npos){
																		aEarlypickup = 0;
																		aEarlydropoff = 0;
																	}
																	else{
																		if (pReturn_trip2 == "Y"){
																			aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			/* C[006] */
																			//   if(DEBUG == 1) gse << "here5 " << endl;
																		}
																		else{
																			aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			//   if(DEBUG == 1) gse << "here4 " << endl;
																		}
																	}


																	string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																	string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																	string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																	set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																			p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																			a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																	int p_perf_time3;
																	pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																	set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																	//if(DEBUG == 1) gse << "NEXT STOP TIME 1:: " <<  nextstoptime  << endl;


																	if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																		if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																			//if(DEBUG == 1) gse << "Adding pickup " << aEarlypickup << endl;
																			nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																		}
																		else{
																			nextstoptime = nextstoptime+p_perf_time2;
																		}
																	}
																	else{
																		if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																			nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																			//if(DEBUG == 1) gse << "Adding dropoff " << aEarlydropoff << endl;
																		}
																		else{
																			nextstoptime = nextstoptime+p_perf_time2;
																		}
																	}


																	int p_eta;
																	if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																		p_eta = previouseta;
																	}
																	else{
																		p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																	}

																	nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);

																	//if(DEBUG == 1) gse << "NEXT STOP TIME  " <<  nextstoptime - (int)to_number(schd_tab[s_tab[m][w]][CALCULATEDTIME]) << " " << (int)to_number(schd_tab[s_tab[m][w]][CALCULATEDTIME]) <<  " " << nextstoptime << " " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7] <<endl;


																	if (pDisability3.find("LP",0) != string::npos){
																		aEarlypickup = 0;
																		aEarlydropoff = 0;
																	}
																	else{
																		if (pReturn_trip3 == "Y"){
																			aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			/* C[006] */
																			//   if(DEBUG == 1) gse << "here5 " << endl;
																		}
																		else{
																			aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			//   if(DEBUG == 1) gse << "here4 " << endl;
																		}
																	}
																	int aLatepickup;
																	if (pDisability3.find("OT",0) != string::npos)
																	{
																		if (pReturn_trip3 == "Y"){
																			aLatepickup = p_OTHERLATEPICKFACTOR1;
																		}
																		else{

																			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																		}
																	}
																	else if (pDisability3.find("LP",0) != string::npos){
																		aLatepickup = 0;
																	}
																	else{
																		if (pReturn_trip3 == "Y"){
																			aLatepickup = p_OTHERLATEPICKFACTOR1;
																		}
																		else{
																			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																		}
																	}
																	bool preassigntripchange = true;

																	int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																	int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																	if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																		endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																	}
																	string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																	if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																		preassigntripchange = false;
																		if ((p_stop_type == "P") && starttime1 != 0  ) {
																			if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																			{
																				int dev =  p_eta - (starttime1 + aLatepickup);
																				if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																					preassigntripchange = true;
																				}

																			}
																		}


																		if ((p_stop_type == "D") && (endtime1) != 0)
																		{
																			if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																			{
																				int dev =  p_eta - (endtime1);
																				if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																					preassigntripchange = true;
																				}
																			}
																		}
																	}

																	if(!preassigntripchange){
																		if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																	}
																	else if(preassigntripchange && strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																		//if(DEBUG == 1) gse << schd_tab[s_tab[m][w+1]][LATEDEVIATION] << " " << p_eta - (starttime1 + aLatepickup) << " " << p_eta - (endtime1) << endl;
																	}



																	if(preassigntripchange){
																		if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																			if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																				isLate = true;
																				break;
																			}

																			// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																			//break;
																			//}
																		}
																		else{

																			if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																				isLate = true;
																				break;
																			}
																			else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																					isLate = true;
																					break;
																				}
																			}
																			// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																				//  break;
																				//}

																		}
																	}
																	w++; previouseta = p_eta;
																}

																if(isLate){
																	continue;
																}



																/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

																return true;

															}

														}
														else{

															if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																int doeta1 = trav_time;
																int actualTT = doeta1 - puetd1;
																if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																		p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																		a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																int groupcnter = 1;
																routeint = (int)to_number(a_route.substr(1, a_route.length()));
																//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																for (int i = 0; i < MAXSEGMENTS; i++)
																{
																	if (s_tab[i][0] == routeint)
																	{
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[i][g] == s_tab[m][k-1])
																			{

																				while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																					groupcnter++;
																					g--;
																				}
																				//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																				break;
																			}
																		}
																		break;
																	}
																}
																groupcnter = groupcnter + groupnumber;
																int aAllowedTT;
																if(estdisttrip < a_mediumshortdistance1)
																	aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																	aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																else
																	aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																	aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																}

																if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																	//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																	//
																	if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																	if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																	break; ////to ensure that the insertion will not make the stop before which I insert late.

																}


															}
															int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
															int segend;
															for (int g = 1; g < MAXSTOPS; g++)
															{
																if (s_tab[m][g] == 0)
																{
																	segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																	break;

																}
															}
															int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
															int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
															timethreshold = segend - timethreshold;
															bool docalc = true;

															if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																	|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
															){


																double threshold;

																if(inslack == "Y"){
																	threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																}
																else{
																	threshold = EXTRASLACK[0];
																}

																double pudev;
																double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																	if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																		pudev = getCost(pickupafterstop,puid);
																		dodev = getCost(doid,  dropoffafterstop);
																	}
																	else{
																		pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																		dodev = pudev;

																	}
																}
																else{
																	pudev = getCost(pickupafterstop,puid);
																	dodev = 0;
																}


																docalc = false;

																if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																	double distpu =  getCost(tripidx, s_tab[m][k]);
																	double distdo = getCost(tripidx+1, s_tab[m][k]);
																	if(isSameLocation(tripidx+1,s_tab[m][k])){
																		distdo = 0;
																	}
																	double cost = getCost(tripidx, s_tab[m][k-1]);

																	if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																		if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																		distpu = 0;
																		if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																			if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																			//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																				distdo = 0;
																			}
																		}

																		if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																			if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																			docalc = true;
																		}
																		else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																			if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																			docalc = true;
																		}

																}else{

																	double distdo = getCost(tripidx+1, s_tab[m][k]);

																	if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																		if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																			pudev = getCost(pickupafterstop,puid);
																			dodev = getCost(doid,  dropoffafterstop);
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																			dodev = pudev;

																		}
																	}
																	else{
																		pudev = getCost(pickupafterstop,puid);
																		dodev = 0;
																	}

																	if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																		if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																		docalc = true;

																	}
																}

																if(!docalc){
																	break;
																}

															}

															bool isLate = false;
															int w = k;
															int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
															while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																string pDisability2 = schd_tab[s_tab[m][w]][12];
																string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																		p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																		a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																int p_perf_time2;
																string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																	AGRPCOUNTER = AGRPCOUNTER + 1;
																else{
																	if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																	{
																		APRVGRPCOUNTER = AGRPCOUNTER + 1;
																	}
																	AGRPCOUNTER = 0;
																}


																if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																	if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																		if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																		p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																	}


																	if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																		p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																		APRVGRPCOUNTER = 0;
																	}
																}
																else{

																	if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																		if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																			p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																		}

																		if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																			p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																			APRVGRPCOUNTER = 0;
																		}
																	}
																}

																}
																int aEarlypickup;
																int aEarlydropoff;
																int t1;

																if (pDisability2.find("LP",0) != string::npos){
																	aEarlypickup = 0;
																	aEarlydropoff = 0;
																}
																else{
																	if (pReturn_trip2 == "Y"){
																		aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		/* C[006] */
																		//   if(DEBUG == 1) gse << "here5 " << endl;
																	}
																	else{
																		aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		//   if(DEBUG == 1) gse << "here4 " << endl;
																	}
																}


																string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																		p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																		a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																int p_perf_time3;
																pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																	if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																		nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																	}
																	else{
																		nextstoptime = nextstoptime+p_perf_time2;
																	}
																}
																else{
																	if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																		nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																	}
																	else{
																		nextstoptime = nextstoptime+p_perf_time2;
																	}
																}

																int p_eta;
																if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																	p_eta = previouseta;
																}
																else{
																	p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																}

																nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																if (pDisability3.find("LP",0) != string::npos){
																	aEarlypickup = 0;
																	aEarlydropoff = 0;
																}
																else{
																	if (pReturn_trip3 == "Y"){
																		aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		/* C[006] */
																		//   if(DEBUG == 1) gse << "here5 " << endl;
																	}
																	else{
																		aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		//   if(DEBUG == 1) gse << "here4 " << endl;
																	}
																}
																int aLatepickup;
																if (pDisability3.find("OT",0) != string::npos)
																{
																	if (pReturn_trip3 == "Y"){
																		aLatepickup = p_OTHERLATEPICKFACTOR1;
																	}
																	else{

																		aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																	}
																}
																else if (pDisability3.find("LP",0) != string::npos){
																	aLatepickup = 0;
																}
																else{
																	if (pReturn_trip3 == "Y"){
																		aLatepickup = p_OTHERLATEPICKFACTOR1;
																	}
																	else{
																		aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																	}
																}
																bool preassigntripchange = true;

																int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																	endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																}
																string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																	preassigntripchange = false;
																	if ((p_stop_type == "P") && starttime1 != 0  ) {
																		if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																		{
																			int dev =  p_eta - (starttime1 + aLatepickup);
																			if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																				preassigntripchange = true;
																			}

																		}
																	}


																	if ((p_stop_type == "D") && (endtime1) != 0)
																	{
																		if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																		{
																			int dev =  p_eta - (endtime1);
																			if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																				preassigntripchange = true;
																			}
																		}
																	}
																}



																if(preassigntripchange){
																	if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																		if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																			isLate = true;
																			break;
																		}

																		// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																		//break;
																		//}
																	}
																	else{

																		if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																			isLate = true;
																			break;
																		}
																		else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																			if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				isLate = true;
																				break;}
																		}
																		// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																			//  break;
																			//}

																	}
																}else{
																	if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																}
																w++; previouseta = p_eta;
															}

															if(isLate){
																continue;
															}



															/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
															if(DEBUG == 1) gse << "No end time " << endl;

															if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

															return true;
														}
													}
													else if(tripstarttime == 0) {
														if(DEBUG == 1) gse << "no start time " << endl;
														if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
															trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
														}
														else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
															trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
														}
														else{
															trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
														}

														if (to_number(schd_tab[tripidx][27]) > 0)
														{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
														if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
														{
															continue;
														}

														}

														if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
															trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
														}
														else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
															trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
														}


														if((int)to_number(endtime1)!= 0)
															est_time = (int)to_number(endtime1);
														else{
															est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
														}
														trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

														if(endofsegtime > 0  ){

															if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																	int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																	int doeta1 = trav_time;
																	int actualTT = doeta1 - puetd1;
																	if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																	string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																	string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																	double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																	string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																	string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																	//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																	set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																			p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																			a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																	int groupcnter = 1;
																	routeint = (int)to_number(a_route.substr(1, a_route.length()));
																	//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																	for (int i = 0; i < MAXSEGMENTS; i++)
																	{
																		if (s_tab[i][0] == routeint)
																		{
																			for (int g = 1; g < MAXSTOPS; g++)
																			{
																				if (s_tab[i][g] == s_tab[m][k-1])
																				{

																					while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																						groupcnter++;
																						g--;
																					}
																					//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																					break;
																				}
																			}
																			break;
																		}
																	}
																	groupcnter = groupcnter + groupnumber;
																	int aAllowedTT;
																	if(estdisttrip < a_mediumshortdistance1)
																		aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																	else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																		aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																	else
																		aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																	if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																		aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																	}

																	if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																		//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																		//
																		if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																		if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																		break; ////to ensure that the insertion will not make the stop before which I insert late.

																	}


																}
																int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																int segend;
																for (int g = 1; g < MAXSTOPS; g++)
																{
																	if (s_tab[m][g] == 0)
																	{
																		segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																		break;

																	}
																}
																int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																timethreshold = segend - timethreshold;
																bool docalc = true;



																if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																		|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																){

																	double threshold;

																	if(inslack == "Y"){
																		threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																	}
																	else{
																		threshold = EXTRASLACK[0];
																	}


																	double pudev;
																	double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																	if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																		if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																			pudev = getCost(pickupafterstop,puid);
																			dodev = getCost(doid,  dropoffafterstop);
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																			dodev = pudev;

																		}
																	}
																	else{
																		pudev = getCost(pickupafterstop,puid);
																		dodev = 0;
																	}


																	docalc = false;

																	if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																		double distpu =  getCost(tripidx, s_tab[m][k]);
																		double distdo = getCost(tripidx+1, s_tab[m][k]);
																		if(isSameLocation(tripidx+1,s_tab[m][k])){
																			distdo = 0;
																		}
																		double cost = getCost(tripidx, s_tab[m][k-1]);

																		if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																			if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																			distpu = 0;
																			if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																				if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																				//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																					distdo = 0;
																				}
																			}

																			if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																				if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																				docalc = true;
																			}
																			else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																				if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																				docalc = true;
																			}

																	}else{

																		double distdo = getCost(tripidx+1, s_tab[m][k]);

																		if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																			if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																				pudev = getCost(pickupafterstop,puid);
																				dodev = getCost(doid,  dropoffafterstop);
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																				dodev = pudev;

																			}
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid);
																			dodev = 0;
																		}

																		if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																			if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																			docalc = true;

																		}
																	}

																	if(!docalc){
																		break;
																	}

																}

																bool isLate = false;
																int w = k;
																int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																	string pDisability2 = schd_tab[s_tab[m][w]][12];
																	string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																	string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																	set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																			p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																			a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																	int p_perf_time2;
																	string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																	set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																	if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																	if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																		AGRPCOUNTER = AGRPCOUNTER + 1;
																	else{
																		if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																		{
																			APRVGRPCOUNTER = AGRPCOUNTER + 1;
																		}
																		AGRPCOUNTER = 0;
																	}


																	if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																		if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																			if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																			p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																		}


																		if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																			p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																			APRVGRPCOUNTER = 0;
																		}
																	}
																	else{

																		if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																			if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																			}

																			if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																				APRVGRPCOUNTER = 0;
																			}
																		}
																	}

																	}
																	int aEarlypickup;
																	int aEarlydropoff;
																	int t1;

																	if (pDisability2.find("LP",0) != string::npos){
																		aEarlypickup = 0;
																		aEarlydropoff = 0;
																	}
																	else{
																		if (pReturn_trip2 == "Y"){
																			aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			/* C[006] */
																			//   if(DEBUG == 1) gse << "here5 " << endl;
																		}
																		else{
																			aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			//   if(DEBUG == 1) gse << "here4 " << endl;
																		}
																	}


																	string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																	string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																	string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																	set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																			p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																			a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																	int p_perf_time3;
																	pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																	set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																	if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																		if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																			nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																		}
																		else{
																			nextstoptime = nextstoptime+p_perf_time2;
																		}
																	}
																	else{
																		if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																			nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																		}
																		else{
																			nextstoptime = nextstoptime+p_perf_time2;
																		}
																	}


																	int p_eta;
																	if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																		p_eta = previouseta;
																	}
																	else{
																		p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																	}

																	nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);



																	if (pDisability3.find("LP",0) != string::npos){
																		aEarlypickup = 0;
																		aEarlydropoff = 0;
																	}
																	else{
																		if (pReturn_trip3 == "Y"){
																			aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			/* C[006] */
																			//   if(DEBUG == 1) gse << "here5 " << endl;
																		}
																		else{
																			aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																			aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																			//   if(DEBUG == 1) gse << "here4 " << endl;
																		}
																	}
																	int aLatepickup;
																	if (pDisability3.find("OT",0) != string::npos)
																	{
																		if (pReturn_trip3 == "Y"){
																			aLatepickup = p_OTHERLATEPICKFACTOR1;
																		}
																		else{

																			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																		}
																	}
																	else if (pDisability3.find("LP",0) != string::npos){
																		aLatepickup = 0;
																	}
																	else{
																		if (pReturn_trip3 == "Y"){
																			aLatepickup = p_OTHERLATEPICKFACTOR1;
																		}
																		else{
																			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																		}
																	}
																	bool preassigntripchange = true;

																	int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																	int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																	if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																		endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																	}
																	string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																	if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																		preassigntripchange = false;
																		if ((p_stop_type == "P") && starttime1 != 0  ) {
																			if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																			{
																				int dev =  p_eta - (starttime1 + aLatepickup);
																				if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																					preassigntripchange = true;
																				}

																			}
																		}


																		if ((p_stop_type == "D") && (endtime1) != 0)
																		{
																			if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																			{
																				int dev =  p_eta - (endtime1);
																				if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																					preassigntripchange = true;
																				}
																			}
																		}
																	}


																	if(preassigntripchange){
																		if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																			if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																				isLate = true;
																				break;
																			}

																			// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																			//break;
																			//}
																		}
																		else{

																			if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																				isLate = true;
																				break;
																			}
																			else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																					isLate = true;
																					break;}
																			}
																			// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																				//  break;
																				//}

																		}
																	}
																	else{
																		if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																	}

																	w++; previouseta = p_eta;
																}

																if(isLate){
																	continue;
																}



																/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

																return true;

															}

														}
														else{

															if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																int doeta1 = trav_time;
																int actualTT = doeta1 - puetd1;
																if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																		p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																		a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																int groupcnter = 1;
																routeint = (int)to_number(a_route.substr(1, a_route.length()));
																//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																for (int i = 0; i < MAXSEGMENTS; i++)
																{
																	if (s_tab[i][0] == routeint)
																	{
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[i][g] == s_tab[m][k-1])
																			{

																				while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																					groupcnter++;
																					g--;
																				}
																				//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																				break;
																			}
																		}
																		break;
																	}
																}
																groupcnter = groupcnter + groupnumber;
																int aAllowedTT;
																if(estdisttrip < a_mediumshortdistance1)
																	aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																	aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																else
																	aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																	aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																}

																if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																	//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																	//
																	if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																	if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																	break; ////to ensure that the insertion will not make the stop before which I insert late.

																}


															}
															int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
															int segend;
															for (int g = 1; g < MAXSTOPS; g++)
															{
																if (s_tab[m][g] == 0)
																{
																	segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																	break;

																}
															}
															int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
															int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
															timethreshold = segend - timethreshold;
															bool docalc = true;

															if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																	|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
															){


																double threshold;

																if(inslack == "Y"){
																	threshold = EXTRASLACK[0]; // 999, by Hui, for testing
																}
																else{
																	threshold = EXTRASLACK[0];
																}

																double pudev;
																double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																	if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																		pudev = getCost(pickupafterstop,puid);
																		dodev = getCost(doid,  dropoffafterstop);
																	}
																	else{
																		pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																		dodev = pudev;

																	}
																}
																else{
																	pudev = getCost(pickupafterstop,puid);
																	dodev = 0;
																}


																docalc = false;

																if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																	double distpu =  getCost(tripidx, s_tab[m][k]);
																	double distdo = getCost(tripidx+1, s_tab[m][k]);
																	if(isSameLocation(tripidx+1,s_tab[m][k])){
																		distdo = 0;
																	}
																	double cost = getCost(tripidx, s_tab[m][k-1]);

																	if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																		if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																		distpu = 0;
																		if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																			if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																			//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																				distdo = 0;
																			}
																		}

																		if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																			if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																			docalc = true;
																		}
																		else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																			if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																			docalc = true;
																		}

																}else{

																	double distdo = getCost(tripidx+1, s_tab[m][k]);

																	if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																		if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																			pudev = getCost(pickupafterstop,puid);
																			dodev = getCost(doid,  dropoffafterstop);
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																			dodev = pudev;

																		}
																	}
																	else{
																		pudev = getCost(pickupafterstop,puid);
																		dodev = 0;
																	}

																	if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																		if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																		docalc = true;

																	}
																}

																if(!docalc){
																	break;
																}

															}


															bool isLate = false;
															int w = k;
															int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
															while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																string pDisability2 = schd_tab[s_tab[m][w]][12];
																string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																		p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																		a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																int p_perf_time2;
																string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																	AGRPCOUNTER = AGRPCOUNTER + 1;
																else{
																	if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																	{
																		APRVGRPCOUNTER = AGRPCOUNTER + 1;
																	}
																	AGRPCOUNTER = 0;
																}


																if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																	if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																		if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																		p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																	}


																	if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																		p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																		APRVGRPCOUNTER = 0;
																	}
																}
																else{

																	if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																		if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																			p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																		}

																		if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																			p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																			APRVGRPCOUNTER = 0;
																		}
																	}
																}

																}
																int aEarlypickup;
																int aEarlydropoff;
																int t1;

																if (pDisability2.find("LP",0) != string::npos){
																	aEarlypickup = 0;
																	aEarlydropoff = 0;
																}
																else{
																	if (pReturn_trip2 == "Y"){
																		aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		/* C[006] */
																		//   if(DEBUG == 1) gse << "here5 " << endl;
																	}
																	else{
																		aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		//   if(DEBUG == 1) gse << "here4 " << endl;
																	}
																}


																string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																		p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																		a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																int p_perf_time3;
																pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																	if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																		nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																	}
																	else{
																		nextstoptime = nextstoptime+p_perf_time2;
																	}
																}
																else{
																	if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																		nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																	}
																	else{
																		nextstoptime = nextstoptime+p_perf_time2;
																	}
																}


																int p_eta;
																if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																	p_eta = previouseta;
																}
																else{
																	p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																}

																nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																if (pDisability3.find("LP",0) != string::npos){
																	aEarlypickup = 0;
																	aEarlydropoff = 0;
																}
																else{
																	if (pReturn_trip3 == "Y"){
																		aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		/* C[006] */
																		//   if(DEBUG == 1) gse << "here5 " << endl;
																	}
																	else{
																		aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																		aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																		//   if(DEBUG == 1) gse << "here4 " << endl;
																	}
																}
																int aLatepickup;
																if (pDisability3.find("OT",0) != string::npos)
																{
																	if (pReturn_trip3 == "Y"){
																		aLatepickup = p_OTHERLATEPICKFACTOR1;
																	}
																	else{

																		aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																	}
																}
																else if (pDisability3.find("LP",0) != string::npos){
																	aLatepickup = 0;
																}
																else{
																	if (pReturn_trip3 == "Y"){
																		aLatepickup = p_OTHERLATEPICKFACTOR1;
																	}
																	else{
																		aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																	}
																}
																bool preassigntripchange = true;

																int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																	endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																}
																string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																	preassigntripchange = false;
																	if ((p_stop_type == "P") && starttime1 != 0  ) {
																		if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																		{
																			int dev =  p_eta - (starttime1 + aLatepickup);
																			if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																				preassigntripchange = true;
																			}

																		}
																	}


																	if ((p_stop_type == "D") && (endtime1) != 0)
																	{
																		if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																		{
																			int dev =  p_eta - (endtime1);
																			if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																				preassigntripchange = true;
																			}
																		}
																	}
																}


																if(preassigntripchange){
																	if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																		if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																			isLate = true;
																			break;
																		}

																		// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																		//break;
																		//}
																	}
																	else{

																		if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																			isLate = true;
																			break;
																		}
																		else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																			if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				isLate = true;
																				break;}
																		}
																		// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																			//  break;
																			//}

																	}
																}else{
																	if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																}
																w++; previouseta = p_eta;
															}

															if(isLate){
																continue;
															}



															/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
															if(DEBUG == 1) gse << "No end time " << endl;

															if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

															return true;
														}
													}


												}
											}
										}
									}
								}
							}
						}
					}
					//break;
				}
			}

		}


		break;}
	}


	//   if(DEBUG == 1) gse << "Couldn't open " << route << endl;
	if(DEBUG == 1) gse << "Nothing fits on " << route << endl;
	return false;

}
////////////////////////searchtimeslotclustermatch//////////////////////


void swapint(int *xp, int *yp)
{
	int temp = *xp;
	*xp = *yp;
	*yp = temp;
}

void swapdouble(double *xp, double *yp)
{
	double temp = *xp;
	*xp = *yp;
	*yp = temp;
}
void swapstring(string *xp, string *yp)
{
	string temp = *xp;
	*xp = *yp;
	*yp = temp;
}

// A function to implement bubble sort
void bubbleSort(int arr[], int n)
{
	int i, j;
	for (i = 0; i < n-1; i++)

		// Last i elements are already in place
		for (j = 0; j < n-i-1; j++)
			if (arr[j] > arr[j+1])
				swapint(&arr[j], &arr[j+1]);
}

void bubbleSort_twoarray(double dist[],int tripidxes[], int groupcnt)
{
	int i, j;
	for (i = 0; i < groupcnt-1; i++)
		// Last i elements are already in place
		for (j = 0; j < groupcnt-i-1; j++)
			if (dist[j] > dist[j+1]){
				swapdouble(&dist[j], &dist[j+1]);
				swapint(&tripidxes[j], &tripidxes[j+1]);

			}
}
void bubbleSort_twoarray_str(double dev[],string json[], int groupcnt)
{
	int i, j;
	for (i = 0; i < groupcnt-1; i++)
		// Last i elements are already in place
		for (j = 0; j < groupcnt-i-1; j++)
			if (dev[j] > dev[j+1]){
				swapdouble(&dev[j], &dev[j+1]);
				swapstring(&json[j], &json[j+1]);

			}
}


void bubbleSort_threearray(double time1[], double dev[],string json[], int groupcnt)
{
	int i, j;
	for (i = 0; i < groupcnt-1; i++)
		// Last i elements are already in place
		for (j = 0; j < groupcnt-i-1; j++)
			if (dev[j] > dev[j+1]){
				swapdouble(&dev[j], &dev[j+1]);
				swapstring(&json[j], &json[j+1]);
				swapdouble(&time1[j], &time1[j+1]);

			}
}
void bubbleSort_threearray_int(double time1[], double dev[],int json[], int groupcnt)
{
	int i, j;
	for (i = 0; i < groupcnt-1; i++)
		// Last i elements are already in place
		for (j = 0; j < groupcnt-i-1; j++)
			if (dev[j] > dev[j+1]){
				swapdouble(&dev[j], &dev[j+1]);
				swapint(&json[j], &json[j+1]);
				swapdouble(&time1[j], &time1[j+1]);

			}
}

void bubbleSort_threearray_twoint(int time1[], double dev[],int json[], int groupcnt)
{
	int i, j;
	for (i = 0; i < groupcnt-1; i++)
		// Last i elements are already in place
		for (j = 0; j < groupcnt-i-1; j++)
			if (dev[j] > dev[j+1]){
				swapdouble(&dev[j], &dev[j+1]);
				swapint(&json[j], &json[j+1]);
				swapint(&time1[j], &time1[j+1]);

			}
}




void bubbleSort_threearray_desc(double time1[], double dev[],string json[], int groupcnt)
{
	int i, j;
	for (i = groupcnt-1; i > 0; i--)
		// Last i elements are already in place
		for (j = groupcnt-i-1; j > 0; j--)
			if (dev[j] > dev[j-1]){
				swapdouble(&dev[j], &dev[j-1]);
				swapstring(&json[j], &json[j-1]);
				swapdouble(&time1[j], &time1[j-1]);

			}
}


void bubbleSort_threearrayint_slackonly(double dev[], double time1[],int json[], int groupcnt)
{
	int i, j;
	for (i = 1; i <= groupcnt; i++)
		// Last i elements are already in place
		for (j = 1; j <= groupcnt-i; j++)
			if (dev[j] > dev[j+1]){
				swapdouble(&dev[j], &dev[j+1]);
				swapint(&json[j], &json[j+1]);
				swapdouble(&time1[j], &time1[j+1]);

			}
}

void bubbleSort_threearray_start_end(double leastdevstraightline[],double promtime[],int tripidxes[], int start,int end){

	if(DEBUG == 1) gse << "In sort by least dev " << endl;
	int i, j;
	for (i = start; i <= end; i++)
		// Last i elements are already in place
		for (j = start; j <= end-1; j++)
			if (leastdevstraightline[j] > leastdevstraightline[j+1]){
				swapint(&tripidxes[j], &tripidxes[j+1]);
				swapdouble(&promtime[j], &promtime[j+1]);
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
			}
}


void bubbleSort_threearray_start_end_string(double leastdevstraightline[],double promtime[],string tripidxes[], int start,int end){
	int i, j;
	for (i = start; i <= end; i++)
		// Last i elements are already in place
		for (j = start; j <= end-1; j++)
			if (leastdevstraightline[j] < leastdevstraightline[j+1]){
				swapstring(&tripidxes[j], &tripidxes[j+1]);
				swapdouble(&promtime[j], &promtime[j+1]);
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
			}
}

void bubbleSort_threearray_sortbytime(double time1[], double dev[],string json[], int groupcnt)
{
	int i, j;
	for (i = 0; i < groupcnt-1; i++)
		// Last i elements are already in place
		for (j = 0; j < groupcnt-i-1; j++)
			if (time1[j] > time1[j+1] && dev[j] == dev[j+1]){
				swapdouble(&dev[j], &dev[j+1]);
				swapstring(&json[j], &json[j+1]);
				swapdouble(&time1[j], &time1[j+1]);

			}
}



void bubbleSort_findbest(double leastdevstraightline[],int returnedroutespu[], int returnedroutesdo[], int cnt){

	int i, j;
	for (i = 0; i < cnt-1; i++)

		// Last i elements are already in place
		for (j = 0; j < cnt-i-1; j++)
			if (leastdevstraightline[j] > leastdevstraightline[j+1]){
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
				swapint(&returnedroutespu[j], &returnedroutespu[j+1]);
				swapint(&returnedroutesdo[j], &returnedroutesdo[j+1]);
			}
}
void bubbleSort_findbestdoublearry(int binarynotransferarray[],double promtime[],double leastdevstraightline[],int returnedroutespu[], int returnedroutesdo[], int cnt){

	int i, j;
	for (i = 0; i < cnt-1; i++)

		// Last i elements are already in place
		for (j = 0; j < cnt-i-1; j++)
			if (binarynotransferarray[j] > binarynotransferarray[j+1]){
				swapint(&binarynotransferarray[j], &binarynotransferarray[j+1]);
				swapdouble(&promtime[j], &promtime[j+1]);
				swapint(&returnedroutespu[j], &returnedroutespu[j+1]);
				swapint(&returnedroutesdo[j], &returnedroutesdo[j+1]);
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
			}
}
void bubbleSort_findbestdoublearry_start_end(double leastdevstraightline[],double promtime[],int binarynotransferarray[],int returnedroutespu[], int returnedroutesdo[], int start,int end){

	int i, j;
	for (i = start; i < end-1; i++)
		// Last i elements are already in place
		for (j = start; j < end-1; j++)
			if (leastdevstraightline[j] > leastdevstraightline[j+1]){
				swapint(&binarynotransferarray[j], &binarynotransferarray[j+1]);
				swapdouble(&promtime[j], &promtime[j+1]);
				swapint(&returnedroutespu[j], &returnedroutespu[j+1]);
				swapint(&returnedroutesdo[j], &returnedroutesdo[j+1]);
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
			}
}





void bubbleSort_findbestdoublearry2(double promtime[],double leastdevstraightline[],int returnedroutespu[], int returnedroutesdo[], int start, int end){

	int i, j;
	for (i = start; i < end-1; i++)

		// Last i elements are already in place
		for (j = start; j < end-1; j++)
			if (promtime[j] > promtime[j+1]){
				swapdouble(&promtime[j], &promtime[j+1]);
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
				swapint(&returnedroutespu[j], &returnedroutespu[j+1]);
				swapint(&returnedroutesdo[j], &returnedroutesdo[j+1]);
			}
}
void bubbleSort_findbestdoublearryup(double promtime[],double leastdevstraightline[],int binarynotransferarray[],int returnedroutespu[], int returnedroutesdo[], int start, int end){

	int i, j;
	for (i = start; i < end-1; i++)

		// Last i elements are already in place
		for (j = start; j < end-1; j++)
			if (promtime[j] > promtime[j+1]){
				swapdouble(&promtime[j], &promtime[j+1]);
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
				swapint(&returnedroutespu[j], &returnedroutespu[j+1]);
				swapint(&returnedroutesdo[j], &returnedroutesdo[j+1]);
				swapint(&binarynotransferarray[j], &binarynotransferarray[j+1]);
			}
}
void bubbleSort_findbestdoublearrydown(double promtime[],double leastdevstraightline[],int binarynotransferarray[],int returnedroutespu[], int returnedroutesdo[], int start, int end){


	int i, j;
	for (i = start; i < end-1; i++)

		// Last i elements are already in place
		for (j = start; j < end-1; j++)
			if (promtime[j] < promtime[j+1]){
				swapdouble(&promtime[j], &promtime[j+1]);
				swapdouble(&leastdevstraightline[j], &leastdevstraightline[j+1]);
				swapint(&returnedroutespu[j], &returnedroutespu[j+1]);
				swapint(&returnedroutesdo[j], &returnedroutesdo[j+1]);
				swapint(&binarynotransferarray[j], &binarynotransferarray[j+1]);
			}
}


////////////////////////searchonetimeslotclustermatch//////////////////////
int searchonetimeslotclustermatch(string route, string wc,string inslack, int timeslot, string triplength, int indextoconsider, double outsideofellipsevar, double maxdeviationfromstop_slack, double maxfirststopdeadhead, string tripids){ //s_tab[m][1] : search to see if this route has any unassigned trips that can fit on it

	if(DEBUG == 1) gse << "in searchonetimeslotclustermatch " <<  route << " " <<  triplength << endl;

	int tripidx;
	int triptimeslot ;
	int tripcluster ;
	string tripneighbors ;
	int cid;
	string routeneighbors;
	string temp;
	int cidroute;
	int t1;
	int t2;
	string a_route = route;
	int routeint = (int)to_number(a_route.substr(1,a_route.length()));
	int p_WHEELLOAD1;
	int p_AMBLOAD1;
	int p_MAXEARLYDROPOFFFACTOR1;
	int p_DIALRIDEEARLYPICKFACTOR1;
	int p_DIALRIDELATEPICKFACTOR1;
	int p_OTHEREARLYPICKFACTOR1;
	int p_OTHERLATEPICKFACTOR1;
	string IGNOREPUTIMES1;
	int p_SHORTBREAK1;
	int p_LUNCHBREAK1;
	int p_PROXIMITYFACTOR1;
	int a_mediumshortdistance1;
	int a_mediumlongdistance1;
	int a_shorttriptime1;
	int a_longtriptime1;
	int a_mediumtriptime1;
	int a_extra_loadtime1;
	string ZONE_DESCR1;
	string IGNORE_DEPOTS_CUTOFF1;
	int tripidxes[MAXTRIPIDX];
	double deviation[MAXTRIPIDX];
	int tripidxcnt = 0;






	for(int m = 0; m < MAXSEGMENTS; m++){
		if(s_tab[m][0] == routeint){ // find the route
			for(int k = 1; k < MAXSTOPS; k++){ // for every stop on route
				if(s_tab[m][k]==0)
					break;

				if(strcmp(schd_tab[s_tab[m][k]][2],"1")!=0 && s_tab[m][k] == indextoconsider){ //if not the first stop and it is equal to the index we are looking at in slack




					string pReturn_trip1 = schd_tab[s_tab[m][k - 1]][18];
					string pDisability1 = schd_tab[s_tab[m][k - 1]][12];
					string p_trip_type1 = schd_tab[s_tab[m][k - 1]][8];


					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type1);






					int aEarlypickup;
					int aEarlydropoff;
					int aLatepickup;
					int t1;




					if (pDisability1.find("LP",0) != string::npos){
						aEarlypickup = 0;
						aEarlydropoff = 0;
					}
					else{
						if (pReturn_trip1 == "Y"){
							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
							/* C[006] */
							//   if(DEBUG == 1) gse << "here5 " << endl;
						}
						else{
							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
							//   if(DEBUG == 1) gse << "here4 " << endl;
						}
					}

					string pDisability = schd_tab[s_tab[m][k]][12];
					string pReturn_trip = schd_tab[s_tab[m][k]][18];
					string p_trip_type = schd_tab[s_tab[m][k]][8];

					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type);


					if (pDisability.find("OT",0) != string::npos)
					{
						if (pReturn_trip == "Y"){

							aLatepickup = p_OTHERLATEPICKFACTOR1;
							//   if(DEBUG == 1) gse << "here5 " << endl;
						}
						else{

							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
							//   if(DEBUG == 1) gse << "here4 " << endl;
						}
					}
					else if (pDisability.find("LP",0) != string::npos){

						aLatepickup = 0;
						//  if(DEBUG == 1) gse << "here3 " << endl;
					}
					else{
						//aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
						//aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

						if (pReturn_trip == "Y"){


							aLatepickup = p_OTHERLATEPICKFACTOR1;
							//    if(DEBUG == 1) gse << "here2 " << endl;
						}
						else{

							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
							//  if(DEBUG == 1) gse << "here1 " << endl;
						}
					}


					if(strcmp(schd_tab[s_tab[m][k-1]][7],"P")==0){
						t1 = (int)ceil((to_number(schd_tab[s_tab[m][k-1]][4]) - aEarlypickup) ); // eta
					}
					else{
						t1 = (int)ceil((to_number(schd_tab[s_tab[m][k-1]][4]) - aEarlydropoff) ); // eta
					}

					if((int)ceil(to_number(schd_tab[s_tab[m][k-1]][30])) > t1){
						t1 = (int)ceil(to_number(schd_tab[s_tab[m][k-1]][30]));

					}


					int t2;
					if(strcmp(schd_tab[s_tab[m][k]][7],"P")==0){
						if((int)to_number(schd_tab[s_tab[m][k]][26]) > 0){
							t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][26]));
						}
						else{
							t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][30]));
						}
					}
					else{
						if((int)to_number(schd_tab[s_tab[m][k]][27]) > 0){
							t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][27]));
						}
						else{
							t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][30]));
						}
					}

					if((int)ceil(to_number(schd_tab[s_tab[m][k]][4])) > t2){
						t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][4]));
					}

					//int t2 =  (int)ceil(to_number(schd_tab[s_tab[m][k]][4])/15); // promise time

					int segmentstart = s_tab[m][1];
					int segmentend;

					for(int z = 1; z < MAXSTOPS; z++){
						if(s_tab[m][z] == 0){
							segmentend = s_tab[m][z-1];
							break;
						}
					}

					//  if(DEBUG == 1) gse << "new verison" << endl;


					if(t1 > (int)to_number(schd_tab[segmentend][4]))
						t1 = (int)to_number(schd_tab[segmentend][4]);


					if(t2 > (int)to_number(schd_tab[segmentend][4]))
						t2 = (int)to_number(schd_tab[segmentend][4]);

					//int etd = (int)to_number(schd_tab[s_tab[m][k-1]][30]);
					// int prom = (int)to_number(schd_tab[s_tab[m][k]][4]);
					int slack = t2 - t1;
					int endofsegtime = 0;
					if(DEBUG == 1) gse << "New stop " << k << endl;
					if(strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])==0){
						endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][4]);
					}
					if(strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])==0){
						endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][4]);
					}
					else{
						if(strcmp(schd_tab[s_tab[m][k]][7], "P")==0){
							if((int)to_number(schd_tab[s_tab[m][k]][26])>0)
								endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][26]) + aLatepickup ;
							else
								endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][4])  + aLatepickup ;

							if(DEBUG == 1) gse << "The trip before is " << schd_tab[s_tab[m][k-1]][3]  << " " << schd_tab[s_tab[m][k-1]][7] << " With time " << schd_tab[s_tab[m][k-1]][4] << endl;
							if(DEBUG == 1) gse << "The trip after is " << schd_tab[s_tab[m][k]][3] << " " << schd_tab[s_tab[m][k]][7] <<  " With time " << endofsegtime - aLatepickup << " " << aLatepickup << endl;
						}
						else{
							if((int)to_number(schd_tab[s_tab[m][k]][27])>0)
								endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][27]);
							else
								endofsegtime = (int)to_number(schd_tab[s_tab[m][k]][4]);

							if(DEBUG == 1) gse << "The trip before is " << schd_tab[s_tab[m][k-1]][3]  << " " << schd_tab[s_tab[m][k-1]][7] << " With time " << schd_tab[s_tab[m][k-1]][4] << endl;
							if(DEBUG == 1) gse << "The trip after is " << schd_tab[s_tab[m][k]][3]  << " " << schd_tab[s_tab[m][k]][7] << " With time " << endofsegtime << endl;

						}

					}
					//  if(DEBUG == 1) gse << "End of seg time is " << endofsegtime << endl;
					t2 = ceil(t2/15);
					t1 = ceil(t1/15);



					int wc_cap = (int)to_number(schd_tab[s_tab[m][1]][34]);
					int amb_cap = (int)to_number(schd_tab[s_tab[m][1]][33]);
					int cs_cap;
					int cy_cap;


					getCS_CY_cap(cs_cap, cy_cap, schd_tab[s_tab[m][1]][SEGMENTTYPE]);



					//t2 = (int)to_number(schd_tab[s_tab[m][k]][4])/15;
					//t1 = (int)to_number(schd_tab[s_tab[m][k-1]][29])/15;

					if(t2-t1 >= 0){ // if there's slack










						for (int i = 1; i < MAXTRIPIDX;i++){

							if(strcmp(schd_tab[i][10],"")==0)
								break;

							string trip = schd_tab[i][3];
							if(tripids!= "" && tripids.find(trip,0)==string::npos)
								continue;


							if ( strcmp(schd_tab[i][0],"")==0 && strcmp(schd_tab[i][7],"P")==0){ // if it's a pickup and unassigned trip
								string  p_disability = schd_tab[i][12];
								if(wc == "WC" && p_disability.find("WC", 0) != string::npos || wc == "WC" && p_disability.find("SC", 0) != string::npos || wc == "WC" && p_disability.find("DOSLOW", 0) != string::npos  || wc != "WC" ){
									tripidx = i;


									int timethreshold = (segmentend - segmentstart)*HEADHOMETHRESHOLD[0];
									timethreshold = segmentend - timethreshold;
									int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));

									pDisability = schd_tab[tripidx][12];
									pReturn_trip = schd_tab[tripidx][18];
									p_trip_type1 = schd_tab[tripidx][8];
									set_registry_values( p_WHEELLOAD1,  p_AMBLOAD1,
											p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
											a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);
									int p_perf_time;
									string pDisposition = schd_tab[tripidx][DISPOSITION];
									set_p_perf_time(pDisposition,pDisability,p_perf_time,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);



									string est_traveltime1 = schd_tab[tripidx][22];

									if (pDisability.find("LP",0) != string::npos){
										aEarlypickup = 0;
										aEarlydropoff = 0;
									}
									else{
										if (pReturn_trip == "Y"){
											aEarlypickup = p_OTHEREARLYPICKFACTOR1;
											aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
											/* C[006] */
											//   if(DEBUG == 1) gse << "here5 " << endl;
										}
										else{
											aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
											aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
											//   if(DEBUG == 1) gse << "here4 " << endl;
										}
									}

									if (pDisability.find("OT",0) != string::npos)
									{
										if (pReturn_trip == "Y"){

											aLatepickup = p_OTHERLATEPICKFACTOR1;
											//   if(DEBUG == 1) gse << "here5 " << endl;
										}
										else{

											aLatepickup = p_DIALRIDELATEPICKFACTOR1;
											//   if(DEBUG == 1) gse << "here4 " << endl;
										}
									}
									else if (pDisability.find("LP",0) != string::npos){

										aLatepickup = 0;
										//  if(DEBUG == 1) gse << "here3 " << endl;
									}
									else{
										//aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
										//aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

										if (pReturn_trip == "Y"){


											aLatepickup = p_OTHERLATEPICKFACTOR1;
											//    if(DEBUG == 1) gse << "here2 " << endl;
										}
										else{

											aLatepickup = p_DIALRIDELATEPICKFACTOR1;
											//  if(DEBUG == 1) gse << "here1 " << endl;
										}
									}
									triptimeslot = (int)to_number(schd_tab[tripidx][41]);
									tripcluster = (int)to_number(schd_tab[tripidx][42]);
									tripneighbors = schd_tab[tripidx][NEIGHBORS];

									if(triplength == "L" && to_number(schd_tab[tripidx][21]) <=  a_mediumlongdistance[0]){
										continue;
									}
									else if(triplength == "M" && to_number(schd_tab[tripidx][21]) <=  a_mediumshortdistance[0] || triplength == "M" && to_number(schd_tab[tripidx][21]) >  a_mediumlongdistance[0]){
										continue;
									}
									else if(triplength == "S" && to_number(schd_tab[tripidx][21]) >  a_mediumshortdistance[0]){
										continue;
									}



									if(triptimeslot >= timeslot -1 && triptimeslot <= timeslot +2  ){







										int prechecktime;
										int aLatepickup2;

										if(strcmp(schd_tab[s_tab[m][k]][7],"P")==0){
											string pReturn_trip12 = schd_tab[s_tab[m][k]][18];
											string pDisability12 = schd_tab[s_tab[m][k]][12];
											string p_trip_type12 = schd_tab[s_tab[m][k]][8];


											set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
													p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
													a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip12,  pDisability12,p_trip_type12);


											if (pDisability12.find("OT",0) != string::npos)
											{
												if (pReturn_trip12 == "Y"){

													aLatepickup2 = p_OTHERLATEPICKFACTOR1;
													//   if(DEBUG == 1) gse << "here5 " << endl;
												}
												else{

													aLatepickup2 = p_DIALRIDELATEPICKFACTOR1;
													//   if(DEBUG == 1) gse << "here4 " << endl;
												}
											}
											else if (pDisability12.find("LP",0) != string::npos){

												aLatepickup2 = 0;
												//  if(DEBUG == 1) gse << "here3 " << endl;
											}
											else{
												//aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
												//aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

												if (pReturn_trip12 == "Y"){


													aLatepickup2 = p_OTHERLATEPICKFACTOR1;
													//    if(DEBUG == 1) gse << "here2 " << endl;
												}
												else{

													aLatepickup2 = p_DIALRIDELATEPICKFACTOR1;
													//  if(DEBUG == 1) gse << "here1 " << endl;
												}
											}

											if((int)to_number(schd_tab[s_tab[m][k]][26]) ==0){
												prechecktime =  1440;
											}
											else{
												prechecktime = (int)to_number(schd_tab[s_tab[m][k]][4]) + aLatepickup2 + floor((RELAXCONSTRAINTS[0] - 1)*50);
											}


										}
										else{
											if((int)to_number(schd_tab[s_tab[m][k]][27]) ==0 && (int)to_number(schd_tab[s_tab[m][k]][2]) != (int)to_number(MAXSTOPNUM[0])){
												prechecktime =  1440;
											}

											else{
												prechecktime = (int)to_number(schd_tab[s_tab[m][k]][4]) + floor((RELAXCONSTRAINTS[0] - 1)*50);
											}
										}


										if(prechecktime >= (int)to_number(schd_tab[tripidx+1][4]) ){





											/* int triptimeslot2 = (int)to_number(schd_tab[tripidx+1][41]);
                              int segtimeslot;
                        if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0){
                            segtimeslot = (int)to_number(schd_tab[s_tab[m][k]][41]);
                        }
                       else{
                           segtimeslot = (int)to_number(schd_tab[s_tab[m][k]][41])  + (aLatepickup2/15)+1;
                       }*/

											if( triptimeslot >=t1 && triptimeslot <= t2 /*&& triptimeslot2 <= segtimeslot*/)
												if(DEBUG == 1) gse << "Examining trip  " << schd_tab[tripidx][3] << " " << schd_tab[tripidx][4] << " " << schd_tab[tripidx+1][4] <<   endl;
												else
													continue;




											for(int t = t1; t <=t2; t++){

												if(triptimeslot == t){ //if there's slack in the timeslot for the trip




													int extraperftime = 0;
													int wc_occ = (int)to_number(schd_tab[s_tab[m][k-1]][32]);
													int amb_occ = (int)to_number(schd_tab[s_tab[m][k-1]][31]);
													int cs_occ = (int)to_number(schd_tab[s_tab[m][k-1]][CS_OCC]);
													int cy_occ = (int)to_number(schd_tab[s_tab[m][k-1]][BS_OCC]);


													string pReturn_trip = schd_tab[tripidx][18];
													string pDisability = schd_tab[tripidx][12];
													string p_trip_type1 = schd_tab[tripidx][8];

													int escort = (int)to_number(schd_tab[tripidx][13]);

													if (pDisability.find("WC",0)!= string::npos || pDisability.find("SC",0)!= string::npos){
														wc_occ = wc_occ + 1;
														amb_occ = amb_occ + escort + 1;
													}

													else if (pDisability.find("CS",0)!= string::npos ){
														amb_occ = amb_occ + escort + 1;
														cs_occ++;
													}

													else if (pDisability.find("CY",0)!= string::npos ){
														amb_occ = amb_occ + escort + 1;
														cy_occ++;
													}
													else{
														amb_occ = amb_occ + escort + 1;
													}


													bool skiproute1 = false;
													int groupnumber = 0;

													for(int u = 1; u < MAXTRIPIDX; u++){
														if(strcmp(schd_tab[u][10],"")==0)
															break;

														if(strcmp(schd_tab[u][0],"")==0 && strcmp(schd_tab[u][7],"P")==0  && u != tripidx && ((isSameLocation(u,tripidx) && isSameLocation(u+1,tripidx+1)&&strcmp(schd_tab[u][41],schd_tab[tripidx][41])==0) || (strcmp(schd_tab[u][GRPIDX],"")!=0 &&strcmp(schd_tab[u][GRPIDX],schd_tab[tripidx][GRPIDX])==0 ))){


															skiproute1 = skipsegment(u, schd_tab[s_tab[m][k]][0]);
															if(skiproute1){
																break;
															}

															if(DEBUG == 1) gse << "Same location or group id as " << schd_tab[tripidx][3] << " --- " << schd_tab[u][3] << " group id " << schd_tab[u][GRPIDX] << endl;
															groupnumber++;

															string pReturn_trip = schd_tab[u][18];
															string pDisability = schd_tab[u][12];
															string p_trip_type1 = schd_tab[u][8];

															int escort = (int)to_number(schd_tab[u][13]);

															if (pDisability.find("WC",0)!= string::npos || pDisability.find("SC",0)!= string::npos){
																wc_occ = wc_occ + 1;
																amb_occ = amb_occ + escort;
															}

															else if (pDisability.find("CS",0)!= string::npos ){
																amb_occ = amb_occ + escort + 1;
																cs_occ++;
															}

															else if (pDisability.find("CY",0)!= string::npos ){
																amb_occ = amb_occ + escort + 1;
																cy_occ++;
															}
															else{
																amb_occ = amb_occ + escort + 1;
															}

															set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																	p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																	a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);
															int p_perf_time;
															string pDisposition = schd_tab[u][DISPOSITION];
															set_p_perf_time(pDisposition,pDisability,p_perf_time,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
															extraperftime = extraperftime + p_perf_time;


														}

													}
													if(skiproute1){
														if(DEBUG == 1) gse << "Conflicting exclusion/inclusion" << endl;
														break;
													}
													if(wc_occ > wc_cap || amb_occ > amb_cap || cs_occ > cs_cap || cy_occ > cy_cap){

														if(DEBUG == 1) gse << "no space " << endl;
														if(DEBUG == 1) gse << wc_occ  << " > " <<  wc_cap << " or " << amb_occ  << " > " << amb_cap << " or " << cs_occ  << " > " <<  cs_cap << " or " << cy_occ  << " > " <<  cy_cap <<endl;
														break;

													}




													if(strcmp(schd_tab[tripidx][42],schd_tab[s_tab[m][k-1]][42])==0){
														string tempneighbors =  schd_tab[s_tab[m][k]][NEIGHBORS];
														int tripcluster2 = (int)to_number(schd_tab[tripidx+1][42]);
														while(tempneighbors != ""){
															int cidroute = (int)to_number(getNextToken(&(tempneighbors),","));
															if(tripcluster2 == cidroute || tripcluster2 == (int)to_number(schd_tab[s_tab[m][k]][42])){




																if(DEBUG == 1) gse << "The clusters directly match!" << endl;
																bool skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
																if(!skiproute){

																	if(strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0){
																		if(DEBUG == 1) gse << "We are exmaining the first stop so checking distance!"<< endl;
																		double distance = getActualDistance(s_tab[m][k-1],tripidx);
																		if(distance > maxfirststopdeadhead && ((inslack == "Y" && (strcmp(schd_tab[s_tab[m][k-1]][2],"1")!=0 || strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0))|| (inslack == "E"))){
																			if(DEBUG == 1) gse << "There's too much deadhead in the beginning of the segment" << endl;
																			continue;
																		}
																	}

																	string starttime1 = schd_tab[tripidx][26];
																	string endtime1 = schd_tab[tripidx][27];
																	int est_time;
																	if((int)to_number(starttime1)!= 0){
																		est_time = (int)to_number(starttime1);
																	}
																	else{
																		est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
																	}
																	int trav_time =   (int)to_number(schd_tab[s_tab[m][k-1]][30]) + getTravTime_passedEta(s_tab[m][k-1],tripidx, to_string(est_time),"0");
																	int tripstarttime = (int)to_number(schd_tab[tripidx][26]);

																	if (trav_time < tripstarttime + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50) && tripstarttime > 0){


																		if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																			trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																		}
																		else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																			trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																		}
																		else{
																			trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																		}

																		if (to_number(schd_tab[tripidx][27]) > 0)
																		{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																		if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																		{
																			break;
																		}

																		}

																		if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																			trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																		}
																		else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																			trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																		}
																		if((int)to_number(endtime1)!= 0)
																			est_time = (int)to_number(endtime1);
																		else{
																			est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																		}
																		trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																		if(endofsegtime > 0 ){

																			if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){




																				if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																					int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																					int doeta1 = trav_time;
																					int actualTT = doeta1 - puetd1;
																					if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																					string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																					string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																					double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																					string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																					string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																					//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																					int groupcnter = 1;
																					routeint = (int)to_number(a_route.substr(1, a_route.length()));
																					//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																					for (int i = 0; i < MAXSEGMENTS; i++)
																					{
																						if (s_tab[i][0] == routeint)
																						{
																							for (int g = 1; g < MAXSTOPS; g++)
																							{
																								if (s_tab[i][g] == s_tab[m][k-1])
																								{

																									while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																										groupcnter++;
																										g--;
																									}
																									//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																									break;
																								}
																							}
																							break;
																						}
																					}
																					groupcnter = groupcnter + groupnumber;
																					int aAllowedTT;
																					if(estdisttrip < a_mediumshortdistance1)
																						aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																						aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else
																						aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																					if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																						aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																					}

																					if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																						//
																						if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																						if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																						break; ////to ensure that the insertion will not make the stop before which I insert late.

																					}


																				}




																				int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																				int segend;
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[m][g] == 0)
																					{
																						segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																						break;

																					}
																				}
																				int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																				int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																				timethreshold = segend - timethreshold;
																				bool docalc = true;

																				if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																						|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																				){


																					double threshold;

																					if(inslack == "Y"){
																						threshold = 999;
																					}
																					else{
																						threshold = EXTRASLACK[0];
																					}

																					double pudev;
																					double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}


																					docalc = false;

																					if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																						double distpu =  getCost(tripidx, s_tab[m][k]);
																						double distdo = getCost(tripidx+1, s_tab[m][k]);
																						if(isSameLocation(tripidx+1,s_tab[m][k])){
																							distdo = 0;
																						}
																						double cost = getCost(tripidx, s_tab[m][k-1]);

																						if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																							distpu = 0;
																							if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																								if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																								//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																									distdo = 0;
																								}
																							}

																							if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																								if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}
																							else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																								if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}

																					}else{

																						double distdo = getCost(tripidx+1, s_tab[m][k]);

																						if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																							if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																								pudev = getCost(pickupafterstop,puid);
																								dodev = getCost(doid,  dropoffafterstop);
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																								dodev = pudev;

																							}
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid);
																							dodev = 0;
																						}

																						if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																							if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																							docalc = true;

																						}
																					}

																					if(!docalc){
																						break;
																					}

																				}




																				bool isLate = false;
																				int w = k;
																				int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																				while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){


																					string pDisability2 = schd_tab[s_tab[m][w]][12];
																					string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																					string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																					int p_perf_time2;
																					string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																					if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																					if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																						AGRPCOUNTER = AGRPCOUNTER + 1;
																					else{
																						if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																						{
																							APRVGRPCOUNTER = AGRPCOUNTER + 1;
																						}
																						AGRPCOUNTER = 0;
																					}


																					if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																							if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}


																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																					else{

																						if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																							}

																							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																								APRVGRPCOUNTER = 0;
																							}
																						}
																					}

																					}
																					int aEarlypickup;
																					int aEarlydropoff;
																					int t1;

																					if (pDisability2.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip2 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}


																					string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																					string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																					string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																					int p_perf_time3;
																					pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																					if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																						if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}
																					else{
																						if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}


																					int p_eta;
																					if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																						p_eta = previouseta;
																					}
																					else{
																						p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																					}

																					nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);



																					if (pDisability3.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}
																					int aLatepickup;
																					if (pDisability3.find("OT",0) != string::npos)
																					{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{

																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}
																					else if (pDisability3.find("LP",0) != string::npos){
																						aLatepickup = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{
																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}

																					bool preassigntripchange = true;

																					int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																					int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																					if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																					}
																					string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																					if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																						preassigntripchange = false;
																						if ((p_stop_type == "P") && starttime1 != 0  ) {
																							if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																							{
																								int dev =  p_eta - (starttime1 + aLatepickup);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}

																							}
																						}


																						if ((p_stop_type == "D") && (endtime1) != 0)
																						{
																							if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																							{
																								int dev =  p_eta - (endtime1);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}
																							}
																						}
																					}


																					if(preassigntripchange){
																						if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																								isLate = true;
																								break;
																							}

																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																							//break;
																							//}
																						}
																						else{

																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																								isLate = true;
																								break;
																							}
																							else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																									isLate = true;
																									break;}
																							}
																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																								//  break;
																								//}

																						}
																					}else{
																						if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																					}
																					w++; previouseta = p_eta;
																				}

																				if(isLate){
																					break;
																				}



																				/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/

																				if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																				if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;


																				tripidxes[tripidxcnt] = tripidx;
																				deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																				tripidxcnt++;break;

																			}

																		}
																		else{

																			if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																				int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																				int doeta1 = trav_time;
																				int actualTT = doeta1 - puetd1;
																				if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																				string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																				string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																				double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																				string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																				string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																				//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																				int groupcnter = 1;
																				routeint = (int)to_number(a_route.substr(1, a_route.length()));
																				//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																				for (int i = 0; i < MAXSEGMENTS; i++)
																				{
																					if (s_tab[i][0] == routeint)
																					{
																						for (int g = 1; g < MAXSTOPS; g++)
																						{
																							if (s_tab[i][g] == s_tab[m][k-1])
																							{

																								while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																									groupcnter++;
																									g--;
																								}
																								//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																								break;
																							}
																						}
																						break;
																					}
																				}
																				groupcnter = groupcnter + groupnumber;
																				int aAllowedTT;
																				if(estdisttrip < a_mediumshortdistance1)
																					aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																					aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else
																					aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																				if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																					aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																				}


																				if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																					//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																					//
																					if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																					if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																					break; ////to ensure that the insertion will not make the stop before which I insert late.

																				}


																			}int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																			int segend;
																			for (int g = 1; g < MAXSTOPS; g++)
																			{
																				if (s_tab[m][g] == 0)
																				{
																					segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																					break;

																				}
																			}
																			int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																			int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																			timethreshold = segend - timethreshold;
																			bool docalc = true;

																			if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																					|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																			){

																				double threshold;

																				if(inslack == "Y"){
																					threshold = 999;
																				}
																				else{
																					threshold = EXTRASLACK[0];
																				}


																				double pudev;
																				double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}


																				docalc = false;

																				if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																					double distpu =  getCost(tripidx, s_tab[m][k]);
																					double distdo = getCost(tripidx+1, s_tab[m][k]);
																					if(isSameLocation(tripidx+1,s_tab[m][k])){
																						distdo = 0;
																					}
																					double cost = getCost(tripidx, s_tab[m][k-1]);

																					if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																						distpu = 0;
																						if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																							//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																								distdo = 0;
																							}
																						}

																						if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																							if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}
																						else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																							if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}

																				}else{

																					double distdo = getCost(tripidx+1, s_tab[m][k]);

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}

																					if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																						if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																						docalc = true;

																					}
																				}

																				if(!docalc){
																					break;
																				}

																			}

																			bool isLate = false;
																			int w = k;
																			int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																			while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																				string pDisability2 = schd_tab[s_tab[m][w]][12];
																				string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																				string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																				int p_perf_time2;
																				string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																				if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																				if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																					AGRPCOUNTER = AGRPCOUNTER + 1;
																				else{
																					if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																					{
																						APRVGRPCOUNTER = AGRPCOUNTER + 1;
																					}
																					AGRPCOUNTER = 0;
																				}


																				if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																						if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}


																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																				else{

																					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}

																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																				}

																				}
																				int aEarlypickup;
																				int aEarlydropoff;
																				int t1;

																				if (pDisability2.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip2 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}


																				string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																				string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																				string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																				int p_perf_time3;
																				pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																				if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																					if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}
																				else{
																					if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}


																				int p_eta;
																				if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																					p_eta = previouseta;
																				}
																				else{
																					p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																				}

																				nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																				if (pDisability3.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}
																				int aLatepickup;
																				if (pDisability3.find("OT",0) != string::npos)
																				{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{

																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}
																				else if (pDisability3.find("LP",0) != string::npos){
																					aLatepickup = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{
																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}
																				bool preassigntripchange = true;

																				int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																				int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																				if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																				}
																				string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																				if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																					preassigntripchange = false;
																					if ((p_stop_type == "P") && starttime1 != 0  ) {
																						if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																						{
																							int dev =  p_eta - (starttime1 + aLatepickup);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}

																						}
																					}


																					if ((p_stop_type == "D") && (endtime1) != 0)
																					{
																						if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																						{
																							int dev =  p_eta - (endtime1);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}
																						}
																					}
																				}

																				if(preassigntripchange){
																					if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																							isLate = true;
																							break;
																						}

																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																						//break;
																						//}
																					}
																					else{

																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																							isLate = true;
																							break;
																						}
																						else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																								isLate = true;
																								break;}
																						}
																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																							//  break;
																							//}

																					}
																				}else{
																					if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																				}
																				w++; previouseta = p_eta;
																			}

																			if(isLate){
																				break;
																			}



																			/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																			if(DEBUG == 1) gse << "No end time " << endl;

																			if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;

																			tripidxes[tripidxcnt] = tripidx;
																			deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																			tripidxcnt++;break;
																		}
																	}
																	else if(tripstarttime == 0) {
																		if(DEBUG == 1) gse << "no start time " << endl;

																		if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																			trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																		}
																		else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																			trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																		}
																		else{
																			trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																		}

																		if (to_number(schd_tab[tripidx][27]) > 0)
																		{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																		if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																		{
																			break;
																		}

																		}
																		if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																			trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																		}
																		else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																			trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																		}

																		if((int)to_number(endtime1)!= 0)
																			est_time = (int)to_number(endtime1);
																		else{
																			est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																		}
																		trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																		if(endofsegtime > 0  ){

																			if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																				if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																					int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																					int doeta1 = trav_time;
																					int actualTT = doeta1 - puetd1;
																					if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																					string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																					string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																					double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																					string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																					string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																					//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																					int groupcnter = 1;
																					routeint = (int)to_number(a_route.substr(1, a_route.length()));
																					//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																					for (int i = 0; i < MAXSEGMENTS; i++)
																					{
																						if (s_tab[i][0] == routeint)
																						{
																							for (int g = 1; g < MAXSTOPS; g++)
																							{
																								if (s_tab[i][g] == s_tab[m][k-1])
																								{

																									while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																										groupcnter++;
																										g--;
																									}
																									//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																									break;
																								}
																							}
																							break;
																						}
																					}
																					groupcnter = groupcnter + groupnumber;
																					int aAllowedTT;

																					if(estdisttrip < a_mediumshortdistance1)
																						aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																						aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else
																						aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																					if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																						aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																					}

																					if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																						//
																						if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																						if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																						break; ////to ensure that the insertion will not make the stop before which I insert late.

																					}


																				}
																				int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																				int segend;
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[m][g] == 0)
																					{
																						segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																						break;

																					}
																				}
																				int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																				int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																				timethreshold = segend - timethreshold;
																				bool docalc = true;

																				if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																						|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																				){


																					double threshold;

																					if(inslack == "Y"){
																						threshold = 999;
																					}
																					else{
																						threshold = EXTRASLACK[0];
																					}

																					double pudev;
																					double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}


																					docalc = false;

																					if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																						double distpu =  getCost(tripidx, s_tab[m][k]);
																						double distdo = getCost(tripidx+1, s_tab[m][k]);
																						if(isSameLocation(tripidx+1,s_tab[m][k])){
																							distdo = 0;
																						}
																						double cost = getCost(tripidx, s_tab[m][k-1]);

																						if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																							distpu = 0;
																							if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																								if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																								//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																									distdo = 0;
																								}
																							}

																							if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																								if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}
																							else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																								if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}

																					}else{

																						double distdo = getCost(tripidx+1, s_tab[m][k]);

																						if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																							if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																								pudev = getCost(pickupafterstop,puid);
																								dodev = getCost(doid,  dropoffafterstop);
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																								dodev = pudev;

																							}
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid);
																							dodev = 0;
																						}

																						if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																							if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																							docalc = true;

																						}
																					}

																					if(!docalc){
																						break;
																					}

																				}
																				bool isLate = false;
																				int w = k;
																				int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																				while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																					string pDisability2 = schd_tab[s_tab[m][w]][12];
																					string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																					string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																					int p_perf_time2;
																					string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																					if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																					if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																						AGRPCOUNTER = AGRPCOUNTER + 1;
																					else{
																						if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																						{
																							APRVGRPCOUNTER = AGRPCOUNTER + 1;
																						}
																						AGRPCOUNTER = 0;
																					}


																					if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																							if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}


																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																					else{

																						if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																							}

																							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																								APRVGRPCOUNTER = 0;
																							}
																						}
																					}

																					}
																					int aEarlypickup;
																					int aEarlydropoff;
																					int t1;

																					if (pDisability2.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip2 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}


																					string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																					string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																					string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																					int p_perf_time3;
																					pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																					if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																						if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}
																					else{
																						if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}


																					int p_eta;
																					if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																						p_eta = previouseta;
																					}
																					else{
																						p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																					}

																					nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																					if (pDisability3.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}
																					int aLatepickup;
																					if (pDisability3.find("OT",0) != string::npos)
																					{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{

																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}
																					else if (pDisability3.find("LP",0) != string::npos){
																						aLatepickup = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{
																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}
																					bool preassigntripchange = true;

																					int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																					int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																					if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																					}
																					string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																					if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																						preassigntripchange = false;
																						if ((p_stop_type == "P") && starttime1 != 0  ) {
																							if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																							{
																								int dev =  p_eta - (starttime1 + aLatepickup);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}

																							}
																						}


																						if ((p_stop_type == "D") && (endtime1) != 0)
																						{
																							if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																							{
																								int dev =  p_eta - (endtime1);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}
																							}
																						}
																					}


																					if(preassigntripchange){
																						if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																								isLate = true;
																								break;
																							}

																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																							//break;
																							//}
																						}
																						else{

																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																								isLate = true;
																								break;
																							}
																							else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																									isLate = true;
																									break;}
																							}
																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																								//  break;
																								//}

																						}
																					}else{
																						if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																					}
																					w++; previouseta = p_eta;
																				}

																				if(isLate){
																					break;
																				}



																				/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/

																				if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																				if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;

																				tripidxes[tripidxcnt] = tripidx;
																				deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																				tripidxcnt++;break;

																			}

																		}
																		else{

																			if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																				int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																				int doeta1 = trav_time;
																				int actualTT = doeta1 - puetd1;
																				if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																				string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																				string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																				double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																				string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																				string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																				//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																				int groupcnter = 1;
																				routeint = (int)to_number(a_route.substr(1, a_route.length()));
																				//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																				for (int i = 0; i < MAXSEGMENTS; i++)
																				{
																					if (s_tab[i][0] == routeint)
																					{
																						for (int g = 1; g < MAXSTOPS; g++)
																						{
																							if (s_tab[i][g] == s_tab[m][k-1])
																							{

																								while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																									groupcnter++;
																									g--;
																								}
																								//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																								break;
																							}
																						}
																						break;
																					}
																				}
																				groupcnter = groupcnter + groupnumber;
																				int aAllowedTT;

																				if(estdisttrip < a_mediumshortdistance1)
																					aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																					aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																				else
																					aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																				if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																					aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																				}

																				if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																					//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																					//
																					if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																					if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																					break; ////to ensure that the insertion will not make the stop before which I insert late.

																				}


																			}
																			int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																			int segend;
																			for (int g = 1; g < MAXSTOPS; g++)
																			{
																				if (s_tab[m][g] == 0)
																				{
																					segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																					break;

																				}
																			}
																			int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																			int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																			timethreshold = segend - timethreshold;
																			bool docalc = true;

																			if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																					|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																			){

																				double threshold;

																				if(inslack == "Y"){
																					threshold = 999;
																				}
																				else{
																					threshold = EXTRASLACK[0];
																				}


																				double pudev;
																				double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}


																				docalc = false;

																				if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																					double distpu =  getCost(tripidx, s_tab[m][k]);
																					double distdo = getCost(tripidx+1, s_tab[m][k]);
																					if(isSameLocation(tripidx+1,s_tab[m][k])){
																						distdo = 0;
																					}
																					double cost = getCost(tripidx, s_tab[m][k-1]);

																					if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																						distpu = 0;
																						if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																							//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																								distdo = 0;
																							}
																						}

																						if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																							if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}
																						else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																							if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																							docalc = true;
																						}

																				}else{

																					double distdo = getCost(tripidx+1, s_tab[m][k]);

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}

																					if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																						if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																						docalc = true;

																					}
																				}

																				if(!docalc){
																					break;
																				}

																			}

																			bool isLate = false;
																			int w = k;
																			int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																			while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																				string pDisability2 = schd_tab[s_tab[m][w]][12];
																				string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																				string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																				int p_perf_time2;
																				string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																				if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																				if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																					AGRPCOUNTER = AGRPCOUNTER + 1;
																				else{
																					if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																					{
																						APRVGRPCOUNTER = AGRPCOUNTER + 1;
																					}
																					AGRPCOUNTER = 0;
																				}


																				if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																						if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}


																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																				else{

																					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}

																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																				}

																				}
																				int aEarlypickup;
																				int aEarlydropoff;
																				int t1;

																				if (pDisability2.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip2 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}


																				string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																				string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																				string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																				int p_perf_time3;
																				pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																				set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																				if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																					if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}
																				else{
																					if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																						nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																					}
																					else{
																						nextstoptime = nextstoptime+p_perf_time2;
																					}
																				}


																				int p_eta;
																				if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																					p_eta = previouseta;
																				}
																				else{
																					p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																				}

																				nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																				if (pDisability3.find("LP",0) != string::npos){
																					aEarlypickup = 0;
																					aEarlydropoff = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						/* C[006] */
																						//   if(DEBUG == 1) gse << "here5 " << endl;
																					}
																					else{
																						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																						aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																						//   if(DEBUG == 1) gse << "here4 " << endl;
																					}
																				}

																				int aLatepickup;
																				if (pDisability3.find("OT",0) != string::npos)
																				{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{

																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}
																				else if (pDisability3.find("LP",0) != string::npos){
																					aLatepickup = 0;
																				}
																				else{
																					if (pReturn_trip3 == "Y"){
																						aLatepickup = p_OTHERLATEPICKFACTOR1;
																					}
																					else{
																						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																					}
																				}
																				bool preassigntripchange = true;

																				int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																				int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																				if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																				}
																				string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																				if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																					preassigntripchange = false;
																					if ((p_stop_type == "P") && starttime1 != 0  ) {
																						if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																						{
																							int dev =  p_eta - (starttime1 + aLatepickup);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}

																						}
																					}


																					if ((p_stop_type == "D") && (endtime1) != 0)
																					{
																						if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																						{
																							int dev =  p_eta - (endtime1);
																							if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																								preassigntripchange = true;
																							}
																						}
																					}
																				}



																				if(preassigntripchange){
																					if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																							isLate = true;
																							break;
																						}

																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																						//break;
																						//}
																					}
																					else{

																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																							isLate = true;
																							break;
																						}
																						else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																								isLate = true;
																								break;}
																						}
																						// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																							//  break;
																							//}

																					}
																				}else{
																					if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																				}
																				w++; previouseta = p_eta;
																			}

																			if(isLate){
																				break;
																			}



																			/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																			if(DEBUG == 1) gse << "No end time " << endl;

																			if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with direct cluster " << tripcluster << endl;

																			tripidxes[tripidxcnt] = tripidx;
																			deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																			tripidxcnt++;break;
																		}
																	}


																}

																break;
															}
														}
													} // if the clusters match


													//while(tripneighbors != ""){ // move on to neighbors if not found for original cluster
													//cid = (int)to_number(getNextToken(&(tripneighbors),","));
													temp = schd_tab[s_tab[m][k-1]][NEIGHBORS];
													bool foundmatch = false;
													//int temproutecluster  = (int)to_number( schd_tab[s_tab[m][k-1]][42]);
													string temp2 = schd_tab[s_tab[m][k]][NEIGHBORS];
													int tripcluster2 = (int)to_number(schd_tab[tripidx+1][42]);
													while(temp != ""){
														cidroute = (int)to_number(getNextToken(&(temp),","));
														if(tripcluster == cidroute){
															while(temp2 != ""){
																int cidroute2 = (int)to_number(getNextToken(&(temp2),","));
																if(tripcluster2 == cidroute2 || tripcluster2 == (int)to_number(schd_tab[s_tab[m][k]][42])){
																	//if(cid == cidroute || cid == temproutecluster || cidroute  == tripcluster || tripcluster == temproutecluster)


																	bool skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
																	if(!skiproute){

																		if(strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0){
																			if(DEBUG == 1) gse << "We are exmaining the first stop so checking distance!"<< endl;
																			double distance = getActualDistance(s_tab[m][k-1],tripidx);
																			if(distance > maxfirststopdeadhead && ((inslack == "Y" && (strcmp(schd_tab[s_tab[m][k-1]][2],"1")!=0 || strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0))|| (inslack == "E"))){
																				if(DEBUG == 1) gse << "There's too much deadhead in the beginning of the segment" << endl;
																				continue;
																			}
																		}

																		string starttime1 = schd_tab[tripidx][26];
																		string endtime1 = schd_tab[tripidx][27];
																		int est_time;
																		if((int)to_number(starttime1)!= 0){
																			est_time = (int)to_number(starttime1);
																		}
																		else{
																			est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
																		}
																		int trav_time =   (int)to_number(schd_tab[s_tab[m][k-1]][30]) +getTravTime_passedEta(s_tab[m][k-1],tripidx, to_string(est_time),"0");
																		int tripstarttime = (int)to_number(schd_tab[tripidx][26]);

																		if (trav_time < tripstarttime + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50) && tripstarttime > 0){


																			if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																				//  if(DEBUG == 1) gse <<" using 1 " << schd_tab[tripidx][26] << endl;
																				trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																			}
																			else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																				//  if(DEBUG == 1) gse <<" using 2 " << schd_tab[tripidx][4] << endl;
																				trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																			}
																			else{
																				//  if(DEBUG == 1) gse <<" none " << trav_time  << endl;
																				trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																			}

																			if (to_number(schd_tab[tripidx][27]) > 0)
																			{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																			if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																			{
																				break;
																			}

																			}

																			if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																				trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																			}
																			else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																				trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																			}

																			if((int)to_number(endtime1)!= 0)
																				est_time = (int)to_number(endtime1);
																			else{
																				est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																			}
																			trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																			if(endofsegtime > 0  ){

																				if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																					if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																						int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																						int doeta1 = trav_time;
																						int actualTT = doeta1 - puetd1;
																						if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																						string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																						string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																						double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																						string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																						string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																						//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																						set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																								p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																								a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																						int groupcnter = 1;
																						routeint = (int)to_number(a_route.substr(1, a_route.length()));
																						//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																						for (int i = 0; i < MAXSEGMENTS; i++)
																						{
																							if (s_tab[i][0] == routeint)
																							{
																								for (int g = 1; g < MAXSTOPS; g++)
																								{
																									if (s_tab[i][g] == s_tab[m][k-1])
																									{

																										while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																											groupcnter++;
																											g--;
																										}
																										//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																										break;
																									}
																								}
																								break;
																							}
																						}
																						groupcnter = groupcnter + groupnumber;
																						int aAllowedTT;

																						if(estdisttrip < a_mediumshortdistance1)
																							aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																						else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																							aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																						else
																							aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																						if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																							aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																						}


																						if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																							//
																							if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																							if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																							break; ////to ensure that the insertion will not make the stop before which I insert late.

																						}


																					}
																					int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																					int segend;
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[m][g] == 0)
																						{
																							segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																							break;

																						}
																					}
																					int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																					int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																					timethreshold = segend - timethreshold;
																					bool docalc = true;

																					if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																							|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																					){

																						double threshold;

																						if(inslack == "Y"){
																							threshold = 999;
																						}
																						else{
																							threshold = EXTRASLACK[0];
																						}


																						double pudev;
																						double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																						if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																							if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																								pudev = getCost(pickupafterstop,puid);
																								dodev = getCost(doid,  dropoffafterstop);
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																								dodev = pudev;

																							}
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid);
																							dodev = 0;
																						}


																						docalc = false;

																						if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																							double distpu =  getCost(tripidx, s_tab[m][k]);
																							double distdo = getCost(tripidx+1, s_tab[m][k]);
																							if(isSameLocation(tripidx+1,s_tab[m][k])){
																								distdo = 0;
																							}
																							double cost = getCost(tripidx, s_tab[m][k-1]);

																							if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																								if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																								distpu = 0;
																								if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																									if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																									//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																										distdo = 0;
																									}
																								}

																								if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																									if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																									docalc = true;
																								}
																								else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																									if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																									docalc = true;
																								}

																						}else{

																							double distdo = getCost(tripidx+1, s_tab[m][k]);

																							if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																								if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																									pudev = getCost(pickupafterstop,puid);
																									dodev = getCost(doid,  dropoffafterstop);
																								}
																								else{
																									pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																									dodev = pudev;

																								}
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid);
																								dodev = 0;
																							}

																							if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																								if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																								docalc = true;

																							}
																						}

																						if(!docalc){
																							break;
																						}

																					}

																					bool isLate = false;
																					int w = k;
																					int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																					while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																						string pDisability2 = schd_tab[s_tab[m][w]][12];
																						string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																						string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																						set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																								p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																								a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																						int p_perf_time2;
																						string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																						set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																						if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																						if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																							AGRPCOUNTER = AGRPCOUNTER + 1;
																						else{
																							if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																							{
																								APRVGRPCOUNTER = AGRPCOUNTER + 1;
																							}
																							AGRPCOUNTER = 0;
																						}


																						if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																								if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																								p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																							}


																							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																								APRVGRPCOUNTER = 0;
																							}
																						}
																						else{

																							if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																								if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																									p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																								}

																								if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																									p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																									APRVGRPCOUNTER = 0;
																								}
																							}
																						}

																						}
																						int aEarlypickup;
																						int aEarlydropoff;
																						int t1;

																						if (pDisability2.find("LP",0) != string::npos){
																							aEarlypickup = 0;
																							aEarlydropoff = 0;
																						}
																						else{
																							if (pReturn_trip2 == "Y"){
																								aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								/* C[006] */
																								//   if(DEBUG == 1) gse << "here5 " << endl;
																							}
																							else{
																								aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								//   if(DEBUG == 1) gse << "here4 " << endl;
																							}
																						}


																						string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																						string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																						string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																						set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																								p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																								a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																						int p_perf_time3;
																						pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																						set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																						if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																							if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																								nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																							}
																							else{
																								nextstoptime = nextstoptime+p_perf_time2;
																							}
																						}
																						else{
																							if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																								nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																							}
																							else{
																								nextstoptime = nextstoptime+p_perf_time2;
																							}
																						}

																						int p_eta;
																						if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																							p_eta = previouseta;
																						}
																						else{
																							p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																						}

																						nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																						if (pDisability3.find("LP",0) != string::npos){
																							aEarlypickup = 0;
																							aEarlydropoff = 0;
																						}
																						else{
																							if (pReturn_trip3 == "Y"){
																								aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								/* C[006] */
																								//   if(DEBUG == 1) gse << "here5 " << endl;
																							}
																							else{
																								aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								//   if(DEBUG == 1) gse << "here4 " << endl;
																							}
																						}
																						int aLatepickup;
																						if (pDisability3.find("OT",0) != string::npos)
																						{
																							if (pReturn_trip3 == "Y"){
																								aLatepickup = p_OTHERLATEPICKFACTOR1;
																							}
																							else{

																								aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																							}
																						}
																						else if (pDisability3.find("LP",0) != string::npos){
																							aLatepickup = 0;
																						}
																						else{
																							if (pReturn_trip3 == "Y"){
																								aLatepickup = p_OTHERLATEPICKFACTOR1;
																							}
																							else{
																								aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																							}
																						}
																						bool preassigntripchange = true;

																						int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																						int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																						if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																							endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																						}
																						string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																						if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																							preassigntripchange = false;
																							if ((p_stop_type == "P") && starttime1 != 0  ) {
																								if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																								{
																									int dev =  p_eta - (starttime1 + aLatepickup);
																									if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																										preassigntripchange = true;
																									}

																								}
																							}


																							if ((p_stop_type == "D") && (endtime1) != 0)
																							{
																								if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																								{
																									int dev =  p_eta - (endtime1);
																									if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																										preassigntripchange = true;
																									}
																								}
																							}
																						}


																						if(preassigntripchange){
																							if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																									isLate = true;
																									break;
																								}

																								// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																								//break;
																								//}
																							}
																							else{

																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																									isLate = true;
																									break;
																								}
																								else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																									if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																										isLate = true;
																										break;}
																								}
																								// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																									//  break;
																									//}

																							}
																						}else{
																							if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																						}
																						w++; previouseta = p_eta;
																					}

																					if(isLate){
																						break;
																					}



																					/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																					if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																					if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																					tripidxes[tripidxcnt] = tripidx;
																					deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																					tripidxcnt++;
																					foundmatch = true;                                                                                                                                   break;

																				}

																			}
																			else{

																				if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																					int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																					int doeta1 = trav_time;
																					int actualTT = doeta1 - puetd1;
																					if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																					string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																					string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																					double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																					string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																					string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																					//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																					int groupcnter = 1;
																					routeint = (int)to_number(a_route.substr(1, a_route.length()));
																					//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																					for (int i = 0; i < MAXSEGMENTS; i++)
																					{
																						if (s_tab[i][0] == routeint)
																						{
																							for (int g = 1; g < MAXSTOPS; g++)
																							{
																								if (s_tab[i][g] == s_tab[m][k-1])
																								{

																									while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																										groupcnter++;
																										g--;
																									}
																									//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																									break;
																								}
																							}
																							break;
																						}
																					}
																					groupcnter = groupcnter + groupnumber;
																					int aAllowedTT;

																					if(estdisttrip < a_mediumshortdistance1)
																						aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																						aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else
																						aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																					if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																						aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																					}


																					if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																						//
																						if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																						if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																						break; ////to ensure that the insertion will not make the stop before which I insert late.

																					}


																				}
																				int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																				int segend;
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[m][g] == 0)
																					{
																						segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																						break;

																					}
																				}
																				int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																				int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																				timethreshold = segend - timethreshold;
																				bool docalc = true;

																				if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																						|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																				){


																					double threshold;

																					if(inslack == "Y"){
																						threshold = 999;
																					}
																					else{
																						threshold = EXTRASLACK[0];
																					}

																					double pudev;
																					double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}


																					docalc = false;

																					if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																						double distpu =  getCost(tripidx, s_tab[m][k]);
																						double distdo = getCost(tripidx+1, s_tab[m][k]);
																						if(isSameLocation(tripidx+1,s_tab[m][k])){
																							distdo = 0;
																						}
																						double cost = getCost(tripidx, s_tab[m][k-1]);

																						if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																							distpu = 0;
																							if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																								if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																								//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																									distdo = 0;
																								}
																							}

																							if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																								if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}
																							else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																								if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}

																					}else{

																						double distdo = getCost(tripidx+1, s_tab[m][k]);

																						if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																							if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																								pudev = getCost(pickupafterstop,puid);
																								dodev = getCost(doid,  dropoffafterstop);
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																								dodev = pudev;

																							}
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid);
																							dodev = 0;
																						}

																						if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																							if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																							docalc = true;

																						}
																					}

																					if(!docalc){
																						break;
																					}
																				}

																				bool isLate = false;
																				int w = k;
																				int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																				while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																					string pDisability2 = schd_tab[s_tab[m][w]][12];
																					string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																					string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																					int p_perf_time2;
																					string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																					if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																					if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																						AGRPCOUNTER = AGRPCOUNTER + 1;
																					else{
																						if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																						{
																							APRVGRPCOUNTER = AGRPCOUNTER + 1;
																						}
																						AGRPCOUNTER = 0;
																					}


																					if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																							if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}


																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																					else{

																						if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																							}

																							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																								APRVGRPCOUNTER = 0;
																							}
																						}
																					}

																					}
																					int aEarlypickup;
																					int aEarlydropoff;
																					int t1;

																					if (pDisability2.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip2 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}


																					string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																					string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																					string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																					int p_perf_time3;
																					pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																					if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																						if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}
																					else{
																						if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}

																					int p_eta;
																					if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																						p_eta = previouseta;
																					}
																					else{
																						p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																					}

																					nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																					if (pDisability3.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}
																					int aLatepickup;
																					if (pDisability3.find("OT",0) != string::npos)
																					{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{

																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}
																					else if (pDisability3.find("LP",0) != string::npos){
																						aLatepickup = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{
																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}
																					bool preassigntripchange = true;

																					int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																					int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																					if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																					}
																					string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																					if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																						preassigntripchange = false;
																						if ((p_stop_type == "P") && starttime1 != 0  ) {
																							if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																							{
																								int dev =  p_eta - (starttime1 + aLatepickup);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}

																							}
																						}


																						if ((p_stop_type == "D") && (endtime1) != 0)
																						{
																							if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																							{
																								int dev =  p_eta - (endtime1);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}
																							}
																						}
																					}


																					if(preassigntripchange){
																						if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																								isLate = true;
																								break;
																							}

																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																							//break;
																							//}
																						}
																						else{

																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																								isLate = true;
																								break;
																							}
																							else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																									isLate = true;
																									break;}
																							}
																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																								//  break;
																								//}

																						}
																					}else{
																						if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																					}
																					w++; previouseta = p_eta;
																				}

																				if(isLate){
																					break;
																				}



																				/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																				if(DEBUG == 1) gse << "No end time " << endl;

																				if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																				tripidxes[tripidxcnt] = tripidx;
																				deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																				tripidxcnt++;
																				foundmatch = true;
																				break;
																			}
																		}
																		else if(tripstarttime == 0) {
																			if(DEBUG == 1) gse << "no start time " << endl;

																			if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																				trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																			}
																			else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																				trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																			}
																			else{
																				trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																			}

																			if (to_number(schd_tab[tripidx][27]) > 0)
																			{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																			if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																			{
																				break;
																			}

																			}

																			if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																				trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																			}
																			else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																				trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																			}

																			if((int)to_number(endtime1)!= 0)
																				est_time = (int)to_number(endtime1);
																			else{
																				est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																			}
																			trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																			if(endofsegtime > 0  ){

																				if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																					if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																						int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																						int doeta1 = trav_time;
																						int actualTT = doeta1 - puetd1;
																						if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																						string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																						string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																						double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																						string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																						string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																						//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																						set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																								p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																								a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																						int groupcnter = 1;
																						routeint = (int)to_number(a_route.substr(1, a_route.length()));
																						//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																						for (int i = 0; i < MAXSEGMENTS; i++)
																						{
																							if (s_tab[i][0] == routeint)
																							{
																								for (int g = 1; g < MAXSTOPS; g++)
																								{
																									if (s_tab[i][g] == s_tab[m][k-1])
																									{

																										while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																											groupcnter++;
																											g--;
																										}
																										//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																										break;
																									}
																								}
																								break;
																							}
																						}
																						groupcnter = groupcnter + groupnumber;
																						int aAllowedTT;

																						if(estdisttrip < a_mediumshortdistance1)
																							aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																						else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																							aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																						else
																							aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																						if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																							aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																						}


																						if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																							//
																							if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																							if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																							break; ////to ensure that the insertion will not make the stop before which I insert late.

																						}


																					}
																					int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																					int segend;
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[m][g] == 0)
																						{
																							segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																							break;

																						}
																					}
																					int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																					int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																					timethreshold = segend - timethreshold;
																					bool docalc = true;

																					if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																							|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																					){

																						double threshold;

																						if(inslack == "Y"){
																							threshold = 999;
																						}
																						else{
																							threshold = EXTRASLACK[0];
																						}


																						double pudev;
																						double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																						if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																							if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																								pudev = getCost(pickupafterstop,puid);
																								dodev = getCost(doid,  dropoffafterstop);
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																								dodev = pudev;

																							}
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid);
																							dodev = 0;
																						}


																						docalc = false;

																						if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																							double distpu =  getCost(tripidx, s_tab[m][k]);
																							double distdo = getCost(tripidx+1, s_tab[m][k]);
																							if(isSameLocation(tripidx+1,s_tab[m][k])){
																								distdo = 0;
																							}
																							double cost = getCost(tripidx, s_tab[m][k-1]);

																							if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																								if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																								distpu = 0;
																								if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																									if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																									//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																										distdo = 0;
																									}
																								}

																								if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																									if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																									docalc = true;
																								}
																								else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																									if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																									docalc = true;
																								}

																						}else{

																							double distdo = getCost(tripidx+1, s_tab[m][k]);

																							if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																								if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																									pudev = getCost(pickupafterstop,puid);
																									dodev = getCost(doid,  dropoffafterstop);
																								}
																								else{
																									pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																									dodev = pudev;

																								}
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid);
																								dodev = 0;
																							}

																							if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																								if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																								docalc = true;

																							}
																						}

																						if(!docalc){
																							break;
																						}

																					}

																					bool isLate = false;
																					int w = k;
																					int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																					while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																						string pDisability2 = schd_tab[s_tab[m][w]][12];
																						string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																						string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																						set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																								p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																								a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																						int p_perf_time2;
																						string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																						set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																						if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																						if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																							AGRPCOUNTER = AGRPCOUNTER + 1;
																						else{
																							if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																							{
																								APRVGRPCOUNTER = AGRPCOUNTER + 1;
																							}
																							AGRPCOUNTER = 0;
																						}


																						if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																								if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																								p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																							}


																							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																								APRVGRPCOUNTER = 0;
																							}
																						}
																						else{

																							if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																								if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																									p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																								}

																								if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																									p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																									APRVGRPCOUNTER = 0;
																								}
																							}
																						}

																						}
																						int aEarlypickup;
																						int aEarlydropoff;
																						int t1;

																						if (pDisability2.find("LP",0) != string::npos){
																							aEarlypickup = 0;
																							aEarlydropoff = 0;
																						}
																						else{
																							if (pReturn_trip2 == "Y"){
																								aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								/* C[006] */
																								//   if(DEBUG == 1) gse << "here5 " << endl;
																							}
																							else{
																								aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								//   if(DEBUG == 1) gse << "here4 " << endl;
																							}
																						}


																						string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																						string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																						string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																						set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																								p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																								a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																						int p_perf_time3;
																						pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																						set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																						if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																							if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																								nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																							}
																							else{
																								nextstoptime = nextstoptime+p_perf_time2;
																							}
																						}
																						else{
																							if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																								nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																							}
																							else{
																								nextstoptime = nextstoptime+p_perf_time2;
																							}
																						}


																						int p_eta;
																						if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																							p_eta = previouseta;
																						}
																						else{
																							p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																						}

																						nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																						if (pDisability3.find("LP",0) != string::npos){
																							aEarlypickup = 0;
																							aEarlydropoff = 0;
																						}
																						else{
																							if (pReturn_trip3 == "Y"){
																								aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								/* C[006] */
																								//   if(DEBUG == 1) gse << "here5 " << endl;
																							}
																							else{
																								aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																								aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																								//   if(DEBUG == 1) gse << "here4 " << endl;
																							}
																						}
																						int aLatepickup;
																						if (pDisability3.find("OT",0) != string::npos)
																						{
																							if (pReturn_trip3 == "Y"){
																								aLatepickup = p_OTHERLATEPICKFACTOR1;
																							}
																							else{

																								aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																							}
																						}
																						else if (pDisability3.find("LP",0) != string::npos){
																							aLatepickup = 0;
																						}
																						else{
																							if (pReturn_trip3 == "Y"){
																								aLatepickup = p_OTHERLATEPICKFACTOR1;
																							}
																							else{
																								aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																							}
																						}
																						bool preassigntripchange = true;

																						int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																						int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																						if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																							endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																						}
																						string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																						if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																							preassigntripchange = false;
																							if ((p_stop_type == "P") && starttime1 != 0  ) {
																								if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																								{
																									int dev =  p_eta - (starttime1 + aLatepickup);
																									if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																										preassigntripchange = true;
																									}

																								}
																							}


																							if ((p_stop_type == "D") && (endtime1) != 0)
																							{
																								if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																								{
																									int dev =  p_eta - (endtime1);
																									if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																										preassigntripchange = true;
																									}
																								}
																							}
																						}



																						if(preassigntripchange){
																							if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																									isLate = true;
																									break;
																								}

																								// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																								//break;
																								//}
																							}
																							else{

																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																									isLate = true;
																									break;
																								}
																								else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																									if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																										isLate = true;
																										break;}
																								}
																								// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																									//  break;
																									//}

																							}
																						}else{
																							if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																						}
																						w++; previouseta = p_eta;
																					}

																					if(isLate){
																						break;
																					}



																					/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																					if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																					if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																					tripidxes[tripidxcnt] = tripidx;
																					deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																					tripidxcnt++;
																					foundmatch = true;
																					break;


																				}

																			}
																			else{

																				if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																					int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																					int doeta1 = trav_time;
																					int actualTT = doeta1 - puetd1;
																					if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																					string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																					string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																					double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																					string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																					string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																					//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																					int groupcnter = 1;
																					routeint = (int)to_number(a_route.substr(1, a_route.length()));
																					//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																					for (int i = 0; i < MAXSEGMENTS; i++)
																					{
																						if (s_tab[i][0] == routeint)
																						{
																							for (int g = 1; g < MAXSTOPS; g++)
																							{
																								if (s_tab[i][g] == s_tab[m][k-1])
																								{

																									while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																										groupcnter++;
																										g--;
																									}
																									//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																									break;
																								}
																							}
																							break;
																						}
																					}
																					groupcnter = groupcnter + groupnumber;
																					int aAllowedTT;

																					if(estdisttrip < a_mediumshortdistance1)
																						aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																						aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																					else
																						aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																					if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																						aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																					}


																					if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																						//
																						if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																						if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																						break; ////to ensure that the insertion will not make the stop before which I insert late.

																					}


																				}
																				int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																				int segend;
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[m][g] == 0)
																					{
																						segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																						break;

																					}
																				}
																				int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																				int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																				timethreshold = segend - timethreshold;
																				bool docalc = true;

																				if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																						|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																				){

																					double threshold;

																					if(inslack == "Y"){
																						threshold = 999;
																					}
																					else{
																						threshold = EXTRASLACK[0];
																					}


																					double pudev;
																					double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																					if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																						if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																							pudev = getCost(pickupafterstop,puid);
																							dodev = getCost(doid,  dropoffafterstop);
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																							dodev = pudev;

																						}
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid);
																						dodev = 0;
																					}


																					docalc = false;

																					if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																						double distpu =  getCost(tripidx, s_tab[m][k]);
																						double distdo = getCost(tripidx+1, s_tab[m][k]);
																						if(isSameLocation(tripidx+1,s_tab[m][k])){
																							distdo = 0;
																						}
																						double cost = getCost(tripidx, s_tab[m][k-1]);

																						if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																							if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																							distpu = 0;
																							if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																								if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																								//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																									distdo = 0;
																								}
																							}

																							if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																								if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}
																							else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																								if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																								docalc = true;
																							}

																					}else{

																						double distdo = getCost(tripidx+1, s_tab[m][k]);

																						if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																							if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																								pudev = getCost(pickupafterstop,puid);
																								dodev = getCost(doid,  dropoffafterstop);
																							}
																							else{
																								pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																								dodev = pudev;

																							}
																						}
																						else{
																							pudev = getCost(pickupafterstop,puid);
																							dodev = 0;
																						}

																						if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																							if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																							docalc = true;

																						}
																					}

																					if(!docalc){
																						break;
																					}

																				}

																				bool isLate = false;
																				int w = k;
																				int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																				while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																					string pDisability2 = schd_tab[s_tab[m][w]][12];
																					string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																					string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																					int p_perf_time2;
																					string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																					if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																					if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																						AGRPCOUNTER = AGRPCOUNTER + 1;
																					else{
																						if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																						{
																							APRVGRPCOUNTER = AGRPCOUNTER + 1;
																						}
																						AGRPCOUNTER = 0;
																					}


																					if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																							if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																							p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																						}


																						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																							p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																							APRVGRPCOUNTER = 0;
																						}
																					}
																					else{

																						if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																							}

																							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																								p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																								APRVGRPCOUNTER = 0;
																							}
																						}
																					}

																					}
																					int aEarlypickup;
																					int aEarlydropoff;
																					int t1;

																					if (pDisability2.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip2 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}


																					string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																					string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																					string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																					int p_perf_time3;
																					pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																					set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																					if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																						if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}
																					else{
																						if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																							nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																						}
																						else{
																							nextstoptime = nextstoptime+p_perf_time2;
																						}
																					}

																					int p_eta;
																					if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																						p_eta = previouseta;
																					}
																					else{
																						p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																					}

																					nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																					if (pDisability3.find("LP",0) != string::npos){
																						aEarlypickup = 0;
																						aEarlydropoff = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							/* C[006] */
																							//   if(DEBUG == 1) gse << "here5 " << endl;
																						}
																						else{
																							aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																							aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																							//   if(DEBUG == 1) gse << "here4 " << endl;
																						}
																					}
																					int aLatepickup;
																					if (pDisability3.find("OT",0) != string::npos)
																					{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{

																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}
																					else if (pDisability3.find("LP",0) != string::npos){
																						aLatepickup = 0;
																					}
																					else{
																						if (pReturn_trip3 == "Y"){
																							aLatepickup = p_OTHERLATEPICKFACTOR1;
																						}
																						else{
																							aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																						}
																					}
																					bool preassigntripchange = true;

																					int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																					int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																					if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																					}
																					string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																					if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																						preassigntripchange = false;
																						if ((p_stop_type == "P") && starttime1 != 0  ) {
																							if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																							{
																								int dev =  p_eta - (starttime1 + aLatepickup);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}

																							}
																						}


																						if ((p_stop_type == "D") && (endtime1) != 0)
																						{
																							if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																							{
																								int dev =  p_eta - (endtime1);
																								if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																									preassigntripchange = true;
																								}
																							}
																						}
																					}



																					if(preassigntripchange){
																						if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																								isLate = true;
																								break;
																							}

																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																							//break;
																							//}
																						}
																						else{

																							if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																								isLate = true;
																								break;
																							}
																							else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																								if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																									isLate = true;
																									break;}
																							}
																							// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																								//  break;
																								//}

																						}
																					}else{
																						if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																					}
																					w++; previouseta = p_eta;
																				}

																				if(isLate){
																					break;
																				}



																				/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																				if(DEBUG == 1) gse << "No end time " << endl;

																				if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot << " with cluster " << tripcluster << endl;

																				tripidxes[tripidxcnt] = tripidx;
																				deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																				tripidxcnt++;foundmatch = true;
																				break;
																			}
																		}


																	}

																	break;}
															}
															break;}
													}
													if(foundmatch){
														continue;
													}
													//}

													double distpu =  getCost(tripidx, s_tab[m][k-1]);
													double distdo = getCost(tripidx+1, s_tab[m][k]);
													int pickupafterstop = s_tab[m][k-1];
													bool skiproute = false;

													if(distpu <= SLACK_THRESHOLD[0] && strcmp(schd_tab[s_tab[m][k-1]][2], "1")==0 && strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])==0){
														//  if(DEBUG == 1) gse << "analysis " <<  schd_tab[s_tab[m][k-1]][0] << " " << schd_tab[tripidx][3] << " " << schd_tab[tripidx][12] << " " << getCost(tripidx,s_tab[m][k-1]) << endl;
														skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
														if(!skiproute){
															if(DEBUG == 1) gse << "It's an empty segment v2 " << schd_tab[s_tab[m][k]][0] << endl;
															tripidxes[tripidxcnt] = tripidx;
															deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
															tripidxcnt++;continue;
														}
													}
													else if(inslack == "Y" &&  (strcmp(schd_tab[s_tab[m][k-1]][2], "1")!=0  || strcmp(schd_tab[s_tab[m][k]][2], MAXSTOPNUM[0])!=0) && distpu <= SLACK_THRESHOLD[0] && distdo <= SLACK_THRESHOLD[0] ){
														skiproute = skipsegment(tripidx, schd_tab[s_tab[m][k]][0]);
														if(!skiproute){

															if(strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0){
																if(DEBUG == 1) gse << "We are exmaining the first stop so checking distance!"<< endl;
																double distance = getActualDistance(s_tab[m][k-1],tripidx);
																if(distance > maxfirststopdeadhead && ((inslack == "Y" && (strcmp(schd_tab[s_tab[m][k-1]][2],"1")!=0 || strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0))|| (inslack == "E"))){
																	if(DEBUG == 1) gse << "There's too much deadhead in the beginning of the segment" << endl;
																	continue;
																}
															}

															string starttime1 = schd_tab[tripidx][26];
															string endtime1 = schd_tab[tripidx][27];
															int est_time;
															if((int)to_number(starttime1)!= 0){
																est_time = (int)to_number(starttime1);
															}
															else{
																est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
															}
															int trav_time =   (int)to_number(schd_tab[s_tab[m][k-1]][30]) + getTravTime_passedEta(s_tab[m][k-1],tripidx, to_string(est_time),"0");
															int tripstarttime = (int)to_number(schd_tab[tripidx][26]);

															if (trav_time < tripstarttime + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50) && tripstarttime > 0){

																//  if(DEBUG == 1) gse << "trav time  = " << trav_time << " etd " << (int)to_number(schd_tab[s_tab[m][k-1]][30]) << endl;


																if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																	//  if(DEBUG == 1) gse <<" using 1 " << schd_tab[tripidx][26] << endl;
																	trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																	//  if(DEBUG == 1) gse <<" using 2 " << schd_tab[tripidx][4] << endl;
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}
																else{
																	//  if(DEBUG == 1) gse <<" none " << trav_time  << endl;
																	trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}

																if (to_number(schd_tab[tripidx][27]) > 0)
																{if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																{
																	continue;
																}

																}

																if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																	trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																}


																if((int)to_number(endtime1)!= 0)
																	est_time = (int)to_number(endtime1);
																else{
																	est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																}
																trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																if(endofsegtime > 0  ){

																	if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																		if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																			int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																			int doeta1 = trav_time;
																			int actualTT = doeta1 - puetd1;
																			if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																			string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																			string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																			double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																			string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																			string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																			//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																			int groupcnter = 1;
																			routeint = (int)to_number(a_route.substr(1, a_route.length()));
																			//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																			for (int i = 0; i < MAXSEGMENTS; i++)
																			{
																				if (s_tab[i][0] == routeint)
																				{
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[i][g] == s_tab[m][k-1])
																						{

																							while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																								groupcnter++;
																								g--;
																							}
																							//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																							break;
																						}
																					}
																					break;
																				}
																			}
																			groupcnter = groupcnter + groupnumber;
																			int aAllowedTT;

																			if(estdisttrip < a_mediumshortdistance1)
																				aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																				aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else
																				aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																			if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/) {
																				aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																			}

																			if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																				//
																				if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																				if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																				continue; ////to ensure that the insertion will not make the stop before which I insert late.

																			}


																		}
																		int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																		int segend;
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[m][g] == 0)
																			{
																				segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																				break;

																			}
																		}
																		int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																		int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																		timethreshold = segend - timethreshold;
																		bool docalc = true;

																		if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																				|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																		){

																			double threshold;

																			if(inslack == "Y"){
																				threshold = 999;
																			}
																			else{
																				threshold = EXTRASLACK[0];
																			}


																			double pudev;
																			double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}


																			docalc = false;

																			if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																				double distpu =  getCost(tripidx, s_tab[m][k]);
																				double distdo = getCost(tripidx+1, s_tab[m][k]);
																				if(isSameLocation(tripidx+1,s_tab[m][k])){
																					distdo = 0;
																				}
																				double cost = getCost(tripidx, s_tab[m][k-1]);

																				if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																					distpu = 0;
																					if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																						//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																							distdo = 0;
																						}
																					}

																					if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																						if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}
																					else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																						if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}

																			}else{

																				double distdo = getCost(tripidx+1, s_tab[m][k]);

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}

																				if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																					if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																					docalc = true;

																				}
																			}

																			if(!docalc){
																				break;
																			}

																		}

																		bool isLate = false;
																		int w = k;
																		int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																		while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																			string pDisability2 = schd_tab[s_tab[m][w]][12];
																			string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																			string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																			int p_perf_time2;
																			string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																			if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																			if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																				AGRPCOUNTER = AGRPCOUNTER + 1;
																			else{
																				if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																				{
																					APRVGRPCOUNTER = AGRPCOUNTER + 1;
																				}
																				AGRPCOUNTER = 0;
																			}


																			if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																					if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}


																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																			else{

																				if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}

																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																			}

																			}
																			int aEarlypickup;
																			int aEarlydropoff;
																			int t1;

																			if (pDisability2.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip2 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}


																			string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																			string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																			string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																			int p_perf_time3;
																			pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																			if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																				if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}
																			else{
																				if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}
																			int p_eta;
																			if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																				p_eta = previouseta;
																			}
																			else{
																				p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																			}

																			nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																			if (pDisability3.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}
																			int aLatepickup;
																			if (pDisability3.find("OT",0) != string::npos)
																			{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{

																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			else if (pDisability3.find("LP",0) != string::npos){
																				aLatepickup = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{
																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			bool preassigntripchange = true;

																			int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																			int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																			if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																			}
																			string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																			if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																				preassigntripchange = false;
																				if ((p_stop_type == "P") && starttime1 != 0  ) {
																					if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																					{
																						int dev =  p_eta - (starttime1 + aLatepickup);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}

																					}
																				}


																				if ((p_stop_type == "D") && (endtime1) != 0)
																				{
																					if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																					{
																						int dev =  p_eta - (endtime1);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}
																					}
																				}
																			}


																			if(preassigntripchange){
																				if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																						isLate = true;
																						break;
																					}

																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																					//break;
																					//}
																				}
																				else{

																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																						isLate = true;
																						break;
																					}
																					else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							isLate = true;
																							break;}
																					}
																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																						//  break;
																						//}

																				}
																			}else{
																				if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																			}
																			w++; previouseta = p_eta;
																		}

																		if(isLate){
																			continue;
																		}



																		/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/                                                                                        if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

tripidxes[tripidxcnt] = tripidx;
deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
tripidxcnt++;continue;

																	}

																}
																else{

																	if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																		int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																		int doeta1 = trav_time;
																		int actualTT = doeta1 - puetd1;
																		if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																		string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																		string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																		double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																		string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																		string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																		//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																		int groupcnter = 1;
																		routeint = (int)to_number(a_route.substr(1, a_route.length()));
																		//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																		for (int i = 0; i < MAXSEGMENTS; i++)
																		{
																			if (s_tab[i][0] == routeint)
																			{
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[i][g] == s_tab[m][k-1])
																					{

																						while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																							groupcnter++;
																							g--;
																						}
																						//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																						break;
																					}
																				}
																				break;
																			}
																		}
																		groupcnter = groupcnter + groupnumber;
																		int aAllowedTT;

																		if(estdisttrip < a_mediumshortdistance1)
																			aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																			aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else
																			aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																		}


																		if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																			//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																			//
																			if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																			if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																			continue; ////to ensure that the insertion will not make the stop before which I insert late.

																		}


																	}
																	int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																	int segend;
																	for (int g = 1; g < MAXSTOPS; g++)
																	{
																		if (s_tab[m][g] == 0)
																		{
																			segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																			break;

																		}
																	}
																	int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																	int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																	timethreshold = segend - timethreshold;
																	bool docalc = true;

																	if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																			|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																	){

																		double threshold;

																		if(inslack == "Y"){
																			threshold = 999;
																		}
																		else{
																			threshold = EXTRASLACK[0];
																		}


																		double pudev;
																		double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																		if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																			if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																				pudev = getCost(pickupafterstop,puid);
																				dodev = getCost(doid,  dropoffafterstop);
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																				dodev = pudev;

																			}
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid);
																			dodev = 0;
																		}


																		docalc = false;

																		if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																			double distpu =  getCost(tripidx, s_tab[m][k]);
																			double distdo = getCost(tripidx+1, s_tab[m][k]);
																			if(isSameLocation(tripidx+1,s_tab[m][k])){
																				distdo = 0;
																			}
																			double cost = getCost(tripidx, s_tab[m][k-1]);

																			if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																				if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																				distpu = 0;
																				if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																					//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																						distdo = 0;
																					}
																				}

																				if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																					if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}
																				else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																					if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}

																		}else{

																			double distdo = getCost(tripidx+1, s_tab[m][k]);

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}

																			if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																				if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																				docalc = true;

																			}
																		}

																		if(!docalc){
																			break;
																		}

																	}

																	bool isLate = false;
																	int w = k;
																	int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																	while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																		string pDisability2 = schd_tab[s_tab[m][w]][12];
																		string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																		string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																		int p_perf_time2;
																		string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																		set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																		if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																		if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																			AGRPCOUNTER = AGRPCOUNTER + 1;
																		else{
																			if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																			{
																				APRVGRPCOUNTER = AGRPCOUNTER + 1;
																			}
																			AGRPCOUNTER = 0;
																		}


																		if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																			if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																				if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																				p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																			}


																			if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																				APRVGRPCOUNTER = 0;
																			}
																		}
																		else{

																			if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}

																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																		}

																		}
																		int aEarlypickup;
																		int aEarlydropoff;
																		int t1;

																		if (pDisability2.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip2 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}


																		string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																		string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																		string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																		int p_perf_time3;
																		pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																		set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																		if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																			if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}
																		else{
																			if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}

																		int p_eta;
																		if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																			p_eta = previouseta;
																		}
																		else{
																			p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																		}

																		nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																		if (pDisability3.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}
																		int aLatepickup;
																		if (pDisability3.find("OT",0) != string::npos)
																		{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{

																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}
																		else if (pDisability3.find("LP",0) != string::npos){
																			aLatepickup = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{
																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}
																		bool preassigntripchange = true;

																		int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																		int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																		if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																			endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																		}
																		string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																		if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																			preassigntripchange = false;
																			if ((p_stop_type == "P") && starttime1 != 0  ) {
																				if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																				{
																					int dev =  p_eta - (starttime1 + aLatepickup);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}

																				}
																			}


																			if ((p_stop_type == "D") && (endtime1) != 0)
																			{
																				if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																				{
																					int dev =  p_eta - (endtime1);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}
																				}
																			}
																		}

																		if(preassigntripchange){
																			if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){

																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																					isLate = true;
																					break;
																				}

																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																				//break;
																				//}
																			}
																			else{

																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																					isLate = true;
																					break;
																				}
																				else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						isLate = true;
																						break;}
																				}
																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																					//  break;
																					//}

																			}
																		}else{
																			if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																		}
																		w++; previouseta = p_eta;
																	}

																	if(isLate){
																		continue;
																	}



																	/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																	if(DEBUG == 1) gse << "No end time " << endl;

																	if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

																	tripidxes[tripidxcnt] = tripidx;
																	deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																	tripidxcnt++;continue;
																}
															}
															else if(tripstarttime == 0) {
																if(DEBUG == 1) gse << "no start time " << endl;
																if(trav_time < to_number(schd_tab[tripidx][26])  - aEarlypickup && to_number(schd_tab[tripidx][26])!= 0 ){
																	trav_time = to_number(schd_tab[tripidx][26]) - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0"); // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlypickup && to_number(schd_tab[tripidx][26])== 0 ){
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlypickup + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}
																else{
																	trav_time =  trav_time + extraperftime + p_perf_time + getTravTime_passedEta(tripidx, tripidx+1, to_string(est_time),"0");// (int)to_number(schd_tab[tripidx][22]);
																}

																if (to_number(schd_tab[tripidx][27]) > 0)
																{
																	if(DEBUG == 1) gse << "End time of trip " << to_number(schd_tab[tripidx][27])  << " trav time " << trav_time << endl;
																	if (trav_time > to_number(schd_tab[tripidx][27]) + floor((RELAXCONSTRAINTS[0] - 1)*50) )
																	{
																		continue;
																	}

																}


																if(trav_time < to_number(schd_tab[tripidx][27])  - aEarlydropoff && to_number(schd_tab[tripidx][27])!= 0 ){
																	trav_time = to_number(schd_tab[tripidx][27]) - aEarlydropoff + p_perf_time; // + (int)to_number(schd_tab[tripidx][22]);
																}
																else if(trav_time < to_number(schd_tab[tripidx][4]) - aEarlydropoff  && to_number(schd_tab[tripidx][27])== 0 ){
																	trav_time =  to_number(schd_tab[tripidx][4])  - aEarlydropoff + p_perf_time;// (int)to_number(schd_tab[tripidx][22]);
																}

																if((int)to_number(endtime1)!= 0)
																	est_time = (int)to_number(endtime1);
																else{
																	est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
																}
																trav_time = trav_time + getTravTime_passedEta(tripidx+1, s_tab[m][k], to_string(est_time),"0") + p_perf_time;

																if(endofsegtime > 0  ){

																	if(trav_time <= endofsegtime + floor((RELAXCONSTRAINTS[0] - 1)*50)){

																		if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																			int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																			int doeta1 = trav_time;
																			int actualTT = doeta1 - puetd1;
																			if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																			string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																			string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																			double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																			string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																			string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																			//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																			int groupcnter = 1;
																			routeint = (int)to_number(a_route.substr(1, a_route.length()));
																			//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																			for (int i = 0; i < MAXSEGMENTS; i++)
																			{
																				if (s_tab[i][0] == routeint)
																				{
																					for (int g = 1; g < MAXSTOPS; g++)
																					{
																						if (s_tab[i][g] == s_tab[m][k-1])
																						{

																							while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																								groupcnter++;
																								g--;
																							}
																							//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																							break;
																						}
																					}
																					break;
																				}
																			}
																			groupcnter = groupcnter + groupnumber;
																			int aAllowedTT;

																			if(estdisttrip < a_mediumshortdistance1)
																				aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																				aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																			else
																				aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																			if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																				aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																			}



																			if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																				//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																				//
																				if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																				if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																				continue; ////to ensure that the insertion will not make the stop before which I insert late.

																			}


																		}
																		int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																		int segend;
																		for (int g = 1; g < MAXSTOPS; g++)
																		{
																			if (s_tab[m][g] == 0)
																			{
																				segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																				break;

																			}
																		}
																		int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																		int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																		timethreshold = segend - timethreshold;
																		bool docalc = true;

																		if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																				|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																		){

																			double threshold;

																			if(inslack == "Y"){
																				threshold = 999;
																			}
																			else{
																				threshold = EXTRASLACK[0];
																			}


																			double pudev;
																			double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}


																			docalc = false;

																			if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																				double distpu =  getCost(tripidx, s_tab[m][k]);
																				double distdo = getCost(tripidx+1, s_tab[m][k]);
																				if(isSameLocation(tripidx+1,s_tab[m][k])){
																					distdo = 0;
																				}
																				double cost = getCost(tripidx, s_tab[m][k-1]);

																				if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																					distpu = 0;
																					if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																						if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																						//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																							distdo = 0;
																						}
																					}

																					if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																						if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}
																					else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																						if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																						docalc = true;
																					}

																			}else{

																				double distdo = getCost(tripidx+1, s_tab[m][k]);

																				if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																					if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																						pudev = getCost(pickupafterstop,puid);
																						dodev = getCost(doid,  dropoffafterstop);
																					}
																					else{
																						pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																						dodev = pudev;

																					}
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid);
																					dodev = 0;
																				}

																				if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																					if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																					docalc = true;

																				}
																			}

																			if(!docalc){
																				break;
																			}

																		}


																		bool isLate = false;
																		int w = k;
																		int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																		while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																			string pDisability2 = schd_tab[s_tab[m][w]][12];
																			string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																			string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																			int p_perf_time2;
																			string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);

																			if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);
																			if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																				AGRPCOUNTER = AGRPCOUNTER + 1;
																			else{
																				if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																				{
																					APRVGRPCOUNTER = AGRPCOUNTER + 1;
																				}
																				AGRPCOUNTER = 0;
																			}


																			if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																					if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}


																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																			else{

																				if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																					if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																					}

																					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																						p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																						APRVGRPCOUNTER = 0;
																					}
																				}
																			}

																			}
																			int aEarlypickup;
																			int aEarlydropoff;
																			int t1;

																			if (pDisability2.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip2 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}


																			string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																			string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																			string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																			int p_perf_time3;
																			pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																			set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																			if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																				if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}
																			else{
																				if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																					nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																				}
																				else{
																					nextstoptime = nextstoptime+p_perf_time2;
																				}
																			}

																			int p_eta;
																			if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																				p_eta = previouseta;
																			}
																			else{
																				p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																			}

																			nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																			if (pDisability3.find("LP",0) != string::npos){
																				aEarlypickup = 0;
																				aEarlydropoff = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					/* C[006] */
																					//   if(DEBUG == 1) gse << "here5 " << endl;
																				}
																				else{
																					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																					//   if(DEBUG == 1) gse << "here4 " << endl;
																				}
																			}
																			int aLatepickup;
																			if (pDisability3.find("OT",0) != string::npos)
																			{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{

																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			else if (pDisability3.find("LP",0) != string::npos){
																				aLatepickup = 0;
																			}
																			else{
																				if (pReturn_trip3 == "Y"){
																					aLatepickup = p_OTHERLATEPICKFACTOR1;
																				}
																				else{
																					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																				}
																			}
																			bool preassigntripchange = true;

																			int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																			int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																			if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																				endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																			}
																			string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																			if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																				preassigntripchange = false;
																				if ((p_stop_type == "P") && starttime1 != 0  ) {
																					if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																					{
																						int dev =  p_eta - (starttime1 + aLatepickup);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}

																					}
																				}


																				if ((p_stop_type == "D") && (endtime1) != 0)
																				{
																					if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																					{
																						int dev =  p_eta - (endtime1);
																						if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																							preassigntripchange = true;
																						}
																					}
																				}
																			}


																			if(preassigntripchange){
																				if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																						isLate = true;
																						break;
																					}

																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																					//break;
																					//}
																				}
																				else{

																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																						isLate = true;
																						break;
																					}
																					else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																						if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																							isLate = true;
																							break;}
																					}
																					// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																						//  break;
																						//}

																				}
																			}else{
																				if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																			}
																			w++; previouseta = p_eta;
																		}

																		if(isLate){
																			continue;
																		}



																		/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																		if(DEBUG == 1) gse << "end time " << endofsegtime << " " << trav_time << endl;
																		if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

																		tripidxes[tripidxcnt] = tripidx;
																		deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																		tripidxcnt++;continue;

																	}

																}
																else{

																	if(strcmp(schd_tab[s_tab[m][k]][7],"D")==0  /*&& strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*//*&& strcmp(schd_tab[pickupafterstop][7],"P")==0 && strcmp(schd_tab[pickupafterstop][3],schd_tab[do_aftershmid][3])==0*/ && strcmp(schd_tab[s_tab[m][k]][3],schd_tab[s_tab[m][k]][0])!=0){



																		int puetd1 = (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][30]);
																		int doeta1 = trav_time;
																		int actualTT = doeta1 - puetd1;
																		if(DEBUG == 1) gse << "estimated travel time " << schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][3] << " " << actualTT << endl;


																		string p_disability = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][12];
																		string p_trip_type = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][8];
																		double estdisttrip = to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][21]);
																		string est_traveltime1 = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][22];
																		string p_returntrip = schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][18];



																		//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " << a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;

																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, p_returntrip,  p_disability, p_trip_type);
																		int groupcnter = 1;
																		routeint = (int)to_number(a_route.substr(1, a_route.length()));
																		//    if(DEBUG == 1) gse << a_route << " " << routeint << endl;
																		for (int i = 0; i < MAXSEGMENTS; i++)
																		{
																			if (s_tab[i][0] == routeint)
																			{
																				for (int g = 1; g < MAXSTOPS; g++)
																				{
																					if (s_tab[i][g] == s_tab[m][k-1])
																					{

																						while(g >=2 && strcmp(schd_tab[s_tab[i][g]][7],"P")==0 && strcmp(schd_tab[s_tab[i][g]][3],schd_tab[s_tab[i][g]][0])!=0 ){
																							groupcnter++;
																							g--;
																						}
																						//   if(DEBUG == 1) gse << " Pick up after stop " << schd_tab[pickupafterstop][31] << " " << schd_tab[pickupafterstop][3] << " " << schd_tab[pickupafterstop][2] << endl;
																						break;
																					}
																				}
																				break;
																			}
																		}
																		groupcnter = groupcnter + groupnumber;
																		int aAllowedTT;

																		if(estdisttrip < a_mediumshortdistance1)
																			aAllowedTT = a_shorttriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
																			aAllowedTT = a_mediumtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);
																		else
																			aAllowedTT = a_longtriptime1 + EXTRAGRPTT[0]* (groupcnter-1);

																		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
																			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
																		}


																		if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
																			//string dopromtime = to_string(to_number(schd_tab[do_aftershmid][26]));
																			//
																			if(DEBUG == 1) gse << "The trip is inserted between a P and D and will make the surrounding trip have a travel time violation "<< endl;
																			if(DEBUG == 1) gse << "travel time " << actualTT << " puetd " <<   puetd1<< " doeta " << doeta1 << " est trip dist " << estdisttrip << " allowed TT " <<  aAllowedTT << endl;
																			continue; ////to ensure that the insertion will not make the stop before which I insert late.

																		}


																	}
																	int segstart = (int)to_number(schd_tab[s_tab[m][1]][4]);
																	int segend;
																	for (int g = 1; g < MAXSTOPS; g++)
																	{
																		if (s_tab[m][g] == 0)
																		{
																			segend = (int)to_number(schd_tab[s_tab[m][g-1]][4]);

																			break;

																		}
																	}
																	int timethreshold = (segend - segstart)*HEADHOMETHRESHOLD[0];
																	int triptimethreshold = ((int)to_number(schd_tab[tripidx][4]));
																	timethreshold = segend - timethreshold;
																	bool docalc = true;

																	if(((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 )
																			|| ((/*timethreshold > actualslack ||*/ triptimethreshold > timethreshold)  && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0)
																	){

																		double threshold;

																		if(inslack == "Y"){
																			threshold = 999;
																		}
																		else{
																			threshold = EXTRASLACK[0];
																		}


																		double pudev;
																		double dodev; int pickupafterstop = s_tab[m][k-1]; int dropoffafterstop = s_tab[m][k]; int puid = tripidx; int doid = tripidx+1;

																		if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																			if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																				pudev = getCost(pickupafterstop,puid);
																				dodev = getCost(doid,  dropoffafterstop);
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																				dodev = pudev;

																			}
																		}
																		else{
																			pudev = getCost(pickupafterstop,puid);
																			dodev = 0;
																		}


																		docalc = false;

																		if((int)to_number(schd_tab[s_tab[m][k-1]][31]) != 0 ||  (int)to_number(schd_tab[s_tab[m][k-1]][32])!= 0 ){
																			double distpu =  getCost(tripidx, s_tab[m][k]);
																			double distdo = getCost(tripidx+1, s_tab[m][k]);
																			if(isSameLocation(tripidx+1,s_tab[m][k])){
																				distdo = 0;
																			}
																			double cost = getCost(tripidx, s_tab[m][k-1]);

																			if(cost <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || cost<= maxdeviationfromstop_slack){
																				if(DEBUG == 1) gse << "There's an allowed deadhead here 2 " << endl;
																				distpu = 0;
																				if(distdo <= to_number(schd_tab[s_tab[m][k-1]][6])*outsideofellipsevar || distdo<= maxdeviationfromstop_slack){
																					if(DEBUG == 1) gse << "There's an allowed deadhead for the dropoff too" << endl;
																					//if(strcmp(schd_tab[pickupafterstop][2],"1")==0 && strcmp(schd_tab[dropoffafterstop][7],"D")==0 && strcmp(schd_tab[dropoffafterstop][2],MAXSTOPNUM[0])==0){
																						distdo = 0;
																					}
																				}

																				if(/*distpu == 0 && distdo == 0*/strcmp(schd_tab[s_tab[m][k-1]][2],"1")==0 && strcmp(schd_tab[s_tab[m][k]][7],"D")==0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
																					if(DEBUG == 1) gse << "We are within the ellipse because it is an empty segment " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}
																				else if (to_number(schd_tab[s_tab[m][k-1]][6]) > 0.0 &&   pudev <= threshold && dodev <= threshold  && (distpu/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0]  && (distdo/to_number(schd_tab[s_tab[m][k-1]][6])) <= MAXDEADHEADVARIANCE[0] ){
																					if(DEBUG == 1) gse << "We are within the ellipse  " << distpu << " " << distdo << " " <<  schd_tab[s_tab[m][k-1]][6] << endl;
																					docalc = true;
																				}

																		}else{

																			double distdo = getCost(tripidx+1, s_tab[m][k]);

																			if(!isSameLocation(pickupafterstop,dropoffafterstop)){
																				if((int)to_number(schd_tab[dropoffafterstop][2])==(int)to_number(MAXSTOPNUM[0])){
																					pudev = getCost(pickupafterstop,puid);
																					dodev = getCost(doid,  dropoffafterstop);
																				}
																				else{
																					pudev = getCost(pickupafterstop,puid) + (int)to_number(schd_tab[puid][21]) + getCost(doid,dropoffafterstop) - to_number(schd_tab[pickupafterstop][6]);
																					dodev = pudev;

																				}
																			}
																			else{
																				pudev = getCost(pickupafterstop,puid);
																				dodev = 0;
																			}

																			if ((distdo/to_number(schd_tab[pickupafterstop][6])) <= MAXDEADHEADVARIANCE[0] &&  pudev <= threshold && dodev <= threshold ){
																				if(DEBUG == 1) gse << "We are heading in the right direction "<<  endl;
																				docalc = true;

																			}
																		}


																		if(!docalc){
																			break;
																		}

																	}

																	bool isLate = false;
																	int w = k;
																	int nextstoptime = trav_time; int previouseta = nextstoptime; int AGRPCOUNTER = 0; int APRVGRPCOUNTER = 0;
																	while(strcmp(schd_tab[s_tab[m][w]][2],MAXSTOPNUM[0])!=0){

																		string pDisability2 = schd_tab[s_tab[m][w]][12];
																		string pReturn_trip2 = schd_tab[s_tab[m][w]][18];
																		string p_trip_type12 = schd_tab[s_tab[m][w]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
																		int p_perf_time2;
																		string pDisposition = schd_tab[s_tab[m][w]][DISPOSITION];
																		set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);



																		if (w != 1 && w+1 != 0) { int timetonextstop2 = (int)to_number(schd_tab[s_tab[m][w-1]][CALCULATEDTIME]);


																		if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)

																			AGRPCOUNTER = AGRPCOUNTER + 1;
																		else{
																			if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0)
																			{
																				APRVGRPCOUNTER = AGRPCOUNTER + 1;
																			}
																			AGRPCOUNTER = 0;
																		}


																		if(pDisability2.find("WC",0) == string::npos && pDisability2.find("SC",0) == string::npos && pDisability2.find("XLT",0) == string::npos){


																			if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0){
																				if(DEBUG == 1) gse << "We are editing perf time " <<endl;
																				p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																			}


																			if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																				p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																				APRVGRPCOUNTER = 0;
																			}
																		}
																		else{

																			if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


																				if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / AGRPCOUNTER;
																				}

																				if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[m][w]][7],schd_tab[s_tab[m][w-1]][7])==0) {

																					p_perf_time2 = p_perf_time2 / APRVGRPCOUNTER;
																					APRVGRPCOUNTER = 0;
																				}
																			}
																		}

																		}
																		int aEarlypickup;
																		int aEarlydropoff;
																		int t1;

																		if (pDisability2.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip2 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}


																		string pDisability3 = schd_tab[s_tab[m][w+1]][12];
																		string pReturn_trip3 = schd_tab[s_tab[m][w+1]][18];
																		string p_trip_type13 = schd_tab[s_tab[m][w+1]][8];
																		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
																				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
																				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
																		int p_perf_time3;
																		pDisposition = schd_tab[s_tab[m][w+1]][DISPOSITION];
																		set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);


																		if(strcmp(schd_tab[s_tab[m][w]][7],"P")==0){
																			if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlypickup + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}
																		else{
																			if(nextstoptime +  p_perf_time2 < (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff){
																				nextstoptime = (int)to_number(schd_tab[s_tab[m][w]][4]) - aEarlydropoff + p_perf_time2;
																			}
																			else{
																				nextstoptime = nextstoptime+p_perf_time2;
																			}
																		}

																		int p_eta;
																		if((int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]) == 0){
																			p_eta = previouseta;
																		}
																		else{
																			p_eta = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);
																		}

																		nextstoptime = nextstoptime + (int)to_number(schd_tab[s_tab[t][w]][CALCULATEDTIME]);


																		if (pDisability3.find("LP",0) != string::npos){
																			aEarlypickup = 0;
																			aEarlydropoff = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aEarlypickup = p_OTHEREARLYPICKFACTOR1;
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				/* C[006] */
																				//   if(DEBUG == 1) gse << "here5 " << endl;
																			}
																			else{
																				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
																				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
																				//   if(DEBUG == 1) gse << "here4 " << endl;
																			}
																		}int aLatepickup;
																		if (pDisability3.find("OT",0) != string::npos)
																		{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{

																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}
																		else if (pDisability3.find("LP",0) != string::npos){
																			aLatepickup = 0;
																		}
																		else{
																			if (pReturn_trip3 == "Y"){
																				aLatepickup = p_OTHERLATEPICKFACTOR1;
																			}
																			else{
																				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
																			}
																		}

																		bool preassigntripchange = true;

																		int starttime1  = (int)to_number(schd_tab[s_tab[m][w+1]][26]);
																		int endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][27]);
																		if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																			endtime1  = (int)to_number(schd_tab[s_tab[m][w+1]][4]);
																		}
																		string p_stop_type = schd_tab[s_tab[m][w+1]][7];


																		if(strcmp(schd_tab[s_tab[m][w+1]][LATEDEVIATION],"")!=0){
																			preassigntripchange = false;
																			if ((p_stop_type == "P") && starttime1 != 0  ) {
																				if( p_eta  > starttime1 + aLatepickup +floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
																				{
																					int dev =  p_eta - (starttime1 + aLatepickup);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}

																				}
																			}


																			if ((p_stop_type == "D") && (endtime1) != 0)
																			{
																				if((p_eta > endtime1 +floor((RELAXCONSTRAINTS[0] - 1)*50)))
																				{
																					int dev =  p_eta - (endtime1);
																					if(dev > (int)to_number(schd_tab[s_tab[m][w+1]][LATEDEVIATION])){
																						preassigntripchange = true;
																					}
																				}
																			}
																		}


																		if(preassigntripchange){
																			if(strcmp(schd_tab[s_tab[m][w+1]][7],"P")==0){


																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+aLatepickup+floor((RELAXCONSTRAINTS[0] - 1)*50) && (int)to_number(schd_tab[s_tab[m][w+1]][26])!=0){
																					isLate = true;
																					break;
																				}

																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlypickup){
																				//break;
																				//}
																			}
																			else{

																				if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50) &&  (int)to_number(schd_tab[s_tab[m][w+1]][27])!=0 && strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])!=0){
																					isLate = true;
																					break;
																				}
																				else if(strcmp(schd_tab[s_tab[m][w+1]][2],MAXSTOPNUM[0])==0){
																					if(p_eta > (int)to_number(schd_tab[s_tab[m][w+1]][4])+floor((RELAXCONSTRAINTS[0] - 1)*50)){
																						isLate = true;
																						break;}
																				}
																				// else if(nextstoptime < (int)to_number(schd_tab[s_tab[m][w+1]][4]) - aEarlydropoff){
																					//  break;
																					//}

																			}
																		}else{
																			if(DEBUG == 1) gse << "It might be late but it is a preassigned trip and the latedeviation has not changed so we don't care. " <<schd_tab[s_tab[m][w+1]][3] << " " <<   schd_tab[s_tab[m][w+1]][7]  << endl;
																		}
																		w++; previouseta = p_eta;
																	}

																	if(isLate){
																		continue;
																	}



																	/*
                                if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])!=0){
                                string pDisability2 = schd_tab[s_tab[m][k]][12];
                                string pReturn_trip2 = schd_tab[s_tab[m][k]][18];
                                string p_trip_type12 = schd_tab[s_tab[m][k]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
     p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
     a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip2,  pDisability2,p_trip_type12);
                                int p_perf_time2;
                                set_p_perf_time(pDisposition,pDisability2,p_perf_time2,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                string pDisability3 = schd_tab[s_tab[m][k+1]][12];
                                string pReturn_trip3 = schd_tab[s_tab[m][k+1]][18];
                                string p_trip_type13 = schd_tab[s_tab[m][k+1]][8];
                                set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
                                p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
                                a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip3,  pDisability3,p_trip_type13);
                                int p_perf_time3;
                                set_p_perf_time(pDisposition,pDisability3,p_perf_time3,p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1);
                                int nextstoptime = trav_time+p_perf_time2+(int)to_number(schd_tab[s_tab[m][k]][CALCULATEDTIME]);


                                if(p_eta > (int)to_number(schd_tab[s_tab[m][k+1]][4])-p_perf_time3){
                                    continue;
                                }

}*/
																	if(DEBUG == 1) gse << "No end time " << endl;

																	if(DEBUG == 1) gse << "Trip " << schd_tab[tripidx][3] << " can go on segment " << schd_tab[s_tab[m][k-1]][0] << " in timeslot " << triptimeslot  << endl;

																	tripidxes[tripidxcnt] = tripidx;
																	deviation[tripidxcnt] = getCost(s_tab[m][k-1],tripidx) + getCost(tripidx,s_tab[m][k]);
																	tripidxcnt++;continue;
																}
															}


														}
													}
												}
											}
										}
									}
								}
							}
							//break;
						}
					}
				}
			}
			break;}
	}

	if( tripidxcnt >  0){
		bubbleSort_twoarray(deviation,tripidxes,tripidxcnt);
		return tripidxes[0];
	}



	//   if(DEBUG == 1) gse << "Couldn't open " << route << endl;
	if(DEBUG == 1) gse << "Nothing fits on " << route << endl;
	return 0;

}
/////////////////////////////searchonetimeslotclustermatch//////////////////////

void buildTree(){

	strcpy(process_tab[ACCESS][0],("RUNNING"));
	strcpy(process_tab[LOADDB][0],("RUNNING"));
	int d = 1;

	for(int m = 0; m < MAXSEGMENTS; m++){

		for(int k = 1; k < MAXSTOPS; k++){

			if(s_tab[m][k]==0)
				break;

			strcpy((schd_tab_unprocess)[d][0] ,schd_tab[s_tab[m][k]][0]);
			strcpy((schd_tab_unprocess[d][1]) , schd_tab[s_tab[m][k]][1]);
			strcpy((schd_tab_unprocess[d][2]) , schd_tab[s_tab[m][k]][2]);
			strcpy((schd_tab_unprocess[d][3]) , schd_tab[s_tab[m][k]][3]);
			strcpy((schd_tab_unprocess[d][4]) , schd_tab[s_tab[m][k]][4]);
			strcpy((schd_tab_unprocess[d][5]) , schd_tab[s_tab[m][k]][5]);
			strcpy((schd_tab_unprocess[d][6]) , schd_tab[s_tab[m][k]][6]);
			strcpy((schd_tab_unprocess[d][7]) , schd_tab[s_tab[m][k]][7]);
			strcpy((schd_tab_unprocess[d][8]) , schd_tab[s_tab[m][k]][8]);
			strcpy((schd_tab_unprocess[d][9]) , schd_tab[s_tab[m][k]][9]);
			strcpy((schd_tab_unprocess[d][10]) , schd_tab[s_tab[m][k]][10]);
			strcpy((schd_tab_unprocess[d][11]) , schd_tab[s_tab[m][k]][11]);
			strcpy((schd_tab_unprocess[d][12]) , schd_tab[s_tab[m][k]][12]);
			strcpy((schd_tab_unprocess[d][13]) , schd_tab[s_tab[m][k]][13]);
			strcpy((schd_tab_unprocess[d][14]) , schd_tab[s_tab[m][k]][14]);
			strcpy((schd_tab_unprocess[d][15]) , schd_tab[s_tab[m][k]][15]);
			strcpy((schd_tab_unprocess[d][16]) , schd_tab[s_tab[m][k]][16]);
			strcpy((schd_tab_unprocess[d][17]) , schd_tab[s_tab[m][k]][17]);
			strcpy((schd_tab_unprocess[d][18]) , schd_tab[s_tab[m][k]][18]);
			strcpy((schd_tab_unprocess[d][19]) , schd_tab[s_tab[m][k]][19]);
			strcpy((schd_tab_unprocess[d][20]) , schd_tab[s_tab[m][k]][20]);
			strcpy((schd_tab_unprocess[d][21]) , schd_tab[s_tab[m][k]][21]);
			strcpy((schd_tab_unprocess[d][22]) , schd_tab[s_tab[m][k]][22]);
			strcpy((schd_tab_unprocess[d][23]) , schd_tab[s_tab[m][k]][23]);
			strcpy((schd_tab_unprocess[d][24]) , schd_tab[s_tab[m][k]][24]);
			strcpy((schd_tab_unprocess[d][25]) , schd_tab[s_tab[m][k]][25]);
			strcpy((schd_tab_unprocess[d][26]) , schd_tab[s_tab[m][k]][26]);
			strcpy((schd_tab_unprocess[d][27]) , schd_tab[s_tab[m][k]][27]);
			strcpy((schd_tab_unprocess[d][28]) , schd_tab[s_tab[m][k]][28]);
			strcpy((schd_tab_unprocess[d][29]) , schd_tab[s_tab[m][k]][29]);
			strcpy((schd_tab_unprocess[d][30]) , schd_tab[s_tab[m][k]][30]);
			strcpy((schd_tab_unprocess[d][31]) , schd_tab[s_tab[m][k]][31]);
			strcpy((schd_tab_unprocess[d][32]) , schd_tab[s_tab[m][k]][32]);
			strcpy((schd_tab_unprocess[d][33]) , schd_tab[s_tab[m][k]][33]);
			strcpy((schd_tab_unprocess[d][34]) , schd_tab[s_tab[m][k]][34]);
			strcpy((schd_tab_unprocess[d][35]) , schd_tab[s_tab[m][k]][35]);
			strcpy((schd_tab_unprocess[d][36]) , schd_tab[s_tab[m][k]][36]);
			strcpy((schd_tab_unprocess[d][37]) , schd_tab[s_tab[m][k]][37]);
			strcpy((schd_tab_unprocess[d][38]) , schd_tab[s_tab[m][k]][38]);
			strcpy((schd_tab_unprocess[d][39]) , schd_tab[s_tab[m][k]][39]);
			strcpy((schd_tab_unprocess[d][41]) , schd_tab[s_tab[m][k]][41]);
			strcpy((schd_tab_unprocess[d][42]) , schd_tab[s_tab[m][k]][42]);
			strcpy((schd_tab_unprocess[d][43]) , "Y"); //Don't want to build the tree, only want to build the cluster table
			strcpy((schd_tab_unprocess[d][44]) ,"Y"); //Don't want to build the tree, only want to build the cluster table
			strcpy((schd_tab_unprocess[d][DIRTYBIT]) , ("N")); // Don't update dirty bit as we only want to build the cluster table
			strcpy((schd_tab_unprocess[d][SUGG_RES_NUM]) , schd_tab[s_tab[m][k]][SUGG_RES_NUM]);
			strcpy((schd_tab_unprocess[d][OPER_ID]) , schd_tab[s_tab[m][k]][OPER_ID]);
			strcpy((schd_tab_unprocess[d][EARLIEST_ARR]) , schd_tab[s_tab[m][k]][EARLIEST_ARR]);
			strcpy((schd_tab_unprocess[d][LATEST_DEP]) , schd_tab[s_tab[m][k]][LATEST_DEP]);
			strcpy((schd_tab_unprocess[d][ORIG_PROMTIME]) , schd_tab[s_tab[m][k]][ORIG_PROMTIME]);
			strcpy((schd_tab_unprocess[d][SITE]) , schd_tab[s_tab[m][k]][SITE]);
			strcpy((schd_tab_unprocess[d][NEIGHBORS]) , schd_tab[s_tab[m][k]][NEIGHBORS]);
			//strcpy((schd_tab_unprocess[d][INCLUDESEG]) , schd_tab[s_tab[m][k]][INCLUDESEG]);
			//strcpy((schd_tab_unprocess[d][EXCLUDESEG]) , schd_tab[s_tab[m][k]][EXCLUDESEG]);
			strcpy((schd_tab_unprocess[d][SKIPTS]) , schd_tab[s_tab[m][k]][SKIPTS]);
			strcpy((schd_tab_unprocess[d][GRPIDX]) , schd_tab[s_tab[m][k]][GRPIDX]);
			strcpy((schd_tab_unprocess[d][PICKUPIDX]) , schd_tab[s_tab[m][k]][PICKUPIDX]);
			strcpy((schd_tab_unprocess[d][DWWAIT]) , schd_tab[s_tab[m][k]][DWWAIT]);
			strcpy((schd_tab_unprocess[d][PWWAIT]) , schd_tab[s_tab[m][k]][PWWAIT]);
			strcpy((schd_tab_unprocess[d][CS_OCC]) , schd_tab[s_tab[m][k]][CS_OCC]);
			strcpy((schd_tab_unprocess[d][BS_OCC]) , schd_tab[s_tab[m][k]][BS_OCC]);
			strcpy((schd_tab_unprocess[d][SEGMENTTYPE]), schd_tab[s_tab[m][k]][SEGMENTTYPE]);
			//strcpy((schd_tab_unprocess[d][DISPOSITION]) , schd_tab[s_tab[m][k]][DISPOSITION]);
			//strcpy((schd_tab_unprocess[d][LATEDEVIATION]) , schd_tab[s_tab[m][k]][LATEDEVIATION]);
			//strcpy((schd_tab_unprocess[d][TRVLTIMEDEVIATION]) , schd_tab[s_tab[m][k]][TRVLTIMEDEVIATION]);
			d++;

		}
	}
	strcpy(process_tab[LOADDB][0],("DONE"));

	if(d == 1){
		strcpy(process_tab[ACCESS][0],("READY"));
	}

	while(true){
		if( strcmp(process_tab[ACCESS][0],("READY"))==0 )
			break;
	}
}

int changedisposition(int * arraytoignore, int numtoignore, string wc, double outsideofellipsevar, double maxdeviationfromstop_slack, string tripids, double maxfirststopdeadhead){
	if(DEBUG == 1) gse << "v2 :Opening more segments with threshold " << OPEN_SEG_THRESHOLD[0] << endl;
	OPEN_SEG_THRESHOLD[0] = 1; //for now since we are using "no threshold" pass in slack we dont want to completely close segments that could be used in this pass
	string segment;
	string arrayofsegments[MAXSEGMENTS];
	int numbertoopen = 0;
	int numberalreadyopen = 0;


	for (int i = 0; i < MAXTIMESLOTS; i++) { ///reset and erase cluster table
		for (int j = 0; j < MAXCLUSTERS; j++) {
			for (int k = 0; k < MAXTC_COLUMNSIZE; k++) {
				ts_tab[i][j][SLACK][k] = 0;
			}
		}
	}


	if(tripids!=""){
		for(int i = 1; i < MAXTRIPIDX; i++){
			if (strcmp(schd_tab[i][10], "") == 0) {
				break;
			}

			if(strcmp(schd_tab[i][DISPOSITION],"T")==0 ){
				strcpy(schd_tab[i][DISPOSITION],"C");
			}

		}
	}

	for(int i = 1; i < MAXTRIPIDX; i++){
		if (strcmp(schd_tab[i][10], "") == 0) {
			break;
		}
		if(strcmp(schd_tab[i][0],"")!=0 && strcmp(schd_tab[i][2],"1")==0 && (strcmp(schd_tab[i][DISPOSITION],"C")==0 || strcmp(schd_tab[i][DISPOSITION],"")==0 )){
			numbertoopen++;
		}
		if(strcmp(schd_tab[i][DISPOSITION],"")==0 ){
			strcpy(schd_tab[i][DISPOSITION],"C");
		}
		if(strcmp(schd_tab[i][0],"")!=0 && strcmp(schd_tab[i][2],"1")==0 && strcmp(schd_tab[i][DISPOSITION],"T")==0 ){
			numberalreadyopen++;
		}
	}

	numbertoopen = round((numbertoopen) * OPEN_SEG_THRESHOLD[0]);
	if(DEBUG == 1) gse << "I want to open : " << numbertoopen << endl;
	if(numbertoopen < 1)
		numbertoopen = 1;

	int routeint;
	string a_route;
	int cnt = 0;
	bool  mightfittrip = false;
	int cantopen = 0;
	int tripcounter = 0;

	if(tripids!= ""){

		string temptrip = tripids;

		while(temptrip!=""){

			string trip = getNextToken(&temptrip,",");
			tripcounter = 0;


			for(int z = 0; z < MAXSEGMENTS; z++){

				if(s_tab[z][0]==0 )
					break;



				if(tripids!="" && tripcounter >= 5){
					break;
				}


				mightfittrip = false;
				if(strcmp(schd_tab[s_tab[z][1]][2],"1")==0 && strcmp(schd_tab[s_tab[z][2]][2],MAXSTOPNUM[0])!=0){ //if this segment has trips on it

					if(numtoignore > 0){
						for(int g = 0; g < numtoignore; g++){

							if(routeint == arraytoignore[g]){
								//   if(DEBUG == 1) gse << "Ignoring " << a_route << " " << i << endl;
								for(int h = 0; h < MAXSEGMENTS; h++){
									if(s_tab[h][0] == routeint){
										//   if(DEBUG == 1) gse << "Turning off this segment " << routeint << endl ;
										for(int d = 1; d < MAXSTOPS; d++){
											if (s_tab[h][d]== 0)
												break;
											strcpy(schd_tab[s_tab[h][d]][DISPOSITION],"C");

										}
										break;
									}
								}
								break;
							}
							else if(routeint != arraytoignore[g] && g+1 ==  numtoignore && cnt < numbertoopen && (strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"")==0)){
								a_route = "S"+to_string(s_tab[z][0]);
								mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,trip,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
								if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
									if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
									cantopen++;
									continue;
								}

								//strcpy(schd_tab[i][DISPOSITION],"T");
								//  if(DEBUG == 1) gse << "Adding " << schd_tab[i][0] << endl;
								for(int p = 0; p <= cnt; p++){
									if(strcmp(schd_tab[s_tab[z][1]][0],arrayofsegments[p].c_str())==0){
										break;
									}
									else if(p == cnt){
										tripcounter++;
										arrayofsegments[cnt] = schd_tab[s_tab[z][1]][0];
										cnt++;
										break;

									}
								}

							}

						}
					}
					else if (numtoignore == 0 && cnt < numbertoopen && (strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"")==0)){
						a_route = "S"+to_string(s_tab[z][0]);
						mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,trip,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
						if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
							if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
							cantopen++;
							continue;
						}
						for(int p = 0; p <= cnt; p++){
							if(strcmp(schd_tab[s_tab[z][1]][0],arrayofsegments[p].c_str())==0){
								break;
							}
							else if(p == cnt){
								tripcounter++;
								arrayofsegments[cnt] = schd_tab[s_tab[z][1]][0];
								cnt++;
								break;

							}
						}
					}

				}
			}



			if(DEBUG == 1) gse << "Doing empty segments " << endl;

			if(numtoignore > 0){
				for(int h = 0; h < MAXSEGMENTS; h++){

					//gse << "Trip counter " << tripcounter << "  " << tripids << endl;

					if(tripids!="" && tripcounter >= 5){
						break;
					}
					if(s_tab[h][0]==0)
						break;

					if(strcmp(schd_tab[s_tab[h][1]][2],"1")==0 && strcmp(schd_tab[s_tab[h][2]][2],MAXSTOPNUM[0])==0 && (strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"")==0)){

						for(int g = 0; g < numtoignore; g++){

							if(s_tab[h][0] == arraytoignore[g])
								break;

							else if(s_tab[h][0] != arraytoignore[g]  && g+1 == numtoignore && cnt < numbertoopen && (strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"")==0)){
								a_route = "S"+to_string(s_tab[h][0]);
								mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,trip,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
								if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
									if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
									cantopen++;
									continue;
								}
								for(int p = 0; p <= cnt; p++){
									if(strcmp(schd_tab[s_tab[h][1]][0],arrayofsegments[p].c_str())==0){
										break;
									}
									else if(p == cnt){
										tripcounter++;
										arrayofsegments[cnt] = schd_tab[s_tab[h][1]][0];
										cnt++;
										break;

									}
								}
							}

						}
					}
				}
			}
			else if (numtoignore == 0 && cnt < numbertoopen){
				for(int h = 0; h < MAXSEGMENTS; h++){

					gse << "Trip counter " << tripcounter << "  " << tripids << endl;

					if(tripids!="" && tripcounter >= 5){
						break;
					}
					if(s_tab[h][0]==0)
						break;
					if(strcmp(schd_tab[s_tab[h][1]][2],"1")==0 && strcmp(schd_tab[s_tab[h][2]][2],MAXSTOPNUM[0])==0 && (strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"")==0)){
						a_route = "S"+to_string(s_tab[h][0]);
						mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,trip,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
						if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
							if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
							cantopen++;
							continue;
						}
						for(int p = 0; p <= cnt; p++){
							if(strcmp(schd_tab[s_tab[h][1]][0],arrayofsegments[p].c_str())==0){
								break;
							}
							else if(p == cnt){
								tripcounter++;
								arrayofsegments[cnt] = schd_tab[s_tab[h][1]][0];
								cnt++;
								break;

							}
						}
					}
				}
			}
		}
	}
	else{

		for(int z = 0; z < MAXSEGMENTS; z++){

			if(tripids!="" && tripcounter >= 5){
				break;
			}


			mightfittrip = false;
			if(strcmp(schd_tab[s_tab[z][1]][2],"1")==0 && strcmp(schd_tab[s_tab[z][2]][2],MAXSTOPNUM[0])!=0){ //if this segment has trips on it

				if(numtoignore > 0){
					for(int g = 0; g < numtoignore; g++){

						if(routeint == arraytoignore[g]){
							//   if(DEBUG == 1) gse << "Ignoring " << a_route << " " << i << endl;
							for(int h = 0; h < MAXSEGMENTS; h++){
								if(s_tab[h][0] == routeint){
									//   if(DEBUG == 1) gse << "Turning off this segment " << routeint << endl ;
									for(int d = 1; d < MAXSTOPS; d++){
										if (s_tab[h][d]== 0)
											break;
										strcpy(schd_tab[s_tab[h][d]][DISPOSITION],"C");

									}
									break;
								}
							}
							break;
						}
						else if(routeint != arraytoignore[g] && g+1 ==  numtoignore &&   cnt < numbertoopen && (strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"")==0)){
							a_route = "S"+to_string(s_tab[z][0]);
							mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,tripids,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
							if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
								if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
								cantopen++;
								continue;
							}
							if(tripids!=""){
								tripcounter++;
							}
							//strcpy(schd_tab[i][DISPOSITION],"T");
							//  if(DEBUG == 1) gse << "Adding " << schd_tab[i][0] << endl;
							arrayofsegments[cnt] = schd_tab[s_tab[z][1]][0];
							cnt++;
						}

					}
				}
				else if (numtoignore == 0 && cnt < numbertoopen && (strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[z][1]][DISPOSITION],"")==0)){
					a_route = "S"+to_string(s_tab[z][0]);
					mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,tripids,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
					if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
						if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
						cantopen++;
						continue;
					}
					if(tripids!=""){
						tripcounter++;
					}
					//strcpy(schd_tab[i][DISPOSITION],"T");
					//  if(DEBUG == 1) gse << "Adding " << schd_tab[i][0] << endl;
					arrayofsegments[cnt] = schd_tab[s_tab[z][1]][0];
					cnt++;
				}

			}
		}



		if(DEBUG == 1) gse << "Doing empty segments " << endl;

		if(numtoignore > 0){
			for(int h = 0; h < MAXSEGMENTS; h++){

				if(tripids!="" && tripcounter >= 5){
					break;
				}
				if(s_tab[h][0]==0)
					break;

				if(strcmp(schd_tab[s_tab[h][1]][2],"1")==0 && strcmp(schd_tab[s_tab[h][2]][2],MAXSTOPNUM[0])==0 && (strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"")==0)){

					for(int g = 0; g < numtoignore; g++){

						if(s_tab[h][0] == arraytoignore[g])
							break;

						else if(s_tab[h][0] != arraytoignore[g]  && g+1 == numtoignore && cnt < numbertoopen){
							a_route = "S"+to_string(s_tab[h][0]);
							mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,tripids,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
							if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
								if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
								cantopen++;
								continue;
							}
							if(tripids!=""){
								tripcounter++;
							}
							// strcpy(schd_tab[i][DISPOSITION],"T");
							//  if(DEBUG == 1) gse << "Adding " << schd_tab[i][0] << endl;
							arrayofsegments[cnt] = schd_tab[s_tab[h][1]][0];
							cnt++;
						}

					}
				}
			}
		}
		else if (numtoignore == 0 && cnt < numbertoopen){
			for(int h = 0; h < MAXSEGMENTS; h++){

				if(tripids!="" && tripcounter >= 5){
					break;
				}
				if(s_tab[h][0]==0)
					break;
				if(strcmp(schd_tab[s_tab[h][1]][2],"1")==0 && strcmp(schd_tab[s_tab[h][2]][2],MAXSTOPNUM[0])==0 && (strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"C")==0  || strcmp(schd_tab[s_tab[h][1]][DISPOSITION],"")==0)){
					a_route = "S"+to_string(s_tab[h][0]);
					mightfittrip =  searchtimeslotclustermatch(a_route,wc,"Y",outsideofellipsevar,maxdeviationfromstop_slack,tripids,maxfirststopdeadhead); // check if we can possibly fit any trips on the route before opening
					if(/*numberalreadyopen > 0 &&*/ !mightfittrip){
						if(DEBUG == 1) gse << "No trips can fit on this segment so we're not opening it: " << a_route << endl;
						cantopen++;
						continue;
					}
					if(tripids!=""){
						tripcounter++;
					}
					//strcpy(schd_tab[i][DISPOSITION],"T");
					//  if(DEBUG == 1) gse << "Adding " << schd_tab[i][0] << endl;
					arrayofsegments[cnt] = schd_tab[s_tab[h][1]][0];
					cnt++;
				}
			}
		}


	}



	for(int i = 1; i < MAXTRIPIDX; i++){
		if (strcmp(schd_tab[i][10], "") == 0) {
			break;
		}
		if(strcmp(schd_tab[i][0],"")!=0){
			for(int t = 0; t < cnt; t++){
				if(strcmp(schd_tab[i][0],arrayofsegments[t].c_str())==0){
					strcpy(schd_tab[i][DISPOSITION],"T");
					break;
				}
				else if(t+1 == cnt && strcmp(schd_tab[i][0],"")!=0){
					strcpy(schd_tab[i][DISPOSITION],"C");
					break;
				}
			}
		}
	}

	strcpy(process_tab[ACCESS][0],("RUNNING"));
	strcpy(process_tab[LOADDB][0],("RUNNING"));
	int d = 1;

	for(int m = 0; m < MAXSEGMENTS; m++){

		for(int k = 1; k < MAXSTOPS; k++){

			if(s_tab[m][k]==0)
				break;

			strcpy((schd_tab_unprocess)[d][0] ,schd_tab[s_tab[m][k]][0]);
			strcpy((schd_tab_unprocess[d][1]) , schd_tab[s_tab[m][k]][1]);
			strcpy((schd_tab_unprocess[d][2]) , schd_tab[s_tab[m][k]][2]);
			strcpy((schd_tab_unprocess[d][3]) , schd_tab[s_tab[m][k]][3]);
			strcpy((schd_tab_unprocess[d][4]) , schd_tab[s_tab[m][k]][4]);
			strcpy((schd_tab_unprocess[d][5]) , schd_tab[s_tab[m][k]][5]);
			strcpy((schd_tab_unprocess[d][6]) , schd_tab[s_tab[m][k]][6]);
			strcpy((schd_tab_unprocess[d][7]) , schd_tab[s_tab[m][k]][7]);
			strcpy((schd_tab_unprocess[d][8]) , schd_tab[s_tab[m][k]][8]);
			strcpy((schd_tab_unprocess[d][9]) , schd_tab[s_tab[m][k]][9]);
			strcpy((schd_tab_unprocess[d][10]) , schd_tab[s_tab[m][k]][10]);
			strcpy((schd_tab_unprocess[d][11]) , schd_tab[s_tab[m][k]][11]);
			strcpy((schd_tab_unprocess[d][12]) , schd_tab[s_tab[m][k]][12]);
			strcpy((schd_tab_unprocess[d][13]) , schd_tab[s_tab[m][k]][13]);
			strcpy((schd_tab_unprocess[d][14]) , schd_tab[s_tab[m][k]][14]);
			strcpy((schd_tab_unprocess[d][15]) , schd_tab[s_tab[m][k]][15]);
			strcpy((schd_tab_unprocess[d][16]) , schd_tab[s_tab[m][k]][16]);
			strcpy((schd_tab_unprocess[d][17]) , schd_tab[s_tab[m][k]][17]);
			strcpy((schd_tab_unprocess[d][18]) , schd_tab[s_tab[m][k]][18]);
			strcpy((schd_tab_unprocess[d][19]) , schd_tab[s_tab[m][k]][19]);
			strcpy((schd_tab_unprocess[d][20]) , schd_tab[s_tab[m][k]][20]);
			strcpy((schd_tab_unprocess[d][21]) , schd_tab[s_tab[m][k]][21]);
			strcpy((schd_tab_unprocess[d][22]) , schd_tab[s_tab[m][k]][22]);
			strcpy((schd_tab_unprocess[d][23]) , schd_tab[s_tab[m][k]][23]);
			strcpy((schd_tab_unprocess[d][24]) , schd_tab[s_tab[m][k]][24]);
			strcpy((schd_tab_unprocess[d][25]) , schd_tab[s_tab[m][k]][25]);
			strcpy((schd_tab_unprocess[d][26]) , schd_tab[s_tab[m][k]][26]);
			strcpy((schd_tab_unprocess[d][27]) , schd_tab[s_tab[m][k]][27]);
			strcpy((schd_tab_unprocess[d][28]) , schd_tab[s_tab[m][k]][28]);
			strcpy((schd_tab_unprocess[d][29]) , schd_tab[s_tab[m][k]][29]);
			strcpy((schd_tab_unprocess[d][30]) , schd_tab[s_tab[m][k]][30]);
			strcpy((schd_tab_unprocess[d][31]) , schd_tab[s_tab[m][k]][31]);
			strcpy((schd_tab_unprocess[d][32]) , schd_tab[s_tab[m][k]][32]);
			strcpy((schd_tab_unprocess[d][33]) , schd_tab[s_tab[m][k]][33]);
			strcpy((schd_tab_unprocess[d][34]) , schd_tab[s_tab[m][k]][34]);
			strcpy((schd_tab_unprocess[d][35]) , schd_tab[s_tab[m][k]][35]);
			strcpy((schd_tab_unprocess[d][36]) , schd_tab[s_tab[m][k]][36]);
			strcpy((schd_tab_unprocess[d][37]) , schd_tab[s_tab[m][k]][37]);
			strcpy((schd_tab_unprocess[d][38]) , schd_tab[s_tab[m][k]][38]);
			strcpy((schd_tab_unprocess[d][39]) , schd_tab[s_tab[m][k]][39]);
			strcpy((schd_tab_unprocess[d][41]) , schd_tab[s_tab[m][k]][41]);
			strcpy((schd_tab_unprocess[d][42]) , schd_tab[s_tab[m][k]][42]);
			strcpy((schd_tab_unprocess[d][43]) , "N"); //Don't want to build the tree, only want to build the cluster table
			strcpy((schd_tab_unprocess[d][44]) ,"N"); //Don't want to build the tree, only want to build the cluster table
			strcpy((schd_tab_unprocess[d][DIRTYBIT]) , ("N")); // Don't update dirty bit as we only want to build the cluster table
			strcpy((schd_tab_unprocess[d][SUGG_RES_NUM]) , schd_tab[s_tab[m][k]][SUGG_RES_NUM]);
			strcpy((schd_tab_unprocess[d][OPER_ID]) , schd_tab[s_tab[m][k]][OPER_ID]);
			strcpy((schd_tab_unprocess[d][EARLIEST_ARR]) , schd_tab[s_tab[m][k]][EARLIEST_ARR]);
			strcpy((schd_tab_unprocess[d][LATEST_DEP]) , schd_tab[s_tab[m][k]][LATEST_DEP]);
			strcpy((schd_tab_unprocess[d][ORIG_PROMTIME]) , schd_tab[s_tab[m][k]][ORIG_PROMTIME]);
			strcpy((schd_tab_unprocess[d][SITE]) , schd_tab[s_tab[m][k]][SITE]);
			strcpy((schd_tab_unprocess[d][NEIGHBORS]) , schd_tab[s_tab[m][k]][NEIGHBORS]);
			//strcpy((schd_tab_unprocess[d][INCLUDESEG]) , schd_tab[s_tab[m][k]][INCLUDESEG]);
			//strcpy((schd_tab_unprocess[d][EXCLUDESEG]) , schd_tab[s_tab[m][k]][EXCLUDESEG]);
			strcpy((schd_tab_unprocess[d][SKIPTS]) , schd_tab[s_tab[m][k]][SKIPTS]);
			strcpy((schd_tab_unprocess[d][GRPIDX]) , schd_tab[s_tab[m][k]][GRPIDX]);
			strcpy((schd_tab_unprocess[d][PICKUPIDX]) , schd_tab[s_tab[m][k]][PICKUPIDX]);
			strcpy((schd_tab_unprocess[d][DWWAIT]) , schd_tab[s_tab[m][k]][DWWAIT]);
			strcpy((schd_tab_unprocess[d][PWWAIT]) , schd_tab[s_tab[m][k]][PWWAIT]);
			strcpy((schd_tab_unprocess[d][CS_OCC]) , schd_tab[s_tab[m][k]][CS_OCC]);
			strcpy((schd_tab_unprocess[d][BS_OCC]) , schd_tab[s_tab[m][k]][BS_OCC]);
			strcpy((schd_tab_unprocess[d][SEGMENTTYPE]), schd_tab[s_tab[m][k]][SEGMENTTYPE]);
			//strcpy((schd_tab_unprocess[d][DISPOSITION]) , schd_tab[s_tab[m][k]][DISPOSITION]);
			//strcpy((schd_tab_unprocess[d][LATEDEVIATION]) , schd_tab[s_tab[m][k]][LATEDEVIATION]);
			//strcpy((schd_tab_unprocess[d][TRVLTIMEDEVIATION]) , schd_tab[s_tab[m][k]][TRVLTIMEDEVIATION]);
			d++;

		}
	}
	strcpy(process_tab[LOADDB][0],("DONE"));

	if(d == 1){
		strcpy(process_tab[ACCESS][0],("READY"));
	}

	while(true){
		if( strcmp(process_tab[ACCESS][0],("READY"))==0 )
			break;
	}


	return cantopen;

}

void passThroughAccess(){

	strcpy(process_tab[ACCESS][0],("RUNNING"));
	strcpy(process_tab[LOADDB][0],("RUNNING"));
	int h;

	for(int d = 1; d < MAXTRIPIDX; d++){

		h = d;

		if(strcmp(schd_tab[d][10],"")==0)
			break;


		strcpy((schd_tab_unprocess)[d][0] ,schd_tab[d][0]);
		strcpy((schd_tab_unprocess[d][1]) , schd_tab[d][1]);
		strcpy((schd_tab_unprocess[d][2]) , schd_tab[d][2]);
		strcpy((schd_tab_unprocess[d][3]) , schd_tab[d][3]);
		strcpy((schd_tab_unprocess[d][4]) , schd_tab[d][4]);
		strcpy((schd_tab_unprocess[d][5]) , schd_tab[d][5]);
		strcpy((schd_tab_unprocess[d][6]) , schd_tab[d][6]);
		strcpy((schd_tab_unprocess[d][7]) , schd_tab[d][7]);
		strcpy((schd_tab_unprocess[d][8]) , schd_tab[d][8]);
		strcpy((schd_tab_unprocess[d][9]) , schd_tab[d][9]);
		strcpy((schd_tab_unprocess[d][10]) , schd_tab[d][10]);
		strcpy((schd_tab_unprocess[d][11]) , schd_tab[d][11]);
		strcpy((schd_tab_unprocess[d][12]) , schd_tab[d][12]);
		strcpy((schd_tab_unprocess[d][13]) , schd_tab[d][13]);
		strcpy((schd_tab_unprocess[d][14]) , schd_tab[d][14]);
		strcpy((schd_tab_unprocess[d][15]) , schd_tab[d][15]);
		strcpy((schd_tab_unprocess[d][16]) , schd_tab[d][16]);
		strcpy((schd_tab_unprocess[d][17]) , schd_tab[d][17]);
		strcpy((schd_tab_unprocess[d][18]) , schd_tab[d][18]);
		strcpy((schd_tab_unprocess[d][19]) , schd_tab[d][19]);
		strcpy((schd_tab_unprocess[d][20]) , schd_tab[d][20]);
		strcpy((schd_tab_unprocess[d][21]) , schd_tab[d][21]);
		strcpy((schd_tab_unprocess[d][22]) , schd_tab[d][22]);
		strcpy((schd_tab_unprocess[d][23]) , schd_tab[d][23]);
		strcpy((schd_tab_unprocess[d][24]) , schd_tab[d][24]);
		strcpy((schd_tab_unprocess[d][25]) , schd_tab[d][25]);
		strcpy((schd_tab_unprocess[d][26]) , schd_tab[d][26]);
		strcpy((schd_tab_unprocess[d][27]) , schd_tab[d][27]);
		strcpy((schd_tab_unprocess[d][28]) , schd_tab[d][28]);
		strcpy((schd_tab_unprocess[d][29]) , schd_tab[d][29]);
		strcpy((schd_tab_unprocess[d][30]) , schd_tab[d][30]);
		strcpy((schd_tab_unprocess[d][31]) , schd_tab[d][31]);
		strcpy((schd_tab_unprocess[d][32]) , schd_tab[d][32]);
		strcpy((schd_tab_unprocess[d][33]) , schd_tab[d][33]);
		strcpy((schd_tab_unprocess[d][34]) , schd_tab[d][34]);
		strcpy((schd_tab_unprocess[d][35]) , schd_tab[d][35]);
		strcpy((schd_tab_unprocess[d][36]) , schd_tab[d][36]);
		strcpy((schd_tab_unprocess[d][37]) , schd_tab[d][37]);
		strcpy((schd_tab_unprocess[d][38]) , schd_tab[d][38]);
		strcpy((schd_tab_unprocess[d][39]) , schd_tab[d][39]);
		strcpy((schd_tab_unprocess[d][41]) , schd_tab[d][41]);
		strcpy((schd_tab_unprocess[d][42]) , schd_tab[d][42]);
		strcpy((schd_tab_unprocess[d][43]) , "N"); //Don't want to build the tree, only want to build the cluster table
		strcpy((schd_tab_unprocess[d][44]) ,"N"); //Don't want to build the tree, only want to build the cluster table
		strcpy((schd_tab_unprocess[d][DIRTYBIT]) , ("N")); // Don't update dirty bit as we only want to build the cluster table
		strcpy((schd_tab_unprocess[d][SUGG_RES_NUM]) , schd_tab[d][SUGG_RES_NUM]);
		strcpy((schd_tab_unprocess[d][OPER_ID]) , schd_tab[d][OPER_ID]);
		strcpy((schd_tab_unprocess[d][EARLIEST_ARR]) , schd_tab[d][EARLIEST_ARR]);
		strcpy((schd_tab_unprocess[d][LATEST_DEP]) , schd_tab[d][LATEST_DEP]);
		strcpy((schd_tab_unprocess[d][ORIG_PROMTIME]) , schd_tab[d][ORIG_PROMTIME]);
		strcpy((schd_tab_unprocess[d][SITE]) , schd_tab[d][SITE]);
		strcpy((schd_tab_unprocess[d][NEIGHBORS]) , schd_tab[d][NEIGHBORS]);
		strcpy((schd_tab_unprocess[d][SKIPTS]) , schd_tab[d][SKIPTS]);
		strcpy((schd_tab_unprocess[d][GRPIDX]) , schd_tab[d][GRPIDX]);
		strcpy((schd_tab_unprocess[d][PICKUPIDX]) , schd_tab[d][PICKUPIDX]);
		strcpy((schd_tab_unprocess[d][DWWAIT]) , schd_tab[d][DWWAIT]);
		strcpy((schd_tab_unprocess[d][PWWAIT]) , schd_tab[d][PWWAIT]);
		strcpy((schd_tab_unprocess[d][CS_OCC]) , schd_tab[d][CS_OCC]);
		strcpy((schd_tab_unprocess[d][BS_OCC]) , schd_tab[d][BS_OCC]);
		strcpy((schd_tab_unprocess[d][SEGMENTTYPE]), schd_tab[d][SEGMENTTYPE]);


	}
	strcpy(process_tab[LOADDB][0],("DONE"));

	if(h == 1){
		strcpy(process_tab[ACCESS][0],("READY"));
	}

	while(true){
		if( strcmp(process_tab[ACCESS][0],("READY"))==0 )
			break;
	}
}

void passSomeThroughAccess(string segments){

	string temp = segments;

	strcpy(process_tab[ACCESS][0],("RUNNING"));
	strcpy(process_tab[LOADDB][0],("RUNNING"));
	int h = 1;
	while(temp!=""){
		string a_route = getNextToken(&temp, ",");
		int routeint = (int)to_number(a_route.substr(1,a_route.length()));
		for(int m = 0; m < MAXSEGMENTS; m++){
			if(s_tab[m][0] == 0)
				break;
			if(s_tab[m][0] == routeint){
				for(int k = 1; k < MAXSTOPS; k++){
					if(s_tab[m][k]==0)
						break;
					strcpy((schd_tab_unprocess)[h][0] ,schd_tab[s_tab[m][k]][0]);
					strcpy((schd_tab_unprocess[h][1]) , schd_tab[s_tab[m][k]][1]);
					strcpy((schd_tab_unprocess[h][2]) , schd_tab[s_tab[m][k]][2]);
					strcpy((schd_tab_unprocess[h][3]) , schd_tab[s_tab[m][k]][3]);
					strcpy((schd_tab_unprocess[h][4]) , schd_tab[s_tab[m][k]][4]);
					strcpy((schd_tab_unprocess[h][5]) , schd_tab[s_tab[m][k]][5]);
					strcpy((schd_tab_unprocess[h][6]) , schd_tab[s_tab[m][k]][6]);
					strcpy((schd_tab_unprocess[h][7]) , schd_tab[s_tab[m][k]][7]);
					strcpy((schd_tab_unprocess[h][8]) , schd_tab[s_tab[m][k]][8]);
					strcpy((schd_tab_unprocess[h][9]) , schd_tab[s_tab[m][k]][9]);
					strcpy((schd_tab_unprocess[h][10]) , schd_tab[s_tab[m][k]][10]);
					strcpy((schd_tab_unprocess[h][11]) , schd_tab[s_tab[m][k]][11]);
					strcpy((schd_tab_unprocess[h][12]) , schd_tab[s_tab[m][k]][12]);
					strcpy((schd_tab_unprocess[h][13]) , schd_tab[s_tab[m][k]][13]);
					strcpy((schd_tab_unprocess[h][14]) , schd_tab[s_tab[m][k]][14]);
					strcpy((schd_tab_unprocess[h][15]) , schd_tab[s_tab[m][k]][15]);
					strcpy((schd_tab_unprocess[h][16]) , schd_tab[s_tab[m][k]][16]);
					strcpy((schd_tab_unprocess[h][17]) , schd_tab[s_tab[m][k]][17]);
					strcpy((schd_tab_unprocess[h][18]) , schd_tab[s_tab[m][k]][18]);
					strcpy((schd_tab_unprocess[h][19]) , schd_tab[s_tab[m][k]][19]);
					strcpy((schd_tab_unprocess[h][20]) , schd_tab[s_tab[m][k]][20]);
					strcpy((schd_tab_unprocess[h][21]) , schd_tab[s_tab[m][k]][21]);
					strcpy((schd_tab_unprocess[h][22]) , schd_tab[s_tab[m][k]][22]);
					strcpy((schd_tab_unprocess[h][23]) , schd_tab[s_tab[m][k]][23]);
					strcpy((schd_tab_unprocess[h][24]) , schd_tab[s_tab[m][k]][24]);
					strcpy((schd_tab_unprocess[h][25]) , schd_tab[s_tab[m][k]][25]);
					strcpy((schd_tab_unprocess[h][26]) , schd_tab[s_tab[m][k]][26]);
					strcpy((schd_tab_unprocess[h][27]) , schd_tab[s_tab[m][k]][27]);
					strcpy((schd_tab_unprocess[h][28]) , schd_tab[s_tab[m][k]][28]);
					strcpy((schd_tab_unprocess[h][29]) , schd_tab[s_tab[m][k]][29]);
					strcpy((schd_tab_unprocess[h][30]) , schd_tab[s_tab[m][k]][30]);
					strcpy((schd_tab_unprocess[h][31]) , schd_tab[s_tab[m][k]][31]);
					strcpy((schd_tab_unprocess[h][32]) , schd_tab[s_tab[m][k]][32]);
					strcpy((schd_tab_unprocess[h][33]) , schd_tab[s_tab[m][k]][33]);
					strcpy((schd_tab_unprocess[h][34]) , schd_tab[s_tab[m][k]][34]);
					strcpy((schd_tab_unprocess[h][35]) , schd_tab[s_tab[m][k]][35]);
					strcpy((schd_tab_unprocess[h][36]) , schd_tab[s_tab[m][k]][36]);
					strcpy((schd_tab_unprocess[h][37]) , schd_tab[s_tab[m][k]][37]);
					strcpy((schd_tab_unprocess[h][38]) , schd_tab[s_tab[m][k]][38]);
					strcpy((schd_tab_unprocess[h][39]) , schd_tab[s_tab[m][k]][39]);
					strcpy((schd_tab_unprocess[h][41]) , schd_tab[s_tab[m][k]][41]);
					strcpy((schd_tab_unprocess[h][42]) , schd_tab[s_tab[m][k]][42]);
					strcpy((schd_tab_unprocess[h][43]) , "Y"); //Don't want to build the tree, only want to build the cluster table
					strcpy((schd_tab_unprocess[h][44]) ,"Y"); //Don't want to build the tree, only want to build the cluster table
					strcpy((schd_tab_unprocess[h][DIRTYBIT]) , ("N")); // Don't update dirty bit as we only want to build the cluster table
					strcpy((schd_tab_unprocess[h][SUGG_RES_NUM]) , schd_tab[s_tab[m][k]][SUGG_RES_NUM]);
					strcpy((schd_tab_unprocess[h][OPER_ID]) , schd_tab[s_tab[m][k]][OPER_ID]);
					strcpy((schd_tab_unprocess[h][EARLIEST_ARR]) , schd_tab[s_tab[m][k]][EARLIEST_ARR]);
					strcpy((schd_tab_unprocess[h][LATEST_DEP]) , schd_tab[s_tab[m][k]][LATEST_DEP]);
					strcpy((schd_tab_unprocess[h][ORIG_PROMTIME]) , schd_tab[s_tab[m][k]][ORIG_PROMTIME]);
					strcpy((schd_tab_unprocess[h][SITE]) , schd_tab[s_tab[m][k]][SITE]);
					strcpy((schd_tab_unprocess[h][NEIGHBORS]) , schd_tab[s_tab[m][k]][NEIGHBORS]);
					strcpy((schd_tab_unprocess[h][SKIPTS]) , schd_tab[s_tab[m][k]][SKIPTS]);
					strcpy((schd_tab_unprocess[h][GRPIDX]) , schd_tab[s_tab[m][k]][GRPIDX]);
					strcpy((schd_tab_unprocess[h][PICKUPIDX]) , schd_tab[s_tab[m][k]][PICKUPIDX]);
					strcpy((schd_tab_unprocess[h][DWWAIT]) , schd_tab[s_tab[m][k]][DWWAIT]);
					strcpy((schd_tab_unprocess[h][PWWAIT]) , schd_tab[s_tab[m][k]][PWWAIT]);
					strcpy((schd_tab_unprocess[h][CS_OCC]) , schd_tab[s_tab[m][k]][CS_OCC]);
					strcpy((schd_tab_unprocess[h][BS_OCC]) , schd_tab[s_tab[m][k]][BS_OCC]);
					strcpy((schd_tab_unprocess[h][SEGMENTTYPE]), schd_tab[s_tab[m][k]][SEGMENTTYPE]);

					h++;
				}

				break;
			}
		}
	}


	strcpy(process_tab[LOADDB][0],("DONE"));

	if(h == 1){
		strcpy(process_tab[ACCESS][0],("READY"));
	}

	while(true){
		if( strcmp(process_tab[ACCESS][0],("READY"))==0 )
			break;
	}




}


void writeallsegtoDB(){

	strcpy((process_tab[DBWRITE][0]) , ("RUNNING"));

	for(int m = 0; m < MAXSEGMENTS; m++){
		if(s_tab[m][0] == 0)
			break;
		for(int k = 1; k < MAXSTOPS; k++){
			if(s_tab[m][k]==0)
				break;
			strcpy((process_tab[DBWRITE][0]) , ("RUNNING"));
			strcpy((schd_tab[s_tab[m][k]][DIRTYBIT]) , ("Y"));
			//  if(DEBUG == 1) gse << "Writing " << schd_tab[s_tab[m][k]][3] << " " << schd_tab[s_tab[m][k]][DIRTYBIT] <<  endl;
		}
	}

	sleep(1); // give time for dbwrite to trigger

	return;

}
void writesomesegtoDB(string segments){

	string temp = segments;

	while(temp!=""){

		string a_route = getNextToken(&temp, ",");
		int routeint = (int)to_number(a_route.substr(1,a_route.length()));

		strcpy((process_tab[DBWRITE][0]) , ("RUNNING"));

		for(int m = 0; m < MAXSEGMENTS; m++){
			if(s_tab[m][0] == 0)
				break;
			if(s_tab[m][0] == routeint){
				for(int k = 1; k < MAXSTOPS; k++){
					if(s_tab[m][k]==0)
						break;
					strcpy((process_tab[DBWRITE][0]) , ("RUNNING"));
					strcpy((schd_tab[s_tab[m][k]][DIRTYBIT]) , ("Y"));
					//  if(DEBUG == 1) gse << "Writing " << schd_tab[s_tab[m][k]][3] << " " << schd_tab[s_tab[m][k]][DIRTYBIT] <<  endl;
				}

				break;
			}
		}
	}

	sleep(1); // give time for dbwrite to trigger

	return;

}




bool CheckIfBreak (string pSplOther , string pTripType){
	if (pTripType.find("BRK",0)!= string::npos)
		return true;
	else if (pTripType.find("LNCH",0)!= string::npos)
		return true;
	else if (pTripType.find("BREAK",0)!= string::npos)
		return true;
	else if (pTripType.find("LUNCH",0)!= string::npos)
		return true;
	else if (pTripType.find("ADMIN",0)!= string::npos)
		return true;
	else{
		return false;
	}
}


int getPWByStop (string pTripdID,  string pStopType  , int pETA    ,int pPROMISED_TIME){
	int aResult = 0;
	if (pPROMISED_TIME == 0){
		aResult = 0;
	}
	else if (pPROMISED_TIME < pETA)
	{
		aResult = pETA - pPROMISED_TIME;
	}
	else{
		aResult = 0;
	}
	if (aResult < 0) {
		aResult = 0;
	}
	return aResult;
}

int getDWByStop (string pTripdID,string  pStopType, int pETA , int pETD  , int  pPROMISED_TIME ,  int pPERFORM_TIME){
	int aResult  = 0;
	if (pPROMISED_TIME== 0)
		aResult = 0;
	else if (pPROMISED_TIME < pETA){ //JDC Running late
		aResult = 0;
	}
	else{
		if (pETD - pETA > 720){

			aResult = pETD - (pETA + 720) - pPERFORM_TIME;
		}
		else{
			aResult = pETD - pETA - pPERFORM_TIME;
		}


		if (pStopType == "P")
		{
			aResult = pETA - pPROMISED_TIME;
			if (aResult < 0){
				aResult = pPROMISED_TIME - pETA;
			}
		}
		if (aResult < 0){
			aResult = 0;
		}
	}

	return aResult;
}

/*int p_WHEELLOAD1;
int p_AMBLOAD1;
int p_MAXEARLYDROPOFFFACTOR1;
int p_DIALRIDEEARLYPICKFACTOR1;
int p_DIALRIDELATEPICKFACTOR1;
int p_OTHEREARLYPICKFACTOR1;
int p_OTHERLATEPICKFACTOR1;
string IGNOREPUTIMES1;
int p_SHORTBREAK1;
int p_LUNCHBREAK1;
int p_PROXIMITYFACTOR1;
int a_mediumshortdistance1;
int a_mediumlongdistance1;
int a_shorttriptime1;
int a_longtriptime1;
int a_mediumtriptime1;
int a_extra_loadtime1;
string ZONE_DESCR1;
string IGNORE_DEPOTS_CUTOFF1;

void setRegistry(string pDisability, string pP_TripType){

if(pDisability.find("OT",0)!= string::npos){
        for(int z = 0; z < MAXZONES; z++){
            if(strcmp("OT", ZONE_DESCR[z])==0){
            p_WHEELLOAD1 =p_WHEELLOAD[z] ;
            p_AMBLOAD1 =p_AMBLOAD[z];
            p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
            p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
            p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
            p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
            p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
            IGNOREPUTIMES1 = ignorepu[z] ;
            p_SHORTBREAK1 = p_SHORTBREAK[z] ;
            p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
            p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
            a_mediumshortdistance1 = a_mediumshortdistance[z] ;
            a_mediumlongdistance1 = a_mediumlongdistance[z] ;
            a_shorttriptime1 = a_shorttriptime[z] ;
            a_longtriptime1 = a_longtriptime[z] ;
            a_mediumtriptime1 =  a_mediumtriptime[z] ;
            a_extra_loadtime1 = a_extra_loadtime[z];
            ZONE_DESCR1 =   ZONE_DESCR[z] ;
            IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
            break;
            }
            if(z+1 == MAXZONES){
                for(int b = 0; b < MAXZONES; b++){

            if(strcmp("ALL", ZONE_DESCR[b])==0){
            p_WHEELLOAD1 =p_WHEELLOAD[b] ;
            p_AMBLOAD1 = p_AMBLOAD[b];
            p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
            p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
            p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
            p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
            p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
            IGNOREPUTIMES1 = ignorepu[b] ;
            p_SHORTBREAK1 = p_SHORTBREAK[b] ;
            p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
            p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
            a_mediumshortdistance1 = a_mediumshortdistance[b] ;
            a_mediumlongdistance1 = a_mediumlongdistance[b] ;
            a_shorttriptime1 = a_shorttriptime[b] ;
            a_longtriptime1 = a_longtriptime[b] ;
            a_mediumtriptime1 =  a_mediumtriptime[b] ;
            a_extra_loadtime1 = a_extra_loadtime[b];
            ZONE_DESCR1 =   ZONE_DESCR[b] ;
            IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
            break;
        }
                }

            }
        }


    }
     else if( pP_TripType.find("OT",0)== string::npos){
        for(int z = 0; z < MAXZONES; z++){
            if(strcmp(pP_TripType.c_str(), ZONE_DESCR[z])==0){
            p_WHEELLOAD1 =p_WHEELLOAD[z] ;
            p_AMBLOAD1 =p_AMBLOAD[z];
            p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
            p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
            p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
            p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
            p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
            IGNOREPUTIMES1 = ignorepu[z] ;
            p_SHORTBREAK1 = p_SHORTBREAK[z] ;
            p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
            p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
            a_mediumshortdistance1 = a_mediumshortdistance[z] ;
            a_mediumlongdistance1 = a_mediumlongdistance[z] ;
            a_shorttriptime1 = a_shorttriptime[z] ;
            a_longtriptime1 = a_longtriptime[z] ;
            a_mediumtriptime1 =  a_mediumtriptime[z] ;
            a_extra_loadtime1 = a_extra_loadtime[z];
            ZONE_DESCR1 =   ZONE_DESCR[z] ;
            IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
            break;
            }
            if(z+1 == MAXZONES){
        for(int b = 0; b < MAXZONES; b++){

            if(strcmp("ALL", ZONE_DESCR[b])==0){
            p_WHEELLOAD1 =p_WHEELLOAD[b] ;
            p_AMBLOAD1 = p_AMBLOAD[b];
            p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
            p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
            p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
            p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
            p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
            IGNOREPUTIMES1 = ignorepu[b] ;
            p_SHORTBREAK1 = p_SHORTBREAK[b] ;
            p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
            p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
            a_mediumshortdistance1 = a_mediumshortdistance[b] ;
            a_mediumlongdistance1 = a_mediumlongdistance[b] ;
            a_shorttriptime1 = a_shorttriptime[b] ;
            a_longtriptime1 = a_longtriptime[b] ;
            a_mediumtriptime1 =  a_mediumtriptime[b] ;
            a_extra_loadtime1 = a_extra_loadtime[b];
            ZONE_DESCR1 =   ZONE_DESCR[b] ;
            IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
            break;
        }
                }

            }
        }
     }

return;
}
 */

/* void getAvlTops(int theAvlTopsShmid) //Hui, 01-FEB-21, populate tops table from db to shm, only gets called if travel date is current date
{
	if (DEBUGROUTED == 1 || DEBUG == 1)
		gse << "calculator.h - getAvlTops() begin." << endl;
	// int shmid = shmget(key_avl_tops, sizeof(char[MAXTRIPIDX][TRIPCOLSIZE][MAXLGSTRSIZE]), 0666);
	// avl_tops = (char(*)[TRIPCOLSIZE][MAXLGSTRSIZE])shmat(shmid, 0, 0);
	// int shmid_a = shmget(key_avl_tops, sizeof(char[MAXSEGMENTS][MAXAVLTOPSCOLUMNSIZE][MAXLGSTRSIZE]), 0666);
	avl_tops = (char(*)[MAXAVLTOPSCOLUMNSIZE][MAXLGSTRSIZE])shmat(theAvlTopsShmid, 0, 0);
	// if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() shmid_a:" << shmid_a << ", key_avl_tops: " << key_avl_tops << ", errno:" << errno << endl;
	Environment *env = NULL;
	Connection *conn = NULL;
	try
	{
		env = Environment::createEnvironment();
		conn = env->createConnection(username, password, connectString);
	}
	catch (...)
	{
		env = NULL;
		conn = NULL;
		if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() Error connecting to DB" << endl;
	}
	string command = "select runid, latitude, longitude, record_time from itms_avl_data_tops";
	try
	{
		Statement *stmt = NULL;
		ResultSet *rs = NULL;
		try
		{
			if(conn != NULL){
				if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() before querying DB" << endl;
				stmt = conn->createStatement(command);
				rs = stmt->executeQuery();
			}
		}
		catch (...)
		{
			stmt = NULL;
			rs = NULL;
			if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() error querying DB" << endl;
		}
		if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() query excuted, fetching dataset" << endl;
		string runid, lat, lng, record_time, isCurrentDate;
		int i = 0;
		try
		{
			if (rs != NULL)
			{
				while (rs->next())
				{
					try
					{
						runid = rs->getString(1);
						lat = rs->getString(2);
						lng = rs->getString(3);
						record_time = rs->getString(4);
						strcpy(avl_tops[i][0], runid.c_str());
						strcpy(avl_tops[i][1], lat.c_str());
						strcpy(avl_tops[i][2], lng.c_str());
						strcpy(avl_tops[i][3], record_time.c_str());
						strcpy(avl_tops[i][4], last_stop_shmid.c_str());
						strcpy(avl_tops[i][5], last_arr_time.c_str());
						strcpy(avl_tops[i][6], last_dep_time.c_str());
						i++;
					}
					catch (...)
					{
						if (DEBUGROUTED == 1 || DEBUG == 1)
							gse << "calculator.h - getAvlTops() error inside while loop, i:" << i << endl;
					}
				}
			}
		}
		catch (...)
		{
			if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() error while loop i:" << i << endl;
		}
		if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() row count: " << i << endl;
		strcpy(avl_tops[i][0], "");
		strcpy(avl_tops[i][1], "");
		strcpy(avl_tops[i][2], "");
		strcpy(avl_tops[i][3], "");
		try
		{
			if (stmt != NULL && rs != NULL)
			{
				stmt->closeResultSet(rs);
			}
			if (conn != NULL && stmt != NULL)
			{
				conn->terminateStatement(stmt);
			}
		}catch (...)
		{
			if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() error closeResultSet and terminateStatement" << endl;
		}
		for (int a = 0; a < MAXSEGMENTS; a++)
		{
			if(avl_tops[a][0]== ""){ // last entry is blank
				break;
			}
			if(sched_tab[avl_tops[a][4]][RES_NUM] != "" && sched_tab[avl_tops[a][4]][ARRIVE_TIME] == "0" )
			{
				strcpy(sched_tab[avl_tops[a][4]][ARRIVE_TIME], avl_tops[a][5]);
				strcpy(sched_tab[avl_tops[a][4]][DEPART_TIME], avl_tops[a][6]);
			}
		}
	}
	catch (...)
	{
		if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() Error" << endl;
	}
	try
	{
		if(env != NULL && conn != NULL){
			if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() terminateConnection and terminateEnvironment" << endl;
			env->terminateConnection(conn);
			env->terminateEnvironment(env);
		}
	}
	catch (...)
	{
		if (DEBUGROUTED == 1 || DEBUG == 1) gse << "calculator.h - getAvlTops() Error terminateConnection and terminateEnvironment" << endl;
	}
} */

string getCurrentDate_New()  //Hui, 01-FEB-21
{
    time_t t21 = time( NULL ); //
        struct tm tm21 = *localtime( &t21 ); //
        int launchmonth = tm21.tm_mon + 1; //
        int launchday = tm21.tm_mday; //
        int launchyear = tm21.tm_year + 1900; //

        string dateday = to_string( launchday ); //
        if( dateday.length() < 2 )
        {
            dateday = "0" + dateday; //
        }
        string datemonth = to_string( launchmonth ); //
        if( datemonth.length() < 2 )
        {
            datemonth = "0" + datemonth; //
        }
        string dateyear = to_string( launchyear ); //
        if( dateyear.length()>2 )
        {
            dateyear.erase( 0, 2 ); //
        }

        if( datemonth == "01" )
            datemonth = "JAN"; //
        if( datemonth == "02" )
            datemonth = "FEB"; //
        if( datemonth == "03" )
            datemonth = "MAR"; //
        if( datemonth == "04" )
            datemonth = "APR"; //
        if( datemonth == "05" )
            datemonth = "MAY"; //
        if( datemonth == "06" )
            datemonth = "JUN"; //
        if( datemonth == "07" )
            datemonth = "JUL"; //
        if( datemonth == "08" )
            datemonth = "AUG"; //
        if( datemonth == "09" )
            datemonth = "SEP"; //
        if( datemonth == "10" )
            datemonth = "OCT"; //
        if( datemonth == "11" )
            datemonth = "NOV"; //
        if( datemonth == "12" )
            datemonth = "DEC"; //

        string currentdate = dateday + "-" + datemonth + "-" + dateyear; //
		if(DEBUGROUTED == 1 || DEBUG == 1 ) gse << "calculator.h - getCurrentDate_New() returning: " << currentdate << endl;
        return currentdate;
}

void getDistTimeFromOsrm_New(string theOrigLat, string theOrigLng, string theDistLat, string theDistLng, int & theTime)
{    int x;    for (int d = 0;
         d < MAXREQUESTS;
         d++)
    {        if (requestIsEmpty(d))
        {
            usleep(10);
            if (requestIsEmpty(d))
            {
                x = d;
                break;
            }
        }
        if (d + 1 == MAXREQUESTS)
            d = -1;
    }
    if (DEBUGFB == 1 || DEBUG == 1)
        gse << "x is " << x << endl;    string aFunction = "FindBestDistSINGLE", bOsrm = theOrigLat + "," + theOrigLng + "," + theDistLat + "," + theDistLng;    // time_t t = time(NULL);
    // struct tm tm = *localtime(&t);
    // char timebuffer[100];
    // sprintf(timebuffer, "%s", asctime(&tm));
    // string localtimestr = timebuffer;
    // localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());    // updateRequest(q, clientdate, "NUM");
    updateRequest(x, aFunction, "FUNC");
    // updateRequest(q, localtimestr, "TIMESTAMP");
    // updateRequest(q, to_string(g), "ID");
    updateRequest(x, bOsrm, "LATLONG");
    // updateRequest(q, temproute[g][20] + "^" + temproute[g + 1][20], "TRIPIDX"); // buid edge between g and g+1
    // updateRequest(q, to_string(deviation), "NUMBEROFEDGES");
    updateRequest(x, "", "DISTANCE");
    if (DEBUGFB == 1 || DEBUG == 1)
        gse << "calculator.h - getDistTimeFromOsrm_New() x: " << x << ", FUNC: " << aFunction << "LATLONG: " << bOsrm <<  endl;
    bool aFoundTime = false;
    while (true)
    {
    	for (int q = 0;
             q < MAXREQUESTS;
             q++)
        {
    		if(q<10)
    			gse << "waiting for osrm: q:" << q << ", fetchRequest(q, DISTANCE): " << fetchRequest(q, "DISTANCE") << ", fetchRequest(q, TIME): " << fetchRequest(q, "TIME") << ", fetchRequest(q, FUNC): " << fetchRequest(q, "FUNC") << ", fetchRequest(q, LATLONG)" << fetchRequest(q, "LATLONG") << endl;
    	if (fetchRequest(q, "DISTANCE") != "" && fetchRequest(q, "TIME") != "" && fetchRequest(q, "FUNC") == "FindBestDistSINGLE" && fetchRequest(q, "LATLONG") == bOsrm)
            {
                double aDist = to_number(fetchRequest(q, "DISTANCE"));
                theTime = ( int )to_number( fetchRequest( q, "TIME" ) );
                aFoundTime = true;
                clearRequest(q);
                while (!requestIsEmpty(q))
                {
                }
                break;
            }
        }
    	if(aFoundTime)
    		break;
    }    if (DEBUGFB == 1 || DEBUG == 1) gse << "calculator.h - getDistTimeFromOsrm_New() at the end, theTime: " << theTime << endl;
}


void getRealTimeTravleTime(int & osrm_travel_time_from_tops_location_to_next_stop, string & vRecordTime, string p_td_segmentid, int p_stop_num, int puid, int doid)
{	
	//Hui, 10FEB21, this function uses real time location of the vehicle to get travel time to the next stop. 
	//Hui, 10FEB21, tops table is only been populated if travel date is current date. this constraint is in gse_monitor.
	int shmid_a = shmget ( key_avl_tops, sizeof( char[ MAXSEGMENTS ][ MAXAVLTOPSCOLUMNSIZE ][ MAXLGSTRSIZE ] ), 0666 );
	avl_tops = ( char ( * )[ MAXAVLTOPSCOLUMNSIZE ][ MAXLGSTRSIZE ] )shmat( shmid_a, 0, 0 );
	string vLat = "", vLon = ""; // will be used as if current stop.
	if (DEBUGFB == 1 || DEBUG == 1)
	            gse << "avl_tops[0][0]: " << avl_tops[0][0] << ", osrm_travel_time_from_tops_location_to_next_stop: " << osrm_travel_time_from_tops_location_to_next_stop << ", vRecordTime: " << vRecordTime << ", p_td_segmentid: " << p_td_segmentid << ", p_stop_num: " << p_stop_num << ", puid: " << puid << ", doid: " << doid << endl;
	for (int x = 0; x < MAXSTOPS; x++)
	{
		if (strcmp(avl_tops[x][0], "") == 0)
		{
			break;
		}
		if (DEBUGFB == 1 || DEBUG == 1)
			gse << "searching avl_tops: idx: " << x << ", segment_id: " << avl_tops[x][0] << ", target segment_id: " << p_td_segmentid << endl;
		// if (strcmp(avl_tops[x][0], p_td_segmentid) == 0)
		if(avl_tops[x][0] == p_td_segmentid)
		{
			vLat = avl_tops[x][1];
			vLon = avl_tops[x][2];
			vRecordTime = avl_tops[x][3];
			break;
		}
	}
	if (DEBUGFB == 1 || DEBUG == 1)
		gse << "vLat: " << vLat << ", vLon: " << vLon << ", vRecordTime: " << vRecordTime << endl;
	// if (strcmp(vLat, "") == 0 || strcmp(vLon, "") == 0 || strcmp(vRecordTime, "") == 0)
	if(vLat == "" || vLon == "" || vRecordTime == "")
	{
		osrm_travel_time_from_tops_location_to_next_stop = -1;
	}
	else
	{
		// get next stop latlng
		string nLat = "", nLon = "";
		if (p_stop_num != 1 && p_stop_num % 5 == 0)
		{
			for (int x = 0; x < MAXSEGMENTS; x++)
			{
				if (DEBUGFB == 1 || DEBUG == 1)
					gse << "searching s_tab: idx: " << x << ", segment_id(int): " << s_tab[x][0] << ", target segment_id: " << p_td_segmentid << ". p_stop_num: " << p_stop_num << endl;
				// if (strcmp("S" + to_string(s_tab[x][0]), p_td_segmentid) == 0)
				if ( ("S" + to_string(s_tab[x][0])) == p_td_segmentid )
				{
					if (DEBUGFB == 1 || DEBUG == 1) gse << "Segment found - s_tab[x][0]: " << s_tab[x][0] << ", = p_td_segmentid: " << p_td_segmentid << endl;
					if(schd_tab[s_tab[x][p_stop_num / 5]][7] == "P")
					{
						if (DEBUGFB == 1 || DEBUG == 1) gse << "It's a pickup." << endl;
						nLat = schd_tab[s_tab[x][p_stop_num / 5]][10];
						nLon = schd_tab[s_tab[x][p_stop_num / 5]][37];
					}else{
						if (DEBUGFB == 1 || DEBUG == 1) gse << "It's a dropoff." << endl;
						nLat = schd_tab[s_tab[x][p_stop_num / 5]][38];
						nLon = schd_tab[s_tab[x][p_stop_num / 5]][39];
					}
				}
			}
		}
		else
		{
			nLat = schd_tab[puid][10];
			nLon = schd_tab[puid][37];
		}
		if (DEBUGFB == 1 || DEBUG == 1)
			gse << "nLat: " << nLat << ", nLon: " << nLon << endl;
		// if (strcmp(nLat, "") == 0 || strcmp(nLon, "") == 0)
		if (nLat == "" || nLon == "")
		{
			osrm_travel_time_from_tops_location_to_next_stop = -1;
		}
		else
		{
			// call osrm to get travel_time and assign it to osrm_travel_time_from_tops_location_to_next_stop
			getDistTimeFromOsrm_New(vLat, vLon, nLat, nLon, osrm_travel_time_from_tops_location_to_next_stop);
		}
	}
}


std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>
itms_calcroute_RealTime( string pActual_Arr_Time, string pActual_Dep_Time, double timebetweenstops, string rteStr , string pPrev_city ,
        string pStreet_by_street ,   string   pEta  ,   string  pPromised_time ,    int  pPerf_time , int  p_early_morning_factor ,
        int  pStop_num , string p_td_segmentid,  int  pWc_occ   ,  int  pAmb_occ,   int pEscort_num  ,  string  pDisability  , string  pStop_type  ,
        int  p_WHEELLOAD2 , int   p_AMBLOAD2 ,
        string  pP_ClientName , string  pReturn_trip  , int p_DIALRIDEEARLYPICKFACTOR2  ,  int p_DIALRIDELATEPICKFACTOR2 , int  p_PROXIMITYFACTOR2, int  p_SHORTBREAK2 ,
        int p_LUNCHBREAK2   ,  int  p_MAXEARLYDROPOFFFACTOR2  , int  p_OTHEREARLYPICKFACTOR2  , int  p_OTHERLATEPICKFACTOR2 ,  string p_name   ,
        int pTimetonextstop , double pDisttonextstop ,  string pEarlystoptime  , string  pLatestoptime  ,
        double aTot_miles , int  aTot_driv_time  , string  pEtd  , int  pLast_dep_time , int pLast_arr_time ,
        int pLast_amb_occ , int  pLast_wc_occ , string  p_spl_other_desc ,
        int  OffLoaded   ,string  pP_TripType ,   int  p_prev_perf_time ,   int p_prev_stop_num ,  int p_latency   ,
        int pAppt_Time , int p_grp_cnt_amb ,int  p_grp_cnt_wc, string IGNOREPUTIMES2, string IGNORE_DEPOTS_CUTOFF2,string time_zone, string time_zone2,string Start_Time, int pCS_occ, int pBS_occ,int pLast_CS_occ , int  pLast_BS_occ, string pDisposition,
        bool & theFirstNotPerformedStop, int puid = -1, int doid = -1){


    //  if(DEBUG == 1) gse << "LAST DEP TIME " << pLast_dep_time << endl;
    int osrm_travel_time_from_tops_location_to_next_stop = -1; //Hui, 01-FEB-21
    string vRecordTime = ""; //Hui, 01-FEB-21, will be used as if current stop.

    int p_WHEELLOAD1;
    int p_AMBLOAD1;
    int p_MAXEARLYDROPOFFFACTOR1;
    int p_DIALRIDEEARLYPICKFACTOR1;
    int p_DIALRIDELATEPICKFACTOR1;
    int p_OTHEREARLYPICKFACTOR1;
    int p_OTHERLATEPICKFACTOR1;
    string IGNOREPUTIMES1;
    int p_SHORTBREAK1;
    int p_LUNCHBREAK1;
    int p_PROXIMITYFACTOR1;
    int a_mediumshortdistance1;
    int a_mediumlongdistance1;
    int a_shorttriptime1;
    int a_longtriptime1;
    int a_mediumtriptime1;
    int a_extra_loadtime1;
    string ZONE_DESCR1;
    string IGNORE_DEPOTS_CUTOFF1;
    double trav_distance = 0;

    if(pDisability.find("OT",0)!= string::npos){
        for(int z = 0; z < MAXZONES; z++){
            if(strcmp("OT", ZONE_DESCR[z])==0){
                p_WHEELLOAD1 =p_WHEELLOAD[z] ;
                p_AMBLOAD1 =p_AMBLOAD[z];
                p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
                p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
                p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
                p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
                p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
                IGNOREPUTIMES1 = ignorepu[z] ;
                p_SHORTBREAK1 = p_SHORTBREAK[z] ;
                p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
                p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
                a_mediumshortdistance1 = a_mediumshortdistance[z] ;
                a_mediumlongdistance1 = a_mediumlongdistance[z] ;
                a_shorttriptime1 = a_shorttriptime[z] ;
                a_longtriptime1 = a_longtriptime[z] ;
                a_mediumtriptime1 =  a_mediumtriptime[z] ;
                a_extra_loadtime1 = a_extra_loadtime[z];
                ZONE_DESCR1 =   ZONE_DESCR[z] ;
                IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
                break;
            }
            if(z+1 == MAXZONES){
                for(int b = 0; b < MAXZONES; b++){

                    if(strcmp("ALL", ZONE_DESCR[b])==0){
                        p_WHEELLOAD1 =p_WHEELLOAD[b] ;
                        p_AMBLOAD1 = p_AMBLOAD[b];
                        p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
                        p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
                        p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
                        p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
                        p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
                        IGNOREPUTIMES1 = ignorepu[b] ;
                        p_SHORTBREAK1 = p_SHORTBREAK[b] ;
                        p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
                        p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
                        a_mediumshortdistance1 = a_mediumshortdistance[b] ;
                        a_mediumlongdistance1 = a_mediumlongdistance[b] ;
                        a_shorttriptime1 = a_shorttriptime[b] ;
                        a_longtriptime1 = a_longtriptime[b] ;
                        a_mediumtriptime1 =  a_mediumtriptime[b] ;
                        a_extra_loadtime1 = a_extra_loadtime[b];
                        ZONE_DESCR1 =   ZONE_DESCR[b] ;
                        IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
                        break;
                    }
                }

            }
        }


    }
    else if( pP_TripType.find("OT",0)== string::npos){
        for(int z = 0; z < MAXZONES; z++){
            if(strcmp(pP_TripType.c_str(), ZONE_DESCR[z])==0){
                p_WHEELLOAD1 =p_WHEELLOAD[z] ;
                p_AMBLOAD1 =p_AMBLOAD[z];
                p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
                p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
                p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
                p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
                p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
                IGNOREPUTIMES1 = ignorepu[z] ;
                p_SHORTBREAK1 = p_SHORTBREAK[z] ;
                p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
                p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
                a_mediumshortdistance1 = a_mediumshortdistance[z] ;
                a_mediumlongdistance1 = a_mediumlongdistance[z] ;
                a_shorttriptime1 = a_shorttriptime[z] ;
                a_longtriptime1 = a_longtriptime[z] ;
                a_mediumtriptime1 =  a_mediumtriptime[z] ;
                a_extra_loadtime1 = a_extra_loadtime[z];
                ZONE_DESCR1 =   ZONE_DESCR[z] ;
                IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
                break;
            }
            if(z+1 == MAXZONES){
                for(int b = 0; b < MAXZONES; b++){

                    if(strcmp("ALL", ZONE_DESCR[b])==0){
                        p_WHEELLOAD1 =p_WHEELLOAD[b] ;
                        p_AMBLOAD1 = p_AMBLOAD[b];
                        p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
                        p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
                        p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
                        p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
                        p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
                        IGNOREPUTIMES1 = ignorepu[b] ;
                        p_SHORTBREAK1 = p_SHORTBREAK[b] ;
                        p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
                        p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
                        a_mediumshortdistance1 = a_mediumshortdistance[b] ;
                        a_mediumlongdistance1 = a_mediumlongdistance[b] ;
                        a_shorttriptime1 = a_shorttriptime[b] ;
                        a_longtriptime1 = a_longtriptime[b] ;
                        a_mediumtriptime1 =  a_mediumtriptime[b] ;
                        a_extra_loadtime1 = a_extra_loadtime[b];
                        ZONE_DESCR1 =   ZONE_DESCR[b] ;
                        IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
                        break;
                    }
                }

            }
        }
    }



    //  if(DEBUG == 1) gse << "MAX "<<p_MAXEARLYDROPOFFFACTOR1 << endl;



    //  if(DEBUG == 1) gse << "In new calc route " << endl;
    /*
1. offloaded (?)
2. <= 999 so -1 for occupancy
3. perf time will be 0 because double converted to int... ex: aTime_per_amb_in_group
     */

/*-------------start -- setting up Calculations --------------*/
    string aSTime                 ;
    string aBlk                   ;
    string aF_item                       ;
    int aCnt                          ;
    int aCnt2                        ;
    int aProm_time                    ;
    int aDep_time                     ;
    int aArr_time                     ;
    double aTime_per_amb_in_group        ;
    double aTime_per_wc_in_group         ;
    int aOffLoaded                    ;
    int aEarlypickup                  ;
    int aEarlydropoff                 ;
    int aLatepickup                   ;
    int aPar_early_morning_factor     ;
    int aTime_per_amb_for_same_stop  ;
    int aTempStartTime  ;
    aCnt = 1;
    aTime_per_amb_in_group = 1 / 5;
    aTime_per_wc_in_group = 1 / 1;
    aTime_per_amb_for_same_stop = 1 / 3;

    aProm_time = 0;
    aDep_time = 0;
    aArr_time = 0;
    aOffLoaded = 0;

    aEarlypickup = 0;
    aEarlydropoff = 0;
    aLatepickup = 0;
    aPar_early_morning_factor = 0;
    int pPCA = 0;
    int pStart_Time = (int)to_number(Start_Time);

    if(pDisability.find("PCA",0)!= string::npos){ /////Shayna  05/04/2018
        pPCA = 1;
    }


    /********Here we will find out the time to next stop value **************/


    pTimetonextstop = round(F_GET_TRAVEL_TIME (timebetweenstops, time_zone, "*"));


    /*
    if(time_zone2 == "#" && pTimetonextstop == 0){
        pTimetonextstop = 1;
    }

     */

    aProm_time = itms_to_minutes (ampm2fullhrs (pPromised_time));
    aDep_time = aProm_time;


    if (pStop_num == 1){
        aDep_time = aDep_time + aPar_early_morning_factor;
    }


    /*-------------end -- setting up Calculations --------------*/

    if ((pDisposition != "N" || pStop_type == "P" )&& (pStop_num > 1) && (pStop_num < (int)to_number(MAXSTOPNUM[0]))){ ////////////////<=999

        pWc_occ = 0;
        pAmb_occ = 0;

        if(pDisposition != "N"){

            if (pDisability.find("WC",0)!= string::npos || pDisability.find("SC",0)!= string::npos){

                pPerf_time = p_WHEELLOAD1;

                if (pStop_type == "P"){

                    pWc_occ = pLast_wc_occ + 1;
                }
                else{
                    pWc_occ = pLast_wc_occ - 1;
                }



                /*if ( (pTimetonextstop == 0) && ( (aProm_time - pLast_arr_time) < 15)){

                  if(DEBUG == 1) gse << "perf time will be 0 because double converted to int... " << endl;

               pPerf_time = aTime_per_amb_for_same_stop;
               pPerf_time =
                  pPerf_time + (aTime_per_amb_in_group * aOffLoaded);
               aOffLoaded = aOffLoaded + 1;
            }
            else{
               aOffLoaded = 0;
            }*/



                pCS_occ = pLast_CS_occ;
                pBS_occ = pLast_BS_occ;
                pAmb_occ = pLast_amb_occ;
            }

            else if (pDisability.find("CS",0)!= string::npos ){


                pPerf_time = p_AMBLOAD1;

                if (pStop_type == "P"){

                    pCS_occ = pLast_CS_occ + 1;
                }
                else{
                    pCS_occ = pLast_CS_occ - 1;
                }
                if (pStop_type == "P"){
                    pAmb_occ = pLast_amb_occ + 1;
                }
                else {
                    pAmb_occ = pLast_amb_occ - 1;
                }



                /*if ( (pTimetonextstop == 0) && ( (aProm_time - pLast_arr_time) < 15)){

                  if(DEBUG == 1) gse << "perf time will be 0 because double converted to int... " << endl;

               pPerf_time = aTime_per_amb_for_same_stop;
               pPerf_time =
                  pPerf_time + (aTime_per_amb_in_group * aOffLoaded);
               aOffLoaded = aOffLoaded + 1;
            }
            else{
               aOffLoaded = 0;
            }*/


                pWc_occ = pLast_wc_occ;
                pBS_occ = pLast_BS_occ;
            }
            else if (pDisability.find("CY",0)!= string::npos ){

                pPerf_time = p_AMBLOAD1;

                if (pStop_type == "P"){

                    pBS_occ = pLast_BS_occ + 1;
                }
                else{
                    pBS_occ = pLast_BS_occ - 1;
                }
                if (pStop_type == "P"){
                    pAmb_occ = pLast_amb_occ + 1;
                }
                else {
                    pAmb_occ = pLast_amb_occ - 1;
                }



                /*if ( (pTimetonextstop == 0) && ( (aProm_time - pLast_arr_time) < 15)){

                  if(DEBUG == 1) gse << "perf time will be 0 because double converted to int... " << endl;

               pPerf_time = aTime_per_amb_for_same_stop;
               pPerf_time =
                  pPerf_time + (aTime_per_amb_in_group * aOffLoaded);
               aOffLoaded = aOffLoaded + 1;
            }
            else{
               aOffLoaded = 0;
            }*/


                pWc_occ = pLast_wc_occ;
                pCS_occ = pLast_CS_occ;
            }
            else{
                if(pDisability.find("DOSLOW",0)!= string::npos )  {
                    pPerf_time = p_WHEELLOAD1;
                }
                else {
                    pPerf_time =  p_AMBLOAD1;
                }


                if (pStop_type == "P"){
                    pAmb_occ = pLast_amb_occ + 1;
                }
                else {
                    pAmb_occ = pLast_amb_occ - 1;
                }



                /*if ( (pTimetonextstop == 0) && ( (aProm_time - pLast_dep_time) < 15)){

               pPerf_time =
                  aTime_per_amb_for_same_stop
                  + (aTime_per_amb_in_group * aOffLoaded);
               aOffLoaded = aOffLoaded + 1;
            }
            else{
               aOffLoaded = 0;
            }*/

                pWc_occ = pLast_wc_occ;
                pBS_occ = pLast_BS_occ;
                pCS_occ = pLast_CS_occ;
            }

            if (pDisability.find("XLT",0)!= string::npos ) {

                pPerf_time = a_extra_loadtime1;//p_EXTRA_LOADTIME;
            }

            if (pPCA > 0){

                if (pStop_type == "P"){

                    pAmb_occ = pAmb_occ + 1;
                }
                else{
                    pAmb_occ = pAmb_occ - 1;
                }

            }

            if (pEscort_num > 0){

                if (pStop_type == "P"){

                    pAmb_occ = pAmb_occ + pEscort_num;
                }
                else{
                    pAmb_occ = pAmb_occ - pEscort_num;
                }

            }
        }
        else{
            pAmb_occ = pLast_amb_occ;
            pWc_occ = pLast_wc_occ;
            pBS_occ = pLast_BS_occ;
            pCS_occ = pLast_CS_occ;

        }

        if (pActual_Arr_Time != "0000") { //Hui, "0000" means it's not arrived.
            aArr_time = (int)to_number(pActual_Arr_Time); //Hui, need to use vehicle's current time from itms_avl_data_tops table.
            if (DEBUGFB == 1 || DEBUG == 1) gse << "the actual arrive time is " << aArr_time << " for stop num " << pStop_num << endl;
        }

        else {

            if ( (pTimetonextstop == 0) && ( (aProm_time - pLast_arr_time) < 15)){ //Hui, if location is the same and less than 15 minutes, then pick up at the same time. time to next stop is 0 meaning same location.
            	//JDC Note, the 15 minutes is hardwired
                aArr_time = pLast_dep_time;                 /*--pLast_arr_time;*/
                if (DEBUGFB == 1 || DEBUG == 1) gse << "same stop, using last depart time " << aArr_time << " for stop num " << pStop_num << endl;
            }
            else{

                if (pDisability.find("LP", 0) != string::npos && (pStop_type != "P"))
                {

                    aArr_time = aProm_time;
                }
                else
                {
                    if (theFirstNotPerformedStop)//Hui, 03-FEB-21
                    {
                        if (DEBUGFB == 1 || DEBUG == 1)
                            gse << "examing Next Stop, try to use osrm_travel_time_from_tops_location_to_next_stop first, if it's not available, then use last_departure_time, to calculate arrive time." << endl;
                        //Hui, 01-FEB-21, tops table is only been populated if travel date is current date, otherwise osrm_travel_time_from_tops_location_to_next_stop stays -1
                        // scan avl_tops to find the segment.
                        try{
                            getRealTimeTravleTime(osrm_travel_time_from_tops_location_to_next_stop, vRecordTime, p_td_segmentid, pStop_num, puid, doid);
                        }catch(...){
                            if (DEBUGFB == 1 || DEBUG == 1) gse << "avl_tops is possibly empty" << endl;
                        }
                        if (DEBUGFB == 1 || DEBUG == 1)
                            gse << "osrm_travel_time_from_tops_location_to_next_stop: " << osrm_travel_time_from_tops_location_to_next_stop << endl;
                        if (osrm_travel_time_from_tops_location_to_next_stop >= 0)
                        {

                            // aArr_time = current_time_from_avl_tops + osrm_travel_time_from_tops_location_to_next_stop;
                            aArr_time = (int)itms_to_minutes(ampm2fullhrs(vRecordTime)) + osrm_travel_time_from_tops_location_to_next_stop;
                            if (DEBUGFB == 1 || DEBUG == 1) gse << "first non performed stop (tops value) arrive time " << aArr_time << " for stop num " << pStop_num << endl;
                        }
                        else
                        {
                            aArr_time = pLast_dep_time + pTimetonextstop;
                            if (DEBUGFB == 1 || DEBUG == 1) gse << "first non performed stop (no tops value) arrive time " << aArr_time << " for stop num " << pStop_num << endl;
                        }
                        theFirstNotPerformedStop = false;
                    }
                    else
                    {
                        aArr_time = pLast_dep_time + pTimetonextstop;
                        if (DEBUGFB == 1 || DEBUG == 1) gse << "next non performed stop arrive time " << aArr_time << " for stop num " << pStop_num << ". pLast_dep_time: " << pLast_dep_time << endl;
                    }

                }
            }
        }


        /*------------LUNCH and ADMIN CHECK ------------------*/


        if (CheckIfBreak ("Dummy", pP_TripType)){ //Hui, 02-FEB-21, since it's BREAK, not sure if we need a very accurate arrival time. CheckIfBreak() doesn't use first parameter at all.
			if (DEBUGFB == 1 || DEBUG == 1) gse <<  "CheckIfBreak() is true" << endl;
            aEarlydropoff=0;
            if (pStop_type == "P") {
                if  (pStart_Time==0 && pAppt_Time !=0) {

                    aArr_time=  pAppt_Time  - p_LUNCHBREAK1;
                    aDep_time=  pAppt_Time  - p_LUNCHBREAK1;
                    if (pAppt_Time  - p_LUNCHBREAK1 < pLast_dep_time + floor(pTimetonextstop)){
                        aArr_time = pLast_dep_time + floor(pTimetonextstop);
                        aDep_time = pLast_dep_time + floor(pTimetonextstop);
                    }

                }

                else{
                    aArr_time = pStart_Time;
                    aDep_time  = pStart_Time;
                    if (pStart_Time < pLast_dep_time + floor(pTimetonextstop)){
                        aArr_time = pLast_dep_time + floor(pTimetonextstop);
                        aDep_time = pLast_dep_time + floor(pTimetonextstop);
                    }
                }


            }
            else
                if  (pStart_Time!=0 && pAppt_Time ==0) {

                    aArr_time=  pStart_Time + p_LUNCHBREAK1;
                    aDep_time=  pStart_Time + p_LUNCHBREAK1;
                    if (pStart_Time < pLast_dep_time + floor(pTimetonextstop)) {
                        aArr_time = pLast_dep_time + floor(pTimetonextstop) +  p_LUNCHBREAK1;
                        aDep_time = pLast_dep_time + floor(pTimetonextstop) + p_LUNCHBREAK1;
                    }
                }

                else{
                    aArr_time = pAppt_Time;
                    aDep_time  = pAppt_Time;
                    if (pAppt_Time < pLast_dep_time + floor(pTimetonextstop)){
                        aArr_time = pLast_dep_time + floor(pTimetonextstop) + p_LUNCHBREAK1;
                        aDep_time = pLast_dep_time + floor(pTimetonextstop) + p_LUNCHBREAK1;
                    }

                }
        }




        /*--------END OF ----LUNCH and ADMIN CHECK -*/
        /*--NOW CALCULATING DEPART TIME*/

        if (pDisability.find("OT",0) != string::npos)
        {
            if (pReturn_trip == "Y"){

                aEarlypickup = p_OTHEREARLYPICKFACTOR1;             /* C[006] */
                aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
                aLatepickup = p_OTHERLATEPICKFACTOR1;
                //   if(DEBUG == 1) gse << "here5 " << endl;
            }
            else{
                aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
                aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
                aLatepickup = p_DIALRIDELATEPICKFACTOR1;
                //   if(DEBUG == 1) gse << "here4 " << endl;
            }
        }
        else if (pDisability.find("LP",0) != string::npos){
            aEarlypickup = 0;
            aEarlydropoff = 0;
            aLatepickup = 0;
            //  if(DEBUG == 1) gse << "here3 " << endl;
        }
        else{
            //aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
            //aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

            if (pReturn_trip == "Y"){

                aEarlypickup = p_OTHEREARLYPICKFACTOR1;             /* C[006] */
                aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
                aLatepickup = p_OTHERLATEPICKFACTOR1;
                //    if(DEBUG == 1) gse << "here2 " << endl;
            }
            else{
                aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */
                aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
                aLatepickup = p_DIALRIDELATEPICKFACTOR1;
                //  if(DEBUG == 1) gse << "here1 " << endl;
            }
        }


        if (pStop_type == "P"){ //Hui, if it's a pick up
            //  if(DEBUG == 1) gse << "Stop type is p " << endl;
            if(pActual_Dep_Time != "0000"){ //Hui, and if the trip is performed, then depart time is actual departure time
                aDep_time = (int)to_number(pActual_Dep_Time); //Hui, need to use vehicle's current time from itms_avl_data_tops table.
                if(DEBUG == 1) gse << "dep: 5 " << pActual_Dep_Time << endl;
            }

            else{ //Hui, if the trip is not performed



                if (!CheckIfBreak ("Dummy", pP_TripType)) { //Hui, and if it's not a break
                    if (aProm_time == 0){ //Hui, and if 
                        if (pTimetonextstop == 0){ //Hui, and if pick up is the same location as the most recent drop off, then the departure time is last departure time plus perform time 
                            aDep_time = pLast_dep_time + pPerf_time;
                            if(DEBUG == 1) gse << "dep: 4 " << pLast_dep_time << " " <<  pPerf_time << endl;
                        }
                        else {//Hui, but if not the same location, then departure time is arrival time plus perform time
                            aDep_time = aArr_time + pPerf_time;
                            if(DEBUG == 1) gse << "dep: 3 " << aArr_time << " " <<  aEarlypickup << endl;
                        }
                    }

                    else  {                            /*-- prom_time is not 0   */
                        if ( (pTimetonextstop == 0) && ( (aProm_time - pLast_arr_time) < 15)){//Hui, if same location and arrived within 15 minutes of promise time,
						//Hui, then departure time is last departure time plus perform time? shouldn't it be pLast_dep_time + (aProm_time - pLast_arr_time) + pPerf_time ? or aProm_time + pPerf_time ?
                        	//JDC This is when you are dropping more than one person at the stop.
                            aDep_time = pLast_dep_time + pPerf_time; //Hui, does this force the person to leave early? //JDC Yes it does
                            if(DEBUG == 1) gse << "dep: 8 " << pLast_dep_time << " " <<  pPerf_time << endl;
                            //aDep_time = aProm_time + pPerf_time; //JDC We have corrected here
                            //if(DEBUG == 1) gse << "dep: 8 " << "aDep_time: " << aDep_time << ", aProm_time: " << aProm_time << ", pPerf_time: " <<  pPerf_time << endl;
                        }
                        else if( (aArr_time + pPerf_time) > (aProm_time - aEarlypickup)){//Hui, why is this case significant? isn't this calculation the usual case?
                            /*-- arrived after the earliest pickup time then don't wait, i.e., pickup and leave*/
                            aDep_time = aArr_time + pPerf_time;
                            if(DEBUG == 1) gse << "dep: 7 " << aArr_time << " " <<  pPerf_time << endl;
                        }
                        else{ //JDC Arrived earlier than the early pickup window, but you are allowed to pickup and leave
                            if ((IGNOREPUTIMES1 == "T") && (pReturn_trip != "Y") && (pAppt_Time != 0)){//Hui, ignore pick up time, pick up at whatever time calculates.
                                aDep_time = aArr_time + pPerf_time;
                                if(DEBUG == 1) gse << "dep: 2 " << aArr_time << " " <<  pPerf_time << endl;
                            }
                            else{//Hui, Arrived earlier than the early pickup window, but not allowed to pickup and leave
                                aDep_time = aProm_time - aEarlypickup + pPerf_time; //JDC Waiting until you're within the early pickup window
                                if(DEBUG == 1) gse << "dep: 1 " << aProm_time << " " <<  aEarlypickup << endl;
                                //aDep_time = aProm_time + pPerf_time; //JDC Should still wait until promised time
                                //if(DEBUG == 1) gse << "dep: 1 " << "aDep_time: " << aDep_time << ", aProm_time: " << aProm_time << ", pPerf_time: " <<  pPerf_time << endl;
                            }
                        }

                        /*IF pu_eta < (start_time - DialRideEarlyPickFactor) ADS-110 */
                        if (aArr_time < (aProm_time - aEarlypickup)){

                            if(pP_ClientName =="ESSTS"){
                                aArr_time = aDep_time - pPerf_time;
                            }
                            else {//Hui, if arrive time is earlier than early pick up time, then wait until the early pick up time and then perform. 
                                aDep_time = (aProm_time - aEarlypickup) + pPerf_time; //JDC Shouldn't one still wait until promised time?
                            	if(DEBUG == 1) gse << "dep: 6 " << aProm_time << " " <<  aEarlypickup << " " << pPerf_time << ", aDep_time = (" << aProm_time << " - " << aEarlypickup << ") + " << pPerf_time << " = " << aDep_time << endl;
                                //aDep_time = aProm_time + pPerf_time; //JDC This makes more sense to me unless the person has agreed to be picked up early
                                //if(DEBUG == 1) gse << "dep: 6 " << "aProm_time: " << aProm_time << ", pPerf_time: " << pPerf_time << ", aDep_time = (" << aProm_time << " + " << pPerf_time << ")  = " << aDep_time << endl;
                            }//Hui, dep 6 overides dep 1, 2, 7 and 8 
                        }
                    }

                }

            }

            pEarlystoptime = aProm_time;
            pLatestoptime = aProm_time + aLatepickup;
        }
        else {                     /*-- for Drop Off -- stop_type = 'D'*/

            if(pActual_Dep_Time != "0000"){ //Hui, if dropoff has taken place
                aDep_time = (int)to_number(pActual_Dep_Time);
                if(DEBUG == 1) gse << "dep: 5 " << pActual_Dep_Time << endl;
            }

            else{

                if (!CheckIfBreak ("Dummy", pP_TripType)){
                    if (aProm_time == 0){
                        if (pTimetonextstop == 0){
                            aDep_time = pLast_dep_time + pPerf_time;
                        }
                        else{
                            aDep_time = aArr_time + pPerf_time;
                        }
                    }

                    else {                                 /*-- prom_time is not 0*/
                        if ( (pTimetonextstop == 0) && ( (aProm_time - pLast_arr_time) < 15)){

                            aDep_time = pLast_dep_time + pPerf_time;
                        }
                        else if ( (aArr_time + pPerf_time) > (aProm_time - aEarlydropoff)){

                            /*-- arrived late or same location different times*/
                            /* If do_earlystoptime = 0, then do_etd = do_eta + do_perf_time ADS-110*/
                            aDep_time = aArr_time + pPerf_time;
                            /* START ADS 44.2   C[087]*/
                        }
                        else if ( (aArr_time + pPerf_time) < (aProm_time - aEarlydropoff)){

                            aDep_time = (aProm_time - aEarlydropoff) + pPerf_time;
                            /* END ADS 44.2   C[087]*/
                        }
                        else if (aEarlydropoff == 0){
                            /* C[006] */
                            aDep_time = aArr_time + pPerf_time;
                        }
                        else{
                            aDep_time = aProm_time - aEarlydropoff;
                        }
                    }
                }
                if (!CheckIfBreak ("Dummy", pP_TripType)){
                    pEarlystoptime = aProm_time - aEarlydropoff;
                }
            }

            pLatestoptime = aProm_time;
            aTot_miles = aTot_miles + trav_distance;
            aTot_driv_time = aTot_driv_time + pTimetonextstop;
        }                                        /*-- stop_type = 'D'*/
        if(DEBUG == 1) gse << "aDep_time: " << aDep_time << endl;

        if (aDep_time > 1439){
            aDep_time = 1439;
        }
        if (aArr_time > 1439){
            aArr_time = 1439;
        }


        pEta = itms_minutes_to_ampm (aArr_time);
        pEtd = itms_minutes_to_ampm (aDep_time);

        //  if(DEBUG == 1) gse << " The eta " << pEta << endl;


    }

    else{


        if(pDisposition == "N" && pStop_type == "D")
        {
            pCS_occ = pLast_CS_occ;
            pBS_occ = pLast_BS_occ;
            pAmb_occ = pLast_amb_occ;
            pWc_occ = pLast_wc_occ;
            aArr_time = pLast_dep_time;
            aDep_time = aArr_time;
            pEta = itms_minutes_to_ampm (aArr_time);
            pEtd = itms_minutes_to_ampm (aDep_time);
            pPerf_time = 0;
        }



        else if (pStop_num == 1)
        {

            aArr_time = pLast_arr_time;

            aDep_time = aArr_time;

            pAmb_occ = 0;
            pWc_occ = 0;
            pEta = itms_minutes_to_ampm (aArr_time);
            pEtd = itms_minutes_to_ampm (aDep_time);
            pPerf_time = 0;

        }

        else if (pStop_num == (int)to_number(MAXSTOPNUM[0]))//Hui, 02-FEB-21, since it's DO Garage, not sure if we need a very accurate arrival time.
        {
            aArr_time = pLast_dep_time +pTimetonextstop;
            aDep_time = aArr_time;
            pAmb_occ = 0;
            pWc_occ = 0;
            pEta = itms_minutes_to_ampm (aArr_time);
            pEtd = itms_minutes_to_ampm (aDep_time);
            pPerf_time = 0;

        }


        pEarlystoptime = pEta;
        pLatestoptime = pEtd;
    }



    if (pActual_Arr_Time == "0000") {
        pLast_dep_time = aDep_time;
        pLast_arr_time = aArr_time;
    }

    else{
        pLast_dep_time = (int)to_number(pActual_Dep_Time);
        pLast_arr_time = (int)to_number(pActual_Arr_Time);
    }
    pLast_amb_occ = pAmb_occ;
    pLast_wc_occ = pWc_occ;






    std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int> returnVar(pEta,
            pWc_occ, pAmb_occ,pEscort_num,pTimetonextstop,trav_distance,pEarlystoptime,
            pLatestoptime, aTot_miles,aTot_driv_time, pEtd, OffLoaded,pPerf_time, pCS_occ,pBS_occ);

	if(DEBUG == 1) gse << "Exiting itms_calcroute_RealTime(), returning pEta: " << pEta << ", pWc_occ: " << pWc_occ << ", pAmb_occ: " << pAmb_occ 
		<< ", pEscort_num: " << pEscort_num << ", pTimetonextstop: " << pTimetonextstop << ", trav_distance: " << trav_distance << ", pEarlystoptime: " 
		<< pEarlystoptime << ", pLatestoptime: " << pLatestoptime << ", aTot_miles: " << aTot_miles << ", aTot_driv_time: " << aTot_driv_time << ", pEtd: " 
		<< pEtd << ", OffLoaded: " << OffLoaded << ", pPerf_time: " << pPerf_time << ", pCS_occ: " << pCS_occ << ", pBS_occ: " << pBS_occ << endl;

    return returnVar;

}



std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>
itms_calcroute( string pActual_Arr_Time, string pActual_Dep_Time, double timebetweenstops, string rteStr , string pPrev_city ,
		string pStreet_by_street ,   string   pEta  ,   string  pPromised_time ,    int  pPerf_time , int  p_early_morning_factor ,
		int  pStop_num , string p_td_segmentid,  int  pWc_occ   ,  int  pAmb_occ,   int pEscort_num  ,  string  pDisability  , string  pStop_type  ,
		int  p_WHEELLOAD2 , int   p_AMBLOAD2 ,
		string  pP_ClientName , string  pReturn_trip  , int p_DIALRIDEEARLYPICKFACTOR2  ,  int p_DIALRIDELATEPICKFACTOR2 , int  p_PROXIMITYFACTOR2, int  p_SHORTBREAK2 ,
		int p_LUNCHBREAK2   ,  int  p_MAXEARLYDROPOFFFACTOR2  , int  p_OTHEREARLYPICKFACTOR2  , int  p_OTHERLATEPICKFACTOR2 ,  string p_name   ,
		int pTimetonextstop , double pDisttonextstop ,  string pEarlystoptime  , string  pLatestoptime  ,
		double aTot_miles , int  aTot_driv_time  , string  pEtd  , int  pLast_dep_time , int pLast_arr_time ,
		int pLast_amb_occ , int  pLast_wc_occ , string  p_spl_other_desc ,
		int  OffLoaded   ,string  pP_TripType ,   int  p_prev_perf_time ,   int p_prev_stop_num ,  int p_latency   ,
		int pAppt_Time , int p_grp_cnt_amb ,int  p_grp_cnt_wc, string IGNOREPUTIMES2, string IGNORE_DEPOTS_CUTOFF2,string time_zone, string time_zone2,string Start_Time, int pCS_occ, int pBS_occ,int pLast_CS_occ , int  pLast_BS_occ, string pDisposition,
		int puid = -1, int doid = -1){

			bool theFirstNotPerformedStop = false;

		return itms_calcroute_RealTime(pActual_Arr_Time, pActual_Dep_Time, timebetweenstops, rteStr , pPrev_city ,
		pStreet_by_street ,     pEta  ,    pPromised_time ,    pPerf_time , p_early_morning_factor ,
		pStop_num , p_td_segmentid,  pWc_occ   ,  pAmb_occ,   pEscort_num  ,   pDisability  ,  pStop_type  ,
		p_WHEELLOAD2 ,  p_AMBLOAD2 ,
		 pP_ClientName ,  pReturn_trip  , p_DIALRIDEEARLYPICKFACTOR2  ,  p_DIALRIDELATEPICKFACTOR2 , p_PROXIMITYFACTOR2, p_SHORTBREAK2 ,
		p_LUNCHBREAK2   ,  p_MAXEARLYDROPOFFFACTOR2  , p_OTHEREARLYPICKFACTOR2  , p_OTHERLATEPICKFACTOR2 ,  p_name   ,
		pTimetonextstop , pDisttonextstop ,  pEarlystoptime  ,  pLatestoptime  ,
		aTot_miles , aTot_driv_time  ,  pEtd  , pLast_dep_time , pLast_arr_time ,
		pLast_amb_occ , pLast_wc_occ ,  p_spl_other_desc ,
		OffLoaded   , pP_TripType ,   p_prev_perf_time ,   p_prev_stop_num ,  p_latency   ,
		pAppt_Time , p_grp_cnt_amb ,p_grp_cnt_wc, IGNOREPUTIMES2, IGNORE_DEPOTS_CUTOFF2,time_zone, time_zone2,Start_Time, pCS_occ, pBS_occ,pLast_CS_occ , pLast_BS_occ, pDisposition,
		theFirstNotPerformedStop, puid, doid);

}












std::tuple<string,int,int,int,int,double,string,string,double,int,string,int,int>

itms_calcroute2( string act_arr_time, string act_dep_time, double trav_distance, string rteStr ,string    p_citytown ,      string p_street_by_street ,   string   p_eta  ,   string  p_promised_time ,    int  p_perf_time , int  p_early_morning_factor ,  int  p_stop_num ,
		string p_td_segmentid,  int  p_wc_occ   ,  int  p_amb_occ,   int p_esc  ,  string  p_disability  , string  p_stop_type  ,  int  p_WHEELLOAD1 , int  p_AMBLOAD1 ,
		string  p_customer , string  p_return_trip  , int p_DIALRIDEEARLYPICKFACTOR1  ,  int p_DIALRIDELATEPICKFACTOR1 , int  p_PROXIMITYFACTOR1, int  p_SHORTBREAK1  ,
		int p_LUNCHBREAK1   ,  int  p_MAXEARLYDROPOFFFACTOR1  , int  p_OTHEREARLYPICKFACTOR1  , int  p_OTHERLATEPICKFACTOR1 ,  string p_name    ,
		int p_timetonextstop , double p_disttonextstop ,  string p_earlystoptime , string  p_latestoptime  ,  double tot_miles , int  tot_driv_time  , string  p_etd  , int  last_dep_time , int last_arr_time ,int last_amb_occ , int  last_wc_occ , string  p_spl_other_desc ,
		int  OffLoaded   ,string  p_trip_type ,   int  p_prev_perf_time ,   int p_prev_stop_num ,  int p_latency   ,  int s_trip_appt_time , int p_grp_cnt_amb ,
		int  p_grp_cnt_wc, string ignorepu, string IGNORE_DEPOTS_CUTOFF1,string time_zone, string time_zone2, string starttime){


	//  if(DEBUG == 1) gse << "in calc route " << endl;


	int oStp;
	int nStp;
	double nDistance;
	string sTime;
	string blk;
	string f_item;
	int cnt  = 1;
	int cnt2 = 0;
	/* unless specified all times are in minutes */
	int perf_time  = 0;
	int trav_time  = 0;
	int prom_time  = 0;
	int dep_time  = 0;
	int arr_time  = 0;
	double prev_lat  = 0;
	double prev_long = 0;
	string prev_city;
	string prev_stop = "BREAK";
	int LUNCHTRAVELTIME  = 0;
	double a_LUNCHBREAK ;
	/*

5 amb people per minute at a stop
dep_time = arr_time + perf_time + (c)*(60/t)         - c = count at a stop, t = # people/minute
1 wc people off in 2 minutes at a stop
dep_time = arr_time + perf_time + (c)*(60/t)         - c = count at a stop, t = # people/minute
	 */
	double time_per_amb_in_group = 1/5;
	double time_per_wc_in_group = 1/1;
	int earlypickup ;
	int earlydropoff ;
	int latepickup ;
	int stopbeforebreak ;
	string citybeforebreak ;
	string td_travel_date;
	bool ignputime = false;



	ignputime = ignore_pu_time(ignorepu);
	//  if(DEBUG == 1) gse << "1 " << ignorepu << " " << ignputime  << " " << p_return_trip << " " << s_trip_appt_time << endl;
	//  if(DEBUG == 1) gse << " 2 " << trav_time << " " << prom_time << " " <<  last_arr_time << " " <<  p_PROXIMITYFACTOR1 << endl;

	// if(DEBUG == 1) gse << "2 " << p_LUNCHBREAK1 << endl;
	if (p_LUNCHBREAK1 < 0)
	{
		a_LUNCHBREAK = -p_LUNCHBREAK1;
		LUNCHTRAVELTIME = 1;
	}
	else{
		a_LUNCHBREAK = p_LUNCHBREAK1;
		LUNCHTRAVELTIME = 0;
	}

	//  if(DEBUG == 1) gse << "3 " <<p_street_by_street << " " << trav_distance << endl;
	if (p_street_by_street == "T") ///////////////always true because using osrm...
	{

		//  if(DEBUG == 1) gse << "The time zone is " << time_zone << endl;
		trav_time = round(F_GET_TRAVEL_TIME (trav_distance, time_zone, time_zone2));


		trav_time = trav_time + p_latency;

		//if (trav_time == 0)
		//trav_time =1;

		//if (p_stop_num == 999)
		// if(DEBUG == 1) gse << "Travel time " << trav_time << " " << trav_distance << " " << time_zone << " " << p_latency <<endl;

	}

	//  if(DEBUG == 1) gse << " Trav time " << trav_time<<  " " << trav_distance << " " << time_zone<< endl;


	/*else{
      parse_stop_info_2 (p_eta,
                         prev_city,
                         p_citytown,
                         nDistance,
                         trav_time);
						 }*/


	//  if(DEBUG == 1) gse << "4 " << p_prev_stop_num << endl;
	if (p_prev_stop_num ==1 && ignore_depot (p_td_segmentid, p_customer, IGNORE_DEPOTS_CUTOFF1))
	{
		//  if(DEBUG == 1) gse << "ignore depot " << p_prev_stop_num << endl;
		trav_time = 0;
	}

	if(p_perf_time ==0 && p_stop_num >1 &&p_stop_num < (int)to_number(MAXSTOPNUM[0])){/////question for mital should this value come from database?
		if(p_disability.find("WC",0)!= string::npos){
			p_perf_time  = p_WHEELLOAD1;
		}
		else{
			p_perf_time = p_AMBLOAD1;
		}
	}

	// if(DEBUG == 1) gse << "5 in calculator " << p_promised_time << " perf time " << p_perf_time<< " disability " <<p_disability<<  endl;


	prom_time = itms_to_minutes (ampm2fullhrs (p_promised_time));
	perf_time = p_perf_time;
	dep_time = prom_time;


	// if(DEBUG == 1) gse << "perf_time 1 " << perf_time << endl;
	// if(DEBUG == 1) gse << "6 " << p_stop_num << endl;
	if (p_stop_num == 1)
	{
		dep_time = dep_time + p_early_morning_factor;
	}

	// if(DEBUG == 1) gse << "7 " << p_stop_num << " " << p_td_segmentid<< endl;

	//  if(DEBUG == 1) gse << " i am here and p_td_segmentidint " << p_td_segmentid << " " << p_td_segmentid.length() << endl;

	int p_td_segmentidint = (int)to_number((p_td_segmentid.substr(1,p_td_segmentid.length())));

	// if(DEBUG == 1) gse << "8 " << p_stop_num << " " << p_td_segmentidint<< endl;
	// if(DEBUG == 1) gse << "8 " << p_amb_occ << " " << last_amb_occ << " " << p_wc_occ << " " << last_wc_occ << " stoptype " << p_stop_type << endl;

	// if(DEBUG == 1) gse << "segment " << p_td_segmentidint << " " << p_stop_num << " " << p_eta << " " << trav_distance << "  " << trav_time << endl;

	if (p_td_segmentidint >= 5000 || (p_stop_num > 1 && p_stop_num < (int)to_number(MAXSTOPNUM[0])))
	{
		// if(DEBUG == 1) gse << " entering the loop " << endl;

		p_wc_occ = 0;
		p_amb_occ = 0;

		// if(DEBUG == 1) gse << "8b " << p_grp_cnt_wc << " " << p_grp_cnt_amb << " " << p_esc <<endl;

		if(p_disability.find("WC",0)!= string::npos)
		{
			if (p_stop_type == "P")
			{
				if (p_grp_cnt_wc > 0)
				{
					p_wc_occ = last_wc_occ + (p_grp_cnt_wc);
				}
				else{
					p_wc_occ = last_wc_occ + 1;
				}
			}
			else{
				if (p_grp_cnt_wc > 0)
				{
					p_wc_occ = last_wc_occ - (p_grp_cnt_wc);
				}
				else{
					p_wc_occ = last_wc_occ - 1;

				}
			}




			if (trav_time == 0 && (prom_time - last_arr_time < p_PROXIMITYFACTOR1  || ( p_customer == "ESSTS"  && p_trip_type.substr(0, 2) == "ES"  && prom_time == 540)  || (    p_customer == "ESSTS"  && p_trip_type.substr(0, 2) == "EA"  && prom_time == 540)) )
			{


				if (p_prev_stop_num > 1)
				{
					if (p_customer == ("CATOC"))
					{
						perf_time = p_perf_time;
						p_prev_perf_time = perf_time;
					}
					else{
						perf_time = floor(p_prev_perf_time / 2);
						p_prev_perf_time = perf_time;
						p_perf_time = perf_time;
					}

				}
			}
			else{
				OffLoaded = 0;
			}



			if (p_stop_type == "P")
			{
				p_amb_occ = last_amb_occ + p_grp_cnt_amb + p_esc;
				// if(DEBUG == 1) gse << "amb is 6 " << p_amb_occ << endl;
			}
			else{
				p_amb_occ = last_amb_occ - p_grp_cnt_amb - p_esc;
				// if(DEBUG == 1) gse << "amb is 5 " << p_amb_occ << endl;
			}
		}

		else{ //no wheel chair
			if (p_stop_type =="P")
			{
				if (p_grp_cnt_amb > 0)
				{
					p_amb_occ = last_amb_occ + p_esc + p_grp_cnt_amb;
					// if(DEBUG == 1) gse << "amb is 4 " << p_amb_occ << endl;
				}
				else{
					p_amb_occ = last_amb_occ + 1 + p_esc;
					// if(DEBUG == 1) gse << "amb  " << p_amb_occ << " " <<  p_esc << endl;
				}
			}

			else{
				if (p_grp_cnt_amb > 0)
				{
					p_amb_occ = last_amb_occ - (p_esc + p_grp_cnt_amb);
					// if(DEBUG == 1) gse << "amb is 2 " << p_amb_occ << endl;
				}
				else{
					p_amb_occ = last_amb_occ - (1 + p_esc);
					// if(DEBUG == 1) gse << "amb is 1 " << p_amb_occ << endl;
				}

			}



			if (trav_time == 0 && (prom_time - last_arr_time < p_PROXIMITYFACTOR1 ||   ( p_customer == "ESSTS"  && p_trip_type.substr(0, 2) == "ES"  && prom_time == 540)  || (    p_customer == "ESSTS"  && p_trip_type.substr(0, 2) == "EA"  && prom_time == 540) ))
			{

				if (p_prev_stop_num > 1)
				{
					perf_time = floor (p_prev_perf_time / 2);
					p_prev_perf_time = perf_time;
					p_perf_time = perf_time;
				}

			}
			else{
				OffLoaded = 0;
			}


			if (p_stop_type == "P")
			{
				p_wc_occ = last_wc_occ + p_grp_cnt_wc;
			}
			else{
				p_wc_occ = last_wc_occ - p_grp_cnt_wc;
			};
		}

		// if(DEBUG == 1) gse << "9 " << p_amb_occ << " " <<  p_wc_occ<< endl;

		if ((p_spl_other_desc.substr(0, 2) =="LP") || CheckifBreak2 (p_spl_other_desc, p_trip_type))
		{


			if (p_trip_type.find("DYC",0) >= 0 || p_trip_type.find("VNA",0) >= 0 || p_trip_type.find("DMR",0) >= 0 || (p_spl_other_desc.substr(0, 2) == "LP") && p_customer == "MART")
			{
				perf_time = 6;
			}
			else{
				perf_time = 0;

			}

			//////changing to last amb and wc instead of 0 -- shayna
			p_amb_occ = last_amb_occ;
			p_wc_occ = last_wc_occ;
			// if(DEBUG == 1) gse << " after setting 1 " <<  p_amb_occ << endl;
		}

		if (p_trip_type == "FIXED")
		{     /* if the stop is part of a fixed route eta = promised_time */
			p_eta = itms_to_minutes (ampm2fullhrs (p_promised_time));
			p_etd = itms_to_minutes (ampm2fullhrs (p_promised_time));


			p_timetonextstop = trav_time;
			p_disttonextstop = trav_distance;
			p_earlystoptime = itms_minutes_to_ampm (prom_time);
			p_latestoptime = itms_minutes_to_ampm (prom_time);
			tot_miles = tot_miles + p_disttonextstop;
			tot_driv_time = tot_driv_time + p_timetonextstop;

			dep_time = itms_to_minutes (ampm2fullhrs (p_etd));
			arr_time = itms_to_minutes (ampm2fullhrs (p_eta));

		}
		else{
			//  if(DEBUG == 1) gse << "stop num " <<p_stop_num << " " <<p_spl_other_desc << " " << p_stop_type <<endl;// << " prox " << p_PROXIMITYFACTOR1  << endl;
			if (trav_time == 0 && (prom_time - last_arr_time < p_PROXIMITYFACTOR1 ||  ( p_customer == "ESSTS"  && p_trip_type.substr(0, 2) == "ES"  && prom_time == 540)  || (    p_customer == "ESSTS"  && p_trip_type.substr(0, 2) == "EA"  && prom_time == 540)))
			{

				arr_time = last_arr_time; ///changed from last_dep_time
				// if(DEBUG == 1) gse << "1 arr" << arr_time << " " << last_arr_time << endl;
			}
			else{
				if(act_arr_time != "0000"){
					arr_time = (int)to_number(act_arr_time);
					//  if(DEBUG == 1) gse << "4 arr" << act_arr_time << " " << trav_time <<  endl;
				}
				else{
					if (p_stop_type == "D" && p_spl_other_desc.substr(0, 2) == "LP")
					{

						arr_time = prom_time;
						// if(DEBUG == 1) gse << "2 printing arr " << arr_time<< endl;
					}
					else{

						arr_time = last_dep_time + trav_time;
						//  if(DEBUG == 1) gse << "3 arr" << last_dep_time << " " << trav_time <<  endl;

					}
				}
			}


			if (p_spl_other_desc.find("OT",0) >= 0)
			{
				if (p_return_trip == "Y")
				{
					earlypickup = p_OTHEREARLYPICKFACTOR1 ; // -1 removed 3/16/2018
					earlydropoff = p_DIALRIDELATEPICKFACTOR1;
					latepickup = p_OTHERLATEPICKFACTOR1;}
				else{
					earlypickup = p_DIALRIDEEARLYPICKFACTOR1 ;// -1 removed 3/16/2018
					earlydropoff = p_MAXEARLYDROPOFFFACTOR1;
					latepickup = p_DIALRIDELATEPICKFACTOR1;}
			}
			else if (p_spl_other_desc.substr(0, 2) == "LP" || CheckifBreak2 (p_spl_other_desc, p_trip_type))
			{
				earlypickup = 0;
				earlydropoff = 0;
				latepickup = 0;
			}
			else{
				earlypickup = p_DIALRIDEEARLYPICKFACTOR1;// -1 removed 3/16/2018
				earlydropoff = p_MAXEARLYDROPOFFFACTOR1;

			}



			if ((p_customer =="ESSTS" && p_trip_type.substr(0, 2) == "ES"  && p_promised_time == "0900A")  || (    p_customer == "ESSTS" && p_trip_type.substr(0, 2) == "EA" && p_promised_time == "0900A"))
			{

				earlydropoff = 0;
				earlypickup = 0;
				latepickup = 0;
			}

			if (CheckifBreak2 (p_spl_other_desc, p_trip_type))
			{
				if (p_stop_type == "P")
				{


					if (p_customer != "ESSTS" &&  LUNCHTRAVELTIME == 0)
					{
						arr_time = last_dep_time;
					}

					stopbeforebreak = oStp;
					citybeforebreak = prev_city;
				}
				else{
					if (p_name == "BREAK")
					{
						arr_time = last_dep_time + p_SHORTBREAK1;
					}
					else if (p_name == "ADMIN")
					{
						arr_time = prom_time;
					}
					else{

						arr_time = last_dep_time + a_LUNCHBREAK;
					}

				}
			}

			/*int p_td_segmentidint;
string temp ((p_td_segmentid.substr(0,p_td_segmentid.length())));
stringstream tempss(temp);
tempss >> p_td_segmentidint;*/

			if ((p_customer == "HLT" && (p_td_segmentidint >= 5000))
					|| (p_customer == "ESSTS"
							&& (p_spl_other_desc == "MANMHS" ||p_td_segmentidint >= 5300)))
			{

				if (p_stop_num == (int)to_number(MAXSTOPNUM[0]))
				{
					arr_time = last_dep_time;
				}
				else if (p_stop_num == 1){
					arr_time = last_dep_time;
				}

			}

			//  if(DEBUG == 1) gse << p_stop_num << " " << p_stop_type << endl;
			// if(DEBUG == 1) gse << "stop type 2 " <<p_stop_type2 << endl;
			if (p_stop_type== "P")
			{


				//  if(DEBUG == 1) gse << p_stop_num << " " << p_spl_other_desc <<endl;
				if (CheckifBreak2 (p_spl_other_desc, p_trip_type) || p_spl_other_desc.substr(0, 2) == "LP")/////////note
				{
					if (arr_time > prom_time)
					{
						dep_time = arr_time;
						if(DEBUG == 1) gse <<" perf_time 8 " << perf_time << endl;
					}
					else{
						dep_time = prom_time;
						if(DEBUG == 1) gse << p_stop_num <<" perf_time 7" << perf_time << " " << dep_time << endl;
					}
				}
				else{
					if(act_dep_time != "0000"){
						dep_time = (int)to_number(act_dep_time);
						if(DEBUG == 1) gse <<" perf_time  actual time 9 " << perf_time << endl;
					}
					else{
						if (p_stop_num == 1)
						{
							dep_time = arr_time;
							if(DEBUG == 1) gse << "perf_time 9" << perf_time << endl;
						}
						else  if ((prom_time == 0 || ( p_return_trip != "Y"  && ignputime && s_trip_appt_time != 0))    && p_stop_num > 1 && p_stop_num < (int)to_number(MAXSTOPNUM[0])  && p_spl_other_desc.substr(0, 2) != "LP")
						{
							if (trav_time == 0)
							{
								dep_time = last_dep_time + perf_time;
								if(DEBUG == 1) gse << "perf_time 6" << perf_time << endl;
							}
							else{
								dep_time= arr_time + perf_time;
								if(DEBUG == 1) gse << "perf_time 5 " << perf_time << endl;
							}

						}
						else {
							if (trav_time == 0 && prom_time - last_arr_time < p_PROXIMITYFACTOR1)
							{
								dep_time = last_dep_time + perf_time;
								if(DEBUG == 1) gse << "perf_time 4 " << perf_time << " prox " << p_PROXIMITYFACTOR1 <<  endl;
							}
							else if ((arr_time + perf_time) > (prom_time - earlypickup))
							{
								dep_time = arr_time + perf_time;
								if(DEBUG == 1) gse << "perf_time 12 " << perf_time << endl;
							}
							else{
								dep_time = (prom_time - earlypickup) + perf_time; //3/16/2018 --SJ
								//dep_time = prom_time + perf_time;
								if(DEBUG == 1) gse << "perf_time 2 " << prom_time << " " << perf_time<< " early " << earlypickup<< endl;
							}
						}
					}

					p_timetonextstop = trav_time;
					p_disttonextstop = trav_distance;

					p_earlystoptime = itms_minutes_to_ampm (prom_time);

					p_latestoptime = itms_minutes_to_ampm (prom_time + latepickup);
					tot_miles = tot_miles + p_disttonextstop;
					tot_driv_time = tot_driv_time + p_timetonextstop;




				}

			}

			else{
				if (p_stop_num == (int)to_number(MAXSTOPNUM[0]))
				{
					if (trav_time == 0)
					{
						dep_time = last_dep_time;
					}
					else{
						dep_time = arr_time;
					}
				}
				else if (CheckifBreak2 (p_spl_other_desc, p_trip_type))
				{
					dep_time = arr_time;
					// if(DEBUG == 1) gse <<" perf_time 10 " << perf_time << endl;
				}
				else{
					if(act_dep_time != "0000"){
						dep_time = (int)to_number(act_dep_time);
						// if(DEBUG == 1) gse <<" perf_time  actual time 11 " << perf_time << endl;
					}
					else{
						if (prom_time == 0)
						{
							if (trav_time == 0)
							{
								dep_time = last_dep_time + perf_time;
								//   if(DEBUG == 1) gse << "perf_time 10" << perf_time << endl;
							}
							else{
								dep_time = arr_time + perf_time;
								//  if(DEBUG == 1) gse << "perf_time 11" << perf_time << endl;
							}
						}
						else {
							if (trav_time == 0 && prom_time - last_arr_time < p_PROXIMITYFACTOR1)
							{
								dep_time = last_dep_time + perf_time;
								//   if(DEBUG == 1) gse << "perf_time 12" << perf_time << endl;
							}
							else if ((arr_time + perf_time) > (prom_time - earlydropoff))
							{
								dep_time = arr_time + perf_time;
								//  if(DEBUG == 1) gse << "perf_time 13" << perf_time << endl;
							}
							else{
								dep_time = prom_time - earlydropoff + perf_time;
								//  if(DEBUG == 1) gse << "perf_time 14 " << prom_time << " "  << earlydropoff << " " <<perf_time <<  endl;

							}
						}
					}

					p_timetonextstop = trav_time;

					p_disttonextstop = trav_distance;

					if (prom_time == 0)
					{
						p_earlystoptime = itms_minutes_to_ampm (prom_time);
					}
					else{
						p_earlystoptime =
								itms_minutes_to_ampm (prom_time - earlydropoff);
					}


					p_latestoptime = itms_minutes_to_ampm (prom_time);
					tot_miles = tot_miles + p_disttonextstop;
					tot_driv_time = tot_driv_time + p_timetonextstop;
				}

			} /* if the stop is part of a fixed route eta = promised_time */


		}



		p_eta = itms_minutes_to_ampm (arr_time);
		p_etd = itms_minutes_to_ampm (dep_time);
		// if(DEBUG == 1) gse <<  p_stop_num << " "  << arr_time <<  " dep_time " << dep_time << endl;

		if (p_stop_num == 1)
		{
			p_amb_occ = 0;
			p_wc_occ = 0;
			//  if(DEBUG == 1) gse << " after setting 2 " <<  p_amb_occ << endl;
		}
		else if (p_stop_num ==(int)to_number(MAXSTOPNUM[0])){

			p_amb_occ = 0;
			p_wc_occ = 0;
		}


	}



	else{
		//  if(DEBUG == 1) gse << "10 " << last_arr_time << endl;
		// if(DEBUG == 1) gse << " here " << p_stop_num <<endl;
		if (p_stop_num == 1)
		{

			arr_time = last_arr_time;
			// arr_time = last_arr_time+trav_time;
			dep_time = arr_time;

			//dep_time = arr_time + perf_time;
			p_amb_occ = 0;
			p_wc_occ = 0;
			p_eta = itms_minutes_to_ampm (arr_time);
			p_etd = itms_minutes_to_ampm (dep_time);

		}
		//}
		//}
		else if (p_stop_num == (int)to_number(MAXSTOPNUM[0]))
		{
			arr_time = last_dep_time +trav_time;
			dep_time = arr_time;
			p_amb_occ = 0;
			p_wc_occ = 0;
			p_eta = itms_minutes_to_ampm (arr_time);
			p_etd = itms_minutes_to_ampm (dep_time);
			// if(DEBUG == 1) gse << "am i here " << arr_time << " " << last_dep_time <<endl;
		}


		p_earlystoptime = p_eta;
		p_latestoptime = p_etd;
	}
	if (act_arr_time == "0000" ){
		last_dep_time = dep_time;
		last_arr_time = arr_time;
	}
	else{
		last_dep_time = (int)to_number(act_dep_time);
		last_arr_time = (int)to_number(act_arr_time);
	}
	last_amb_occ = p_amb_occ;
	last_wc_occ = p_wc_occ;
	prev_city = p_citytown;
	p_prev_stop_num = p_stop_num;

	// if(DEBUG == 1) gse << " FINAL Pambocc with stop  " <<  p_stop_num << " " << p_amb_occ << endl;


	//p_disttonextstop = trav_distance;



	p_timetonextstop = trav_time;

	// if(DEBUG == 1) gse << "checking travtime " << p_timetonextstop << endl;



	// if(DEBUG == 1) gse << "11 " << "arr "  << arr_time << " segment id " << p_td_segmentidint << " peta " << p_eta << " etd " << p_etd <<" dep " << dep_time << endl;
	//" lamb" << last_amb_occ<< " lwc " << last_wc_occ << " prevcity "  << prev_city << " pstopnum " << p_prev_stop_num << endl;

	// if(DEBUG == 1) gse << " FINAL  dist " << p_disttonextstop << " travtime " << p_timetonextstop << " ldep" << last_dep_time << " larr" <<last_arr_time <<endl;

	std::tuple<string,int,int,int,int,double,string,string,double,int,string,int,int> returnVar(p_eta,
			p_wc_occ, p_amb_occ,p_esc,p_timetonextstop,trav_distance,p_earlystoptime, p_latestoptime,tot_miles,tot_driv_time, p_etd, OffLoaded,perf_time);


	return returnVar;

}





#include <boost/config.hpp> /* keep it first to prevent nasty warns in MSVC */
#include <algorithm>
#include <boost/algorithm/string/find.hpp>
#include <boost/interprocess/allocators/allocator.hpp>
#include <boost/interprocess/containers/string.hpp>
#include <boost/interprocess/managed_mapped_file.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>
#include <boost/interprocess/sync/scoped_lock.hpp>
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/member.hpp>
#include <iostream>
#include <iterator>
#include <sstream>
#include <tuple>
#include <string>


void Convert(std::string& str, std::string& upperStr)
{
	for(short i = 0; i < str.size(); ++i)
		upperStr += toupper(str[i]);
}



/*const int MAXSTOPS = 200;
const int MAXSEGMENTS = 2000;
const int MAXTRIPIDX = 2000;
const int MAXTIMESLOTS = 96;
const int MAXCLUSTERS = 20000;
const int MAXTC_COLUMNSIZE = 500;
const int MAXTS_COLUMNSIZE = 200;
const int TREESIZE = 200000;
const int TRIPCOLSIZE = 200;
const int MAXLGSTRSIZE = 2000;*/





void slack_calc(int i, char (*schd_tab)[TRIPCOLSIZE][MAXLGSTRSIZE]){

	int slack = ((int)to_number(schd_tab[i][4]) - (int)to_number(schd_tab[i][29]));

	if (slack > 0){
		strcpy(schd_tab[i-1][40], to_string(slack).c_str());
		// if(DEBUG == 1) gse << "The slack is " << slack << " for  " << schd_tab[i][0] << endl;
	}

}


//MP: Function InsertTrip. What does this function do ?
//    If the trip is in the slack array then it returns the index of the trip (same as tripidx)
//    if the trip is not in the slack array then add the tripidx to the slack array

int insertTrip(int timeslot, int clusterid, int tripidx, int isslack){

	int tempidx = ts_tab[timeslot][clusterid][isslack][0];
	int tripfound = 0;

	if(tempidx + 1 >= MAXTC_COLUMNSIZE){
		if(DEBUG == 1) gse << "Too many inserts into the same timeslot and cluster" << endl;
		return 0;
	}

	//MP: tempidx is the count of trips that have Slack ?
	//    Is the loop to check if the trip already exists in the slack array

	for(int k = 1; k <= (tempidx); k++){

		if(ts_tab[timeslot][clusterid][isslack][k] == tripidx){
			tripfound = k;
			break;
		}

	}

	//MP: If the trip is not in the slack (ts[][]) then add it to the array
	//
	if(tripfound == 0){

		/*for(int i = 0; i < ts_tab[timeslot][clusterid][0]; i++){

                                tempidx[i] = ts_tab[timeslot][clusterid][i+2];
                                ts_tab[timeslot][clusterid][i+1] = ts_tab[timeslot][clusterid][i];
                                tempidx[i+1] = ts_tab[timeslot][clusterid][i+2];
                                ts_tab[timeslot][clusterid][i+2] = tempidx[i+1];

                         }*/
		//MP: If trip was not in the slack. Increment the previous counter for the timeslot and clusterId by 1
		//    Add the tripIdx at the new counter
		//    Return the new count

		ts_tab[timeslot][clusterid][isslack][0] = ts_tab[timeslot][clusterid][isslack][0]+1;
		ts_tab[timeslot][clusterid][isslack][ts_tab[timeslot][clusterid][isslack][0]] = tripidx;
		tripfound = ts_tab[timeslot][clusterid][isslack][0];


		//  if(DEBUG == 1) gse << timeslot << " " << clusterid << " " << tripidx <<endl;
	}

	return tripfound;
}


void insertGroupTrips(int timeslot, int cluster, int tripidx, int routeidx, bool firstPassOfSlack){

	if(DEBUG == 1) gse << "in insert groups" << endl;
	int attemptstraightlinecnt = 1;
	int attemptstraightline[MAXTRIPIDX];

	attemptstraightline[0] = tripidx;

	int addextracnt = 1;


	for(int q = 1; q < MAXTRIPIDX; q++){


		if(strcmp(schd_tab[q][10],"")==0)
			break;


		if(strcmp(schd_tab[q][7],"D")==0 && strcmp(schd_tab[q][0],"")==0 ){

			int doid = q;
			int puid = (int)to_number(schd_tab[q][PICKUPIDX]);

			if(strcmp(schd_tab[puid][41],schd_tab[attemptstraightline[0]][41])==0  && puid != attemptstraightline[0]  && strcmp(schd_tab[puid][0],"")==0){

				if(DEBUG == 1) gse << "We found a possible trip" << endl;


				for (int h = 0; h < attemptstraightlinecnt; h++)
				{

					bool foundamatchneighborgroup = false;
					bool foundamatchneighborgroupdo = false;




					if(strcmp(schd_tab[attemptstraightline[h]][7],"P")==0 && strcmp(schd_tab[attemptstraightline[h]][41],schd_tab[puid][41])==0 && strcmp(schd_tab[puid][0],"")==0){

						if(DEBUG == 1) gse << "Starting to search the clusters " <<endl;


						string neighborclusterspu = schd_tab[attemptstraightline[h]][NEIGHBORS];
						if(DEBUG == 1) gse << "The pick up neighbors " << neighborclusterspu << endl;
						while (neighborclusterspu != "")
						{

							if(strcmp(schd_tab[attemptstraightline[h]][3], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][3]) ==0){
								break;
							}

							string cidpu = getNextToken(&(neighborclusterspu), ",");

							//int t1 = ((int)to_number(schd_tab[h][4]))/15;
							//int t2 = ((int)to_number(schd_tab[h+1][4]))/15;
							int timeslot1 = ((int)to_number(schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][41]));

							if (/*(timeslot >= (t1 - 2) && timeslot <= (t2 +2 ))*/ /*timeslot >= m-2 && timeslot <= m+2*/ strcmp(schd_tab[attemptstraightline[h]][3], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][3]) != 0  && (strcmp(cidpu.c_str(), schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][42]) == 0 || strcmp(schd_tab[attemptstraightline[h]][42], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][42]) == 0 || (strcmp(schd_tab[attemptstraightline[h]][17], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][17]) == 0&& strcmp(schd_tab[attemptstraightline[h]][17], "") != 0)))
							{
								//   if(DEBUG == 1) gse << "hit a match in the group P " << t1 << " " << t2 << " " <<schd_tab[straightlinetrip][3] << " " << timeslot << " " << schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][3]<< endl;
								if(DEBUG == 1) gse << "Same pickup cluster " << endl;
								foundamatchneighborgroup = true;
								break;
							}
						}
						if(!foundamatchneighborgroup){
							continue;
						}


						bool isSameStopLocation  = false;



						for (int h = 0; h < attemptstraightlinecnt; h++)
						{



							string neighborclustersdo = schd_tab[attemptstraightline[h]+1][NEIGHBORS];
							if(DEBUG == 1) gse << "The drop off neighbors " << neighborclustersdo << endl;

							while (neighborclustersdo != "")
							{

								if(strcmp(schd_tab[attemptstraightline[h]][3], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][3]) ==0){
									break;
								}
								string ciddo = getNextToken(&(neighborclustersdo), ",");

								//   if(DEBUG == 1) gse << "Looping through group " << schd_tab[grouptriparr[h]][3] << " " << ciddo << " " << schd_tab[(ts_tab[m][k][UNASSIGNED][u] + 1)][42] << endl;
								if (strcmp(schd_tab[attemptstraightline[h]][3], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][3]) != 0 && (strcmp(ciddo.c_str(), schd_tab[doid][42]) == 0 || strcmp(schd_tab[attemptstraightline[h]+1][42], schd_tab[doid][42]) == 0||(strcmp(schd_tab[attemptstraightline[h]][17], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][17]) == 0&& strcmp(schd_tab[attemptstraightline[h]][17], "") != 0)))
								{
									if(DEBUG == 1) gse << "Same dropoff cluster " << endl;
									//  if(DEBUG == 1) gse << "hit a match in the group D " << endl;
									foundamatchneighborgroupdo = true;
									if((strcmp(schd_tab[attemptstraightline[h]][17], schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][17]) == 0 && strcmp(schd_tab[attemptstraightline[h]][17], "") != 0)|| (isSameLocation(attemptstraightline[h]+1,doid) && isSameLocation(attemptstraightline[h],(int)to_number(schd_tab[doid][PICKUPIDX]))) || (firstPassOfSlack  && isSameLocation(attemptstraightline[h],(int)to_number(schd_tab[doid][PICKUPIDX])))){
										isSameStopLocation = true;
									}
									break;
								}

							}
							if(!foundamatchneighborgroupdo){
								continue;
							}

						}


						if (foundamatchneighborgroupdo && foundamatchneighborgroup)
						{

							if(DEBUG == 1) gse << "Attempting to insert" << endl;


							for (int j = 0; j <  attemptstraightlinecnt; j++)
							{
								if (attemptstraightline[j] == (int)to_number(schd_tab[doid][PICKUPIDX]))
								{
									break;
								}
								else if (j+1 == attemptstraightlinecnt)
								{

									bool skiproute = true;

									if( addextracnt < (int)to_number(schd_tab[routeidx][33]))
										skiproute = skipsegment((int)to_number(schd_tab[doid][PICKUPIDX]), schd_tab[routeidx][0]);



									if (skiproute && !isSameStopLocation)
									{
										if(DEBUG == 1) gse << "Skipping route ... SAME CLUSTER " << schd_tab[routeidx][0] << " for trip " << schd_tab[doid][3] << endl;
										break;
									}

									if(DEBUG == 1) gse << "v2 Also found and inserting grouped trip because of same pickup/neighboring cluster route : " << schd_tab[doid][0] << " tripid :  "  << schd_tab[doid][3] << " " << timeslot  << " " << timeslot  <<  " " << schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][41] << endl;
									attemptstraightline[attemptstraightlinecnt] = (int)to_number(schd_tab[doid][PICKUPIDX]);
									attemptstraightlinecnt++;
									insertTrip(timeslot, cluster, (int)to_number(schd_tab[doid][PICKUPIDX]), UNASSIGNED);
									h = -1;
									addextracnt++;
									break;
								}
								else if(isSameStopLocation){
									if(DEBUG == 1) gse << "v2 Also found and inserting grouped trip because of same pickup/neighboring cluster route and same lat long : " << schd_tab[doid][0] << " tripid :  "  << schd_tab[doid][3] << " "  <<timeslot  <<  " " << schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][41] << endl;
									attemptstraightline[attemptstraightlinecnt] = (int)to_number(schd_tab[doid][PICKUPIDX]);
									attemptstraightlinecnt++;
									insertTrip(timeslot, cluster, (int)to_number(schd_tab[doid][PICKUPIDX]), UNASSIGNED);
									h = -1;
									addextracnt++;
									break;
								}


							}

							break;
						}

						// break;
						//}

						/*if(triedPreviously){
                                                            // if(DEBUG == 1) gse << "We already tried this trip in this slack  " << schd_tab[doid][3] <<  endl;
                                                            break;
                                                        }
                                                        if (skiproute)
                                                        {
                                                            break;
                                                            }*/
					}
					//break;
					//}

					if(foundamatchneighborgroup){
						break;
					}
				}
			}
		}
	}
}






/* Function to print an array */
void printArray( int size, int m, int k)
{
	int i;
	if(DEBUG == 1) gse << "Size " << size << endl;
	for (i=0; i < size; i++)
		if(DEBUG == 1) gse << ts_tab[m][k][SLACK][i] << " (" <<(schd_tab[ts_tab[m][k][SLACK][i]][21]) << ")  " ;
	if(DEBUG == 1) gse << endl;
	//printf("n");
}

/*void swap(int *xp, int *yp)
{
    int temp = *xp;
 *xp = *yp;
 *yp = temp;
}

// A function to implement bubble sort
void bubbleSort(int n, int m, int k, int isslack)
{
   int i, j;
   int temp;

   for (i = 0; i < n-1; i++)    {

       // Last i elements are already in place
       for (j = 0; j < n-i-1; j++) {


           // if(DEBUG == 1) gse << ts_tab[m][k][j] << " " << j << " Dist " << to_number(schd_tab[ts_tab[m][k][j]][21]) << endl;
           if (to_number(schd_tab[ts_tab[m][k][isslack][j]][21]) < to_number(schd_tab[ts_tab[m][k][isslack][j+1]][21])){
                    temp = ts_tab[m][k][isslack][j];
                    ts_tab[m][k][isslack][j] = ts_tab[m][k][isslack][j+1];
                    ts_tab[m][k][isslack][j+1] = temp;

       }
   }



}

 //printArray(n, m, k);
}*/



#include <unistd.h>
#include <vector>
/* Binary Tree */
#include <string.h>
#include <bits/stdc++.h>
#include <tuple>
#include <occi.h>
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/register/point.hpp>
#include <boost/geometry/geometries/register/ring.hpp>
#include <boost/geometry/geometries/point_xy.hpp>
#include <boost/geometry/geometries/polygon.hpp>

namespace bg = boost::geometry;
struct my_point {double x, y;};
BOOST_GEOMETRY_REGISTER_POINT_2D(my_point,double,bg::cs::spherical_equatorial<degree>,x,y)
BOOST_GEOMETRY_REGISTER_RING(std::vector<my_point>)
typedef boost::geometry::model::d2::point_xy<double> point_type;
typedef bg::model::polygon<point_type> polygon_type;




void create_group(int local_s_tab[], int counter){

	int grpmarker = 0;
	string tempstring;
	for (int i = 1; i < MAXTRIPIDX; i++)
	{ //find the largest group marker currently in the trip table
		if (strcmp(schd_tab[i][GRPIDX], "") != 0)
		{
			tempstring = schd_tab[i][GRPIDX];
			int tempgrpmarker = (int)to_number(getNextToken(&tempstring, "^"));
			if (grpmarker <= tempgrpmarker)
			{
				grpmarker = tempgrpmarker;
			}
		}
	}


	grpmarker++;
	if(DEBUG == 1) gse << "The marker is " << grpmarker << endl;
	for(int i = 0; i < counter; i++){

		if(strcmp("", schd_tab[local_s_tab[i]][GRPIDX])==0 && strcmp(schd_tab[local_s_tab[i]][0], schd_tab[local_s_tab[i]][3])!=0 ){

			for(int c = 0; c < counter;c++){
				if(local_s_tab[i] == 0)
					break;
				if(strcmp(schd_tab[local_s_tab[i]][3], schd_tab[local_s_tab[c]][3])==0 && strcmp("D", schd_tab[local_s_tab[c]][7])==0 && strcmp(schd_tab[local_s_tab[i]][0], schd_tab[local_s_tab[i]][3])!=0  && strcmp("", schd_tab[local_s_tab[i]][GRPIDX])==0){

					int precheck = 0;
					for(int z = 0; z < counter;z++){
						if(strcmp(schd_tab[local_s_tab[z]][3], schd_tab[local_s_tab[c]][3])==0 && strcmp("P", schd_tab[local_s_tab[z]][7])==0){
							precheck++;
						}
						if(strcmp(schd_tab[local_s_tab[z]][3], schd_tab[local_s_tab[c]][3])==0 && strcmp("D", schd_tab[local_s_tab[z]][7])==0){
							precheck++;
						}
						if(precheck == 2){
							break;
						}
					}


					if(precheck == 2){

						int grouppickupcnt = 0;
						int temptravelarray[MAXSTOPS];
						int temptravelarraystopnumber[MAXSTOPS];
						int temptravarraycnt = 0;
						int current = c;
						while(c-1 >= 1 && strcmp("D", schd_tab[local_s_tab[c-1]][7])==0 && strcmp(schd_tab[local_s_tab[c-1]][0], schd_tab[local_s_tab[c-1]][3])!=0){

							int checkcnt = 0;

							for(int z = 0; z < counter;z++){
								if(strcmp(schd_tab[local_s_tab[z]][3], schd_tab[local_s_tab[c-1]][3])==0 && strcmp("P", schd_tab[local_s_tab[z]][7])==0){
									checkcnt++;
								}
								if(strcmp(schd_tab[local_s_tab[z]][3], schd_tab[local_s_tab[c-1]][3])==0 && strcmp("D", schd_tab[local_s_tab[z]][7])==0){
									checkcnt++;
								}
								if(checkcnt == 2){
									break;
								}
							}

							if(checkcnt == 2){
								temptravelarray[temptravarraycnt] = local_s_tab[c-1];
								temptravarraycnt++;
								temptravelarray[temptravarraycnt] = (int)to_number(schd_tab[local_s_tab[c-1]][PICKUPIDX]);
								temptravarraycnt++;

								//  if(DEBUG == 1) gse << " c 1 " << c-1 << endl;
							}

							c--;
						}
						c = current;
						while(c+1 < counter && strcmp("D", schd_tab[local_s_tab[c+1]][7])==0 && strcmp(schd_tab[local_s_tab[c+1]][0], schd_tab[local_s_tab[c+1]][3])!=0){

							int checkcnt = 0;

							for(int z = 0; z < counter;z++){
								if(strcmp(schd_tab[local_s_tab[z]][3], schd_tab[local_s_tab[c+1]][3])==0 && strcmp("P", schd_tab[local_s_tab[z]][7])==0){
									checkcnt++;
								}
								if(strcmp(schd_tab[local_s_tab[z]][3], schd_tab[local_s_tab[c+1]][3])==0 && strcmp("D", schd_tab[local_s_tab[z]][7])==0){
									checkcnt++;
								}
								if(checkcnt == 2){
									break;
								}
							}

							if(checkcnt == 2){
								temptravelarray[temptravarraycnt] = local_s_tab[c+1];
								temptravarraycnt++;
								temptravelarray[temptravarraycnt] = (int)to_number(schd_tab[local_s_tab[c+1]][PICKUPIDX]);
								temptravarraycnt++;

								//  if(DEBUG == 1) gse << " c 2 " << c+1 << endl;
							}

							c++;


						}

						c = current;


						//  if(DEBUG == 1) gse << "Out of initial " << c <<  endl;

						if(temptravarraycnt > 0){

							temptravelarray[temptravarraycnt] = local_s_tab[c];
							temptravarraycnt++;
							temptravelarray[temptravarraycnt] = (int)to_number(schd_tab[local_s_tab[c]][PICKUPIDX]);
							temptravarraycnt++;



							bool isnotgroup = false;
							int counting = 0;

							for(int e = 0; e < counter; e++){
								if(local_s_tab[e] == 0)
									break;
								for(int t = 0; t < temptravarraycnt; t++){
									if(strcmp(schd_tab[temptravelarray[t]][3], schd_tab[local_s_tab[e]][3])==0 && strcmp(schd_tab[temptravelarray[t]][7], schd_tab[local_s_tab[e]][7])==0){

										for(int r = t; r < temptravarraycnt; r++){

											//  if(DEBUG == 1) gse << "r is "<< r <<  " " << counting << " " << temptravarraycnt << " " << endl;

											if(e == counter) {
												if(DEBUG == 1) gse << "There is something wrong with this group " << endl;
												isnotgroup = true;
												break;
											}

											if(strcmp(schd_tab[temptravelarray[r]][3], schd_tab[local_s_tab[e]][3])==0 && strcmp(schd_tab[temptravelarray[r]][7], schd_tab[local_s_tab[e]][7])==0){
												// if even one instance is in there
												//  if(DEBUG == 1) gse << schd_tab[temptravelarray[r]][3] <<  " " << schd_tab[local_s_tab[e]][3] << endl;
												e++;
												r = -1;
												counting++;

												if(counting == temptravarraycnt){
													if(DEBUG == 1) gse << "it is a consecutive group " << endl;
													grouppickupcnt = temptravarraycnt/2;
													break;

												}
											}


											else if(counting == temptravarraycnt){
												if(DEBUG == 1) gse << "it is a consecutive group " << endl;
												grouppickupcnt = temptravarraycnt/2;
												break;
											}
											else if(r + 1 == temptravarraycnt){
												isnotgroup = true;
												//  if(DEBUG == 1) gse << schd_tab[temptravelarray[r]][3] <<  " " << schd_tab[local_s_tab[e]][3] << " " << r <<  endl;
												if(DEBUG == 1) gse << "not a consecutive group" << endl;
												break;
											}
										}
										break;
									}



								}

								if(isnotgroup){
									break;
								}


							}


							if(!isnotgroup){

								///mark GRPIDX
								if(DEBUG == 1) gse << "Copying " << grpmarker << endl;
								for (int j = 0; j < temptravarraycnt; j++)
								{
									strcpy(schd_tab[temptravelarray[j]][GRPIDX], (to_string(grpmarker) + "^" + to_string(j)).c_str());
								}

								if(DEBUG == 1) gse << "The grpmarker is " << grpmarker << endl;

								grpmarker++;


							}

						}

						break;
					}
				}
			}




		}

	}

	if(DEBUG == 1) gse << "Done creating group " << endl;

	return;
}


void groupsametosame(int doid){

	string tempstring;
	int grpmarker = 0;
	for (int i = 1; i < MAXTRIPIDX; i++)
	{ //find the largest group marker currently in the trip table
		if (strcmp(schd_tab[i][GROUPNUMBER], "") != 0)
		{
			tempstring = schd_tab[i][GROUPNUMBER];
			int tempgrpmarker = (int)to_number(tempstring);
			if (grpmarker <= tempgrpmarker)
			{
				grpmarker = tempgrpmarker;
			}
		}
	}
	grpmarker++;


	for(int g = 1; g < MAXTRIPIDX; g++){
		if(strcmp(schd_tab[g][10],"")==0){
			break;
		}

		if(strcmp(schd_tab[g][7],"D")==0 && strcmp(schd_tab[doid][17],"")==0){
			//  if(DEBUG == 1) gse << "doid is " << g << endl;
			if(isSameLocation((int)to_number(schd_tab[doid][PICKUPIDX]),(int)to_number(schd_tab[g][PICKUPIDX])) && isSameLocation(doid,g) && (int)to_number(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][41]) <= (int)to_number(schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][41])+1 && (int)to_number(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][41]) >= (int)to_number(schd_tab[doid][41])-1 &&   (int)to_number(schd_tab[g][41]) <= (int)to_number(schd_tab[doid][41])+1 && (int)to_number(schd_tab[g][41]) >= (int)to_number(schd_tab[doid][41])-1 && strcmp(schd_tab[doid][7],"D")==0 && strcmp(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][7],"P")==0  && /*strcmp(schd_tab[doid][0],"")==0 && strcmp(schd_tab[j][0],"")==0 &&*/ (int)to_number(schd_tab[doid][PICKUPIDX]) != (int)to_number(schd_tab[g][PICKUPIDX])  && strcmp(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][GROUPNUMBER],"")==0){
				if(DEBUG == 1) gse << "Found a match in grouping " << grpmarker << endl;
				if(strcmp(schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][GROUPNUMBER],"")==0){
					strcpy(schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][GROUPNUMBER],to_string(grpmarker).c_str());
					strcpy(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][GROUPNUMBER],to_string(grpmarker).c_str());
					strcpy(schd_tab[doid][GROUPNUMBER],to_string(grpmarker).c_str());
					strcpy(schd_tab[g][GROUPNUMBER],to_string(grpmarker).c_str());
					grpmarker++;
				}
				else{
					strcpy(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][GROUPNUMBER],schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][GROUPNUMBER]);
					strcpy(schd_tab[g][GROUPNUMBER],schd_tab[doid][GROUPNUMBER]);
				}

			}


		}

		else if(strcmp(schd_tab[g][7],"D")==0 && strcmp(schd_tab[doid][17],"")!=0 && (int)to_number(schd_tab[g][PICKUPIDX]) != (int)to_number(schd_tab[doid][PICKUPIDX])){

			if(strcmp(schd_tab[g][17],schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][17])==0 && strcmp(schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][17],"")!=0){

				if(DEBUG == 1) gse << "Found a match in grouping actual group " << grpmarker << endl;
				if(strcmp(schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][GROUPNUMBER],"")==0){
					strcpy(schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][GROUPNUMBER],to_string(grpmarker).c_str());
					strcpy(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][GROUPNUMBER],to_string(grpmarker).c_str());
					strcpy(schd_tab[doid][GROUPNUMBER],to_string(grpmarker).c_str());
					strcpy(schd_tab[g][GROUPNUMBER],to_string(grpmarker).c_str());
					grpmarker++;
				}
				else{
					strcpy(schd_tab[(int)to_number(schd_tab[g][PICKUPIDX])][GROUPNUMBER],schd_tab[(int)to_number(schd_tab[doid][PICKUPIDX])][GROUPNUMBER]);
					strcpy(schd_tab[g][GROUPNUMBER],schd_tab[doid][GROUPNUMBER]);
				}


			}



		}




	}


	return;

}


bool hasoutboundtrip(string tripid){

	if(DEBUG == 1) gse << "in has outbound trip" << endl;

	int puid = 0;
	int doid = 0;

	for(int j = 1; j < MAXTRIPIDX; j++){

		if(strcmp(schd_tab[j][10],"")==0){
			break;
		}
		if(strcmp(schd_tab[j][3],tripid.c_str())==0 && strcmp(schd_tab[j][7],"P")==0){
			puid = (int)to_number(schd_tab[j][20]);
		}
		else if(strcmp(schd_tab[j][3],tripid.c_str())==0 && strcmp(schd_tab[j][7],"D")==0){
			doid = (int)to_number(schd_tab[j][20]);
		}
	}

	if(puid == 0 || doid == 0){
		if(DEBUG == 1) gse << "Not in shared memory grouping "<< endl;
		return false;
	}



	for(int f = 1; f < MAXTRIPIDX; f++){
		if(strcmp(schd_tab[f][10],"")==0){
			break;
		}
		if(strcmp(schd_tab[f][3],schd_tab[puid][3])!=0 && strcmp(schd_tab[f][7],"P")==0  && strcmp(schd_tab[f][OB_TRIP_ID],schd_tab[puid][3])==0){
			if(DEBUG == 1) gse << "found one" << endl;
			return true;


		}
	}
	return false;

}


bool hasgrouptrip(string tripid){

	if(DEBUG == 1) gse << "in has group trip" << endl;

	int puid = 0;
	int doid = 0;

	for(int j = 1; j < MAXTRIPIDX; j++){

		if(strcmp(schd_tab[j][10],"")==0){
			break;
		}
		if(strcmp(schd_tab[j][3],tripid.c_str())==0 && strcmp(schd_tab[j][7],"P")==0){
			puid = (int)to_number(schd_tab[j][20]);
		}
		else if(strcmp(schd_tab[j][3],tripid.c_str())==0 && strcmp(schd_tab[j][7],"D")==0){
			doid = (int)to_number(schd_tab[j][20]);
		}
	}

	if(puid == 0 || doid == 0){
		if(DEBUG == 1) gse << "Not in shared memory grouping "<< endl;
		return false;
	}



	for(int f = 1; f < MAXTRIPIDX; f++){
		if(strcmp(schd_tab[f][10],"")==0){
			break;
		}
		if(strcmp(schd_tab[f][3],schd_tab[puid][3])!=0 && strcmp(schd_tab[f][7],"P")==0  && strcmp(schd_tab[f][GROUPNUMBER],schd_tab[puid][GROUPNUMBER])==0){
			if(DEBUG == 1) gse << "found one group" << endl;
			return true;


		}
	}

	if(DEBUG == 1) gse << "found none" << endl;
	return false;



}

bool insertandtrygroup_onsegment(string client, string date,string segment,string tripid){

	if(DEBUG == 1) gse << "Trying to insert all inbound and outbound trips " << endl;

	string tripidxarray[MAXSTOPS];
	string tripidxarraysegments[MAXSTOPS];
	int tripidxarraycnt = 0;
	string tripidxarrayindicies[MAXSTOPS];
	int tripidxarrayindiciescnt = 0;
	tripidxarray[tripidxarraycnt] = tripid;
	int temppuid = 0;
	int tempdoid = 0;
	for(int j = 1; j < MAXTRIPIDX; j++){

		if(strcmp(schd_tab[j][10],"")==0){
			break;
		}
		if(strcmp(schd_tab[j][3],tripid.c_str())==0 && strcmp(schd_tab[j][7],"P")==0){
			temppuid = (int)to_number(schd_tab[j][20]);

		}
		if(strcmp(schd_tab[j][3],tripid.c_str())==0 && strcmp(schd_tab[j][7],"D")==0){
			tempdoid = (int)to_number(schd_tab[j][20]);
		}

	}





	double estputime[MAXSTOPS];
	string starttime1 = schd_tab[temppuid][26];
	string endtime1 =  schd_tab[temppuid][27];
	string est_traveltime1 = schd_tab[temppuid][22];
	string p_stop_type = schd_tab[temppuid][7];
	double est_time;
	if(p_stop_type == "P"){
		if((int)to_number(starttime1)!= 0)
			est_time = (int)to_number(starttime1);
		else{
			est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
		}
	}
	else{
		if((int)to_number(endtime1)!= 0)
			est_time = (int)to_number(endtime1);
		else{

			est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
		}
	}


	tripidxarrayindicies[tripidxarrayindiciescnt] = to_string(temppuid);
	estputime[tripidxarraycnt] = est_time;
	tripidxarraycnt++;
	tripidxarrayindiciescnt++;

	starttime1 = schd_tab[tempdoid][26];
	endtime1 =  schd_tab[tempdoid][27];
	est_traveltime1 = schd_tab[tempdoid][22];
	p_stop_type = schd_tab[tempdoid][7];
	est_time; //JDC Is something missing here?
	if(p_stop_type == "P"){
		if((int)to_number(starttime1)!= 0)
			est_time = (int)to_number(starttime1);
		else{
			est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
		}
	}
	else{
		if((int)to_number(endtime1)!= 0)
			est_time = (int)to_number(endtime1);
		else{

			est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
		}
	}



	tripidxarrayindicies[tripidxarrayindiciescnt] = to_string(tempdoid);
	estputime[tripidxarrayindiciescnt] = est_time;
	tripidxarrayindiciescnt++;






	if(DEBUG == 1) gse << "Searching for outbound " << endl;

	for(int z = 0; z < tripidxarraycnt; z++){

		int puid = 0;
		int doid = 0;

		for(int j = 1; j < MAXTRIPIDX; j++){
			if(strcmp(schd_tab[j][3],tripidxarray[z].c_str())==0 && strcmp(schd_tab[j][7],"P")==0){
				puid = (int)to_number(schd_tab[j][20]);
			}
			else if(strcmp(schd_tab[j][3],tripidxarray[z].c_str())==0 && strcmp(schd_tab[j][7],"D")==0){
				doid = (int)to_number(schd_tab[j][20]);
			}
		}

		if(puid == 0 || doid == 0){
			if(DEBUG == 1) gse << "Not in shared memory grouping "<< endl;
			continue;
		}



		for(int f = 1; f < MAXTRIPIDX; f++){
			if(strcmp(schd_tab[f][10],"")==0){
				break;
			}
			if(strcmp(schd_tab[f][0],"")==0 && strcmp(schd_tab[f][3],schd_tab[puid][3])!=0 && strcmp(schd_tab[f][7],"P")==0 && strcmp(schd_tab[f][OB_TRIP_ID],schd_tab[puid][3])==0){

				for(int r = 0; r < tripidxarraycnt; r++){
					if(strcmp(tripidxarray[r].c_str(),schd_tab[f][3])==0){
						break;
					}
					else if (r+1 == tripidxarraycnt){




						tripidxarray[tripidxarraycnt] = schd_tab[f][3];

						tripidxarraycnt++;


						starttime1 = schd_tab[f][26];
						endtime1 =  schd_tab[f][27];
						est_traveltime1 = schd_tab[f][22];
						p_stop_type = schd_tab[f][7];
						est_time; //JDC Is something missing here?

								if((int)to_number(starttime1)!= 0)
									est_time = (int)to_number(starttime1);
								else{
									est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
								}
						tripidxarrayindicies[tripidxarrayindiciescnt] = to_string(f);
						estputime[tripidxarrayindiciescnt] = est_time;
						tripidxarrayindiciescnt++;
						starttime1 = schd_tab[f+1][26];
						endtime1 =  schd_tab[f+1][27];
						est_traveltime1 = schd_tab[f+1][22];
						p_stop_type = schd_tab[f+1][7];

						if((int)to_number(endtime1)!= 0)
							est_time = (int)to_number(endtime1);
						else{

							est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
						}

						tripidxarrayindicies[tripidxarrayindiciescnt] = to_string(f+1);
						estputime[tripidxarrayindiciescnt] = est_time;
						tripidxarrayindiciescnt++;
						break;




					}
				}


			}
		}
	}

	if(DEBUG == 1) gse << "Searching for groups " << endl;

	for(int z = 0; z < tripidxarraycnt; z++){

		int puid = 0;
		int doid = 0;

		for(int j = 1; j < MAXTRIPIDX; j++){

			if(strcmp(schd_tab[j][10],"")==0){
				break;
			}
			if(strcmp(schd_tab[j][3],tripidxarray[z].c_str())==0 && strcmp(schd_tab[j][7],"P")==0){
				puid = (int)to_number(schd_tab[j][20]);
			}
			else if(strcmp(schd_tab[j][3],tripidxarray[z].c_str())==0 && strcmp(schd_tab[j][7],"D")==0){
				doid = (int)to_number(schd_tab[j][20]);
			}
		}

		if(puid == 0 || doid == 0){
			if(DEBUG == 1) gse << "Not in shared memory grouping "<< endl;
			continue;
		}
		for(int i = 1; i < MAXTRIPIDX;i++){
			if(strcmp(schd_tab[i][10],"")==0){
				break;
			}
			if(strcmp(schd_tab[i][0],"")==0 && strcmp(schd_tab[i][3],schd_tab[puid][3])!=0 && strcmp(schd_tab[i][GROUPNUMBER],"")!=0 && strcmp(schd_tab[i][GROUPNUMBER],schd_tab[puid][GROUPNUMBER])==0 && strcmp(schd_tab[i][7],"P")==0 && strcmp(schd_tab[i+1][GROUPNUMBER],"")!=0 && strcmp(schd_tab[i+1][GROUPNUMBER],schd_tab[doid][GROUPNUMBER])==0){

				for(int r = 0; r < tripidxarraycnt; r++){


					if(strcmp(tripidxarray[r].c_str(),schd_tab[i][3])==0){
						break;
					}
					else if (r+1 == tripidxarraycnt){
						tripidxarray[tripidxarraycnt] = schd_tab[i][3];
						tripidxarraycnt++;


						starttime1 = schd_tab[i][26];
						endtime1 =  schd_tab[i][27];
						est_traveltime1 = schd_tab[i][22];
						p_stop_type = schd_tab[i][7];
						est_time;

						if((int)to_number(starttime1)!= 0)
							est_time = (int)to_number(starttime1);
						else{
							est_time =  (int)to_number(endtime1) - (int)to_number(est_traveltime1);
						}
						tripidxarrayindicies[tripidxarrayindiciescnt] = to_string(i);
						estputime[tripidxarrayindiciescnt] = est_time;
						tripidxarrayindiciescnt++;
						starttime1 = schd_tab[i+1][26];
						endtime1 =  schd_tab[i+1][27];
						est_traveltime1 = schd_tab[i+1][22];
						p_stop_type = schd_tab[i+1][7];

						if((int)to_number(endtime1)!= 0)
							est_time = (int)to_number(endtime1);
						else{

							est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
						}

						tripidxarrayindicies[tripidxarrayindiciescnt] = to_string(i+1);
						estputime[tripidxarrayindiciescnt] = est_time;
						tripidxarrayindiciescnt++;
						break;
					}
				}

			}
			else if(strcmp(schd_tab[i][0],"")!=0 && strcmp(schd_tab[i][3],schd_tab[puid][3])!=0 && strcmp(schd_tab[i][GROUPNUMBER],"")!=0 && strcmp(schd_tab[i][GROUPNUMBER],schd_tab[puid][GROUPNUMBER])==0 && strcmp(schd_tab[i][7],"P")==0 && strcmp(schd_tab[i+1][GROUPNUMBER],"")!=0 && strcmp(schd_tab[i+1][GROUPNUMBER],schd_tab[doid][GROUPNUMBER])==0){
				if(DEBUG == 1) gse << "The trips group is already assigned!" << endl;
				return false;
			}
		}
	}

	bubbleSort_twoarray_str(estputime,tripidxarrayindicies,tripidxarrayindiciescnt);
	if(DEBUG == 1) gse << "We have to fit : " << endl;
	for(int r = 0; r < tripidxarraycnt; r++){
		if(DEBUG == 1) gse << tripidxarray[r] << ", ";
	}
	if(DEBUG == 1) gse << endl;
	string temproute[MAXSTOPS][TRIPCOLSIZE];
	int routeint = (int)to_number(segment.substr(1,segment.length()));



	for(int m = 0; m < MAXSEGMENTS; m++){

		//   if(DEBUG == 1) gse << routeint << endl;


		//if(segmentroute == ""){



		if( s_tab[m][0]== routeint){

			for(int o = 0; o < MAXSTOPS;o++){
				if(temproute[0][10]=="")
					break;
				for(int u = 0; u < TRIPCOLSIZE;u++)
					temproute[o][u] == "";
			}


			if(DEBUG == 1) gse << "\n Route is " << segment << endl;


			for(int k = 1; k < MAXSTOPS; k++){

				//    if(DEBUG == 1) gse << "Test " << s_tab[i][k] << endl;
				if(s_tab[m][k]== 0){break;}

				//   if(DEBUG == 1) gse <<"In the loop " <<  s_tab[m][0] << " " << (int)to_number(routes[cnt].substr(1,routes[cnt].length())) << " " << schd_tab[s_tab[m][1]][0] <<endl;

				//counterbegin = m;
				int counter = 0;
				int h = 0;
				bool ontime = true;
				int  actualTT = 0;
				double origdistdo = 0.0;
				double origdistpu = 0.0;
				int u = 0;


				if(DEBUG == 1) gse << segment << endl;

				while(strcmp(schd_tab[s_tab[m][k]][0],segment.c_str())==0 ){

					while(u < tripidxarrayindiciescnt) {

						if(DEBUG == 1) gse << u << " out of " << tripidxarrayindiciescnt << " " << (int)to_number(schd_tab[s_tab[m][k]][29]) << "/" << (int)to_number(schd_tab[s_tab[m][k]][4]) << " compared to " << estputime[u] << endl;



						if((int)to_number(schd_tab[s_tab[m][k]][4]) < estputime[u] && (int)to_number(schd_tab[s_tab[m][k]][2])== (int)to_number(MAXSTOPNUM[0]) ){
							if(DEBUG == 1) gse << "Passed segment end" << endl;
							return false;
						}

						int comparisontime = 0;
						if((int)to_number(schd_tab[s_tab[m][k]][29]) > (int)to_number(schd_tab[s_tab[m][k]][4])){
							comparisontime = (int)to_number(schd_tab[s_tab[m][k]][29]);
						}
						else{
							comparisontime = (int)to_number(schd_tab[s_tab[m][k]][4]);
						}

						if(comparisontime >= estputime[u] && (int)to_number(schd_tab[s_tab[m][k]][2])!= 1 ){
							if(DEBUG == 1) gse << "inserting " << u << endl;

							if(k!= 1 && (int)to_number(schd_tab[s_tab[m][k-1]][2])!= 1 && !isSameLocation(s_tab[m][k], (int)to_number(tripidxarrayindicies[u]))    &&  !isSameLocation(s_tab[m][k],s_tab[m][k-1])){
								int l = k;
								while( l != 1 && isSameLocation(s_tab[m][l], s_tab[m][l-1])){
									l--;
									if((int)to_number(schd_tab[s_tab[m][l-1]][2])== 1)
										break;
								}
								if(DEBUG == 1) gse << " l is " << l << " : k is " << k << endl;
								k = l;
								if(((int)to_number(schd_tab[s_tab[m][k]][29])!= 0 && (int)to_number(schd_tab[s_tab[m][k]][29]) < estputime[u])||
										((int)to_number(schd_tab[s_tab[m][k]][29])== 0 && (int)to_number(schd_tab[s_tab[m][k]][4]) < estputime[u])
								){
									if(DEBUG == 1) gse << "We had to move up because of a group and the first stop in the group that we are inserting before will be late" << endl;
									return false;
								}
							}
							temproute[h][0] = schd_tab[s_tab[m][1]][0];
							temproute[h][1] =schd_tab[(int)to_number(tripidxarrayindicies[u])][1];
							temproute[h][2] = to_string((int)to_number(schd_tab[(int)to_number(temproute[h-1][20])][2])+1) ;
							temproute[h][3] = schd_tab[(int)to_number(tripidxarrayindicies[u])][3];
							temproute[h][4] = schd_tab[(int)to_number(tripidxarrayindicies[u])][4];
							temproute[h][5] = "Y";
							temproute[h][6] =schd_tab[(int)to_number(tripidxarrayindicies[u])][6];
							temproute[h][7] =schd_tab[(int)to_number(tripidxarrayindicies[u])][7];
							temproute[h][8] =schd_tab[(int)to_number(tripidxarrayindicies[u])][8];
							temproute[h][9] = schd_tab[(int)to_number(tripidxarrayindicies[u])][9];
							temproute[h][10] = schd_tab[(int)to_number(tripidxarrayindicies[u])][10];
							temproute[h][37] =schd_tab[(int)to_number(tripidxarrayindicies[u])][37];
							temproute[h][38]= schd_tab[s_tab[m][k]][10];
							temproute[h][39]= schd_tab[s_tab[m][k]][37];
							temproute[h-1][38] = schd_tab[(int)to_number(tripidxarrayindicies[u])][10];
							temproute[h-1][39] =schd_tab[(int)to_number(tripidxarrayindicies[u])][37];
							temproute[h][11] =schd_tab[(int)to_number(tripidxarrayindicies[u])][11];
							temproute[h][12] = schd_tab[(int)to_number(tripidxarrayindicies[u])][12];
							temproute[h][13] =schd_tab[(int)to_number(tripidxarrayindicies[u])][13];
							temproute[h][14] =schd_tab[(int)to_number(tripidxarrayindicies[u])][14];
							temproute[h][15] =schd_tab[(int)to_number(tripidxarrayindicies[u])][15];
							temproute[h][16] =schd_tab[(int)to_number(tripidxarrayindicies[u])][16];
							temproute[h][17] =schd_tab[(int)to_number(tripidxarrayindicies[u])][17];
							temproute[h][18] =schd_tab[(int)to_number(tripidxarrayindicies[u])][18];
							temproute[h][19] = to_string((int)to_number(schd_tab[(int)to_number(temproute[h-1][20])][2])+2) ;
							temproute[h-1][19] = to_string((int)to_number(schd_tab[(int)to_number(temproute[h-1][20])][2])+1) ;
							temproute[h][20] = tripidxarrayindicies[u];
							temproute[h][21] = schd_tab[(int)to_number(tripidxarrayindicies[u])][21];
							temproute[h][22] =schd_tab[(int)to_number(tripidxarrayindicies[u])][22];
							temproute[h][23] =schd_tab[(int)to_number(tripidxarrayindicies[u])][23];
							temproute[h][24] =schd_tab[(int)to_number(tripidxarrayindicies[u])][24];
							temproute[h][25] =schd_tab[(int)to_number(tripidxarrayindicies[u])][25];
							temproute[h][26] =schd_tab[(int)to_number(tripidxarrayindicies[u])][26];
							temproute[h][27] =schd_tab[(int)to_number(tripidxarrayindicies[u])][27];
							temproute[h][28] =schd_tab[(int)to_number(tripidxarrayindicies[u])][28];
							temproute[h][29] =schd_tab[(int)to_number(tripidxarrayindicies[u])][29];
							temproute[h][30] =schd_tab[(int)to_number(tripidxarrayindicies[u])][30];
							temproute[h][31] =schd_tab[(int)to_number(tripidxarrayindicies[u])][31];
							temproute[h][32] =schd_tab[(int)to_number(tripidxarrayindicies[u])][32];
							temproute[h][33] =schd_tab[(int)to_number(tripidxarrayindicies[u])][33];
							temproute[h][34] =schd_tab[(int)to_number(tripidxarrayindicies[u])][34];
							temproute[h][35] =schd_tab[(int)to_number(tripidxarrayindicies[u])][35];
							temproute[h][36] =schd_tab[(int)to_number(tripidxarrayindicies[u])][36];
							temproute[h][OPER_ID] = schd_tab[s_tab[m][1]][OPER_ID];
							temproute[h][EARLIEST_ARR] = schd_tab[(int)to_number(tripidxarrayindicies[u])][EARLIEST_ARR];
							temproute[h][LATEST_DEP] = schd_tab[(int)to_number(tripidxarrayindicies[u])][LATEST_DEP];
							temproute[h][NEIGHBORS] = schd_tab[(int)to_number(tripidxarrayindicies[u])][NEIGHBORS];
							temproute[h][SUGG_RES_NUM] = schd_tab[s_tab[m][1]][0];
							temproute[h][ORIG_PROMTIME] = schd_tab[(int)to_number(tripidxarrayindicies[u])][ORIG_PROMTIME];
							temproute[h][SITE] = schd_tab[(int)to_number(tripidxarrayindicies[u])][SITE];
							temproute[h][PICKUPIDX] = schd_tab[(int)to_number(tripidxarrayindicies[u])][PICKUPIDX];
							temproute[h][43] = "Y";
							temproute[h][44] = "Y";
							temproute[h][LATEDEVIATION] = "";
							temproute[h][TRVLTIMEDEVIATION] = "";

							u++;
							h++;
							counter++;
						}

						else if(u == tripidxarrayindiciescnt || (int)to_number(schd_tab[s_tab[m][k]][4]) < estputime[u] || (int)to_number(schd_tab[s_tab[m][k]][2])== 1){

							if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
								// string templatlong = schd_tab[s_tab[m][k]][10];
								string lat11 = schd_tab[s_tab[m][k]][10];
								string lon11 = schd_tab[s_tab[m][k]][37];
								// temproute[h][13] = "0";
								temproute[h][10] = lat11;
								temproute[h][37] =lon11;
								temproute[h][38] = lat11;
								temproute[h][39] =lon11;

							}
							else{
								temproute[h][10] = schd_tab[s_tab[m][k]][10];
								temproute[h][37] = schd_tab[s_tab[m][k]][37];
								temproute[h][38] = schd_tab[s_tab[m][k]][38];
								temproute[h][39] = schd_tab[s_tab[m][k]][39];
							}

							string temp =  schd_tab[s_tab[m][k]][19] ;
							temp = getNextToken(&(temp),"^");

							temproute[h][0] = schd_tab[s_tab[m][k]][0];
							temproute[h][1] =schd_tab[s_tab[m][k]][1];
							temproute[h][2] = schd_tab[s_tab[m][k]][2];
							temproute[h][3] = schd_tab[s_tab[m][k]][3];
							temproute[h][4] = schd_tab[s_tab[m][k]][4];
							temproute[h][5] = "N";
							temproute[h][6] = schd_tab[s_tab[m][k]][6];
							temproute[h][7] = schd_tab[s_tab[m][k]][7];
							temproute[h][8] =schd_tab[s_tab[m][k]][8];
							temproute[h][9] = schd_tab[s_tab[m][k]][9];
							//temproute[h][10] = schd_tab[s_tab[m][k]][10];
							temproute[h][11] =schd_tab[s_tab[m][k]][11];
							temproute[h][12] = schd_tab[s_tab[m][k]][12];
							if(strcmp(schd_tab[s_tab[m][k]][13], "")==0)
								temproute[h][13] = "0";
							else
								temproute[h][13] =schd_tab[s_tab[m][k]][13];
							temproute[h][14] =schd_tab[s_tab[m][k]][14];
							temproute[h][15] =schd_tab[s_tab[m][k]][15];
							temproute[h][16] =schd_tab[s_tab[m][k]][16];
							temproute[h][17] =schd_tab[s_tab[m][k]][17];
							temproute[h][18] =schd_tab[s_tab[m][k]][18];
							temproute[h][19] = temp;
							temproute[h][20] = to_string(s_tab[m][k]);
							temproute[h][21] =schd_tab[s_tab[m][k]][21];
							temproute[h][22] =schd_tab[s_tab[m][k]][22];
							temproute[h][23] =schd_tab[s_tab[m][k]][23];
							temproute[h][24] =schd_tab[s_tab[m][k]][24];
							temproute[h][25] =schd_tab[s_tab[m][k]][25];
							temproute[h][26] =schd_tab[s_tab[m][k]][26];
							temproute[h][27] =schd_tab[s_tab[m][k]][27];
							temproute[h][28] =schd_tab[s_tab[m][k]][28];
							temproute[h][29] =schd_tab[s_tab[m][k]][29];
							temproute[h][30] =schd_tab[s_tab[m][k]][30];
							temproute[h][31] =schd_tab[s_tab[m][k]][31];
							temproute[h][32] =schd_tab[s_tab[m][k]][32];
							temproute[h][33] =schd_tab[s_tab[m][k]][33];
							temproute[h][34] =schd_tab[s_tab[m][k]][34];
							temproute[h][35] =schd_tab[s_tab[m][k]][35];
							temproute[h][36] =schd_tab[s_tab[m][k]][36];
							temproute[h][OPER_ID] = schd_tab[s_tab[m][k]][OPER_ID];
							temproute[h][EARLIEST_ARR] = schd_tab[s_tab[m][k]][EARLIEST_ARR];
							temproute[h][LATEST_DEP] = schd_tab[s_tab[m][k]][LATEST_DEP];
							temproute[h][NEIGHBORS] = schd_tab[s_tab[m][k]][NEIGHBORS];
							temproute[h][SUGG_RES_NUM] = schd_tab[s_tab[m][k]][SUGG_RES_NUM];
							temproute[h][ORIG_PROMTIME] = schd_tab[s_tab[m][k]][ORIG_PROMTIME];
							temproute[h][SITE] = schd_tab[s_tab[m][k]][SITE];
							temproute[h][PICKUPIDX] = schd_tab[s_tab[m][k]][PICKUPIDX];
							temproute[h][43] = "Y";
							temproute[h][44] = "Y";
							temproute[h][LATEDEVIATION] = schd_tab[s_tab[m][k]][LATEDEVIATION];
							temproute[h][TRVLTIMEDEVIATION] = schd_tab[s_tab[m][k]][TRVLTIMEDEVIATION];
							k++;
							h++;
							counter++;

						}



						//m++;

						//   if(DEBUG == 1) gse << " THE INDEX IS " << s_tab[m][k] << endl;

					}



					if(strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0])==0){
						// string templatlong = schd_tab[s_tab[m][k]][10];
						string lat11 = schd_tab[s_tab[m][k]][10];
						string lon11 = schd_tab[s_tab[m][k]][37];
						// temproute[h][13] = "0";
						temproute[h][10] = lat11;
						temproute[h][37] =lon11;
						temproute[h][38] = lat11;
						temproute[h][39] =lon11;

					}
					else{
						temproute[h][10] = schd_tab[s_tab[m][k]][10];
						temproute[h][37] = schd_tab[s_tab[m][k]][37];
						temproute[h][38] = schd_tab[s_tab[m][k]][38];
						temproute[h][39] = schd_tab[s_tab[m][k]][39];
					}

					string temp =  schd_tab[s_tab[m][k]][19] ;
					temp = getNextToken(&(temp),"^");

					temproute[h][0] = schd_tab[s_tab[m][k]][0];
					temproute[h][1] =schd_tab[s_tab[m][k]][1];
					temproute[h][2] = schd_tab[s_tab[m][k]][2];
					temproute[h][3] = schd_tab[s_tab[m][k]][3];
					temproute[h][4] = schd_tab[s_tab[m][k]][4];
					temproute[h][5] = "N";
					temproute[h][6] = schd_tab[s_tab[m][k]][6];
					temproute[h][7] = schd_tab[s_tab[m][k]][7];
					temproute[h][8] =schd_tab[s_tab[m][k]][8];
					temproute[h][9] = schd_tab[s_tab[m][k]][9];
					//temproute[h][10] = schd_tab[s_tab[m][k]][10];
					temproute[h][11] =schd_tab[s_tab[m][k]][11];
					temproute[h][12] = schd_tab[s_tab[m][k]][12];
					if(strcmp(schd_tab[s_tab[m][k]][13], "")==0)
						temproute[h][13] = "0";
					else
						temproute[h][13] =schd_tab[s_tab[m][k]][13];
					temproute[h][14] =schd_tab[s_tab[m][k]][14];
					temproute[h][15] =schd_tab[s_tab[m][k]][15];
					temproute[h][16] =schd_tab[s_tab[m][k]][16];
					temproute[h][17] =schd_tab[s_tab[m][k]][17];
					temproute[h][18] =schd_tab[s_tab[m][k]][18];
					temproute[h][19] = temp;
					temproute[h][20] = to_string(s_tab[m][k]);
					temproute[h][21] =schd_tab[s_tab[m][k]][21];
					temproute[h][22] =schd_tab[s_tab[m][k]][22];
					temproute[h][23] =schd_tab[s_tab[m][k]][23];
					temproute[h][24] =schd_tab[s_tab[m][k]][24];
					temproute[h][25] =schd_tab[s_tab[m][k]][25];
					temproute[h][26] =schd_tab[s_tab[m][k]][26];
					temproute[h][27] =schd_tab[s_tab[m][k]][27];
					temproute[h][28] =schd_tab[s_tab[m][k]][28];
					temproute[h][29] =schd_tab[s_tab[m][k]][29];
					temproute[h][30] =schd_tab[s_tab[m][k]][30];
					temproute[h][31] =schd_tab[s_tab[m][k]][31];
					temproute[h][32] =schd_tab[s_tab[m][k]][32];
					temproute[h][33] =schd_tab[s_tab[m][k]][33];
					temproute[h][34] =schd_tab[s_tab[m][k]][34];
					temproute[h][35] =schd_tab[s_tab[m][k]][35];
					temproute[h][36] =schd_tab[s_tab[m][k]][36];
					temproute[h][OPER_ID] = schd_tab[s_tab[m][k]][OPER_ID];
					temproute[h][EARLIEST_ARR] = schd_tab[s_tab[m][k]][EARLIEST_ARR];
					temproute[h][LATEST_DEP] = schd_tab[s_tab[m][k]][LATEST_DEP];
					temproute[h][NEIGHBORS] = schd_tab[s_tab[m][k]][NEIGHBORS];
					temproute[h][SUGG_RES_NUM] = schd_tab[s_tab[m][k]][SUGG_RES_NUM];
					temproute[h][ORIG_PROMTIME] = schd_tab[s_tab[m][k]][ORIG_PROMTIME];
					temproute[h][SITE] = schd_tab[s_tab[m][k]][SITE];
					temproute[h][PICKUPIDX] = schd_tab[s_tab[m][k]][PICKUPIDX];
					temproute[h][LATEDEVIATION] = schd_tab[s_tab[m][k]][LATEDEVIATION];
					temproute[h][TRVLTIMEDEVIATION] = schd_tab[s_tab[m][k]][TRVLTIMEDEVIATION];

					k++;
					h++;
					counter++;




				}

				int stopnum = 1;
				for(int g = 0; g < counter; g++){
					if(g == 0){
						temproute[g][2] = "1";
						temproute[g][19] = to_string(stopnum+1);
					}
					else if(g +1 == counter){
						temproute[g][2] = MAXSTOPNUM[0];
						temproute[g][19] = MAXSTOPNUM[0];
					}
					else{
						temproute[g][2] = to_string(stopnum);
						temproute[g][19] = to_string(stopnum+1);
					}

					stopnum++;
				}


				string clientdate = client + date;
				string running = "RUNNINGFBSEARCH"+clientdate;

				int waitingforosrm = 0;

				while(true){
					//  if(DEBUG == 1) gse << process_tab[ACCESS][0] << " " << process_tab[LOADDB][0] << endl;
					if( strcmp(shared_process_tab[WRITINGFB][0],("READY"))==0 ){
						usleep(100);
						if( strcmp(shared_process_tab[WRITINGFB][0],("READY"))==0 ){
							strcpy(shared_process_tab[WRITINGFB][0],running.c_str());
							break;
						}

					}
				}


				while(true){ // double check if someone else is currently writing
					//  if(DEBUG == 1) gse << process_tab[ACCESS][0] << " " << process_tab[LOADDB][0] << endl;
					if( strcmp(shared_process_tab[WRITINGFB][0],(running.c_str()))==0){
						break;
					}
					else if(strcmp(shared_process_tab[WRITINGFB][0],("READY"))==0){
						strcpy(shared_process_tab[WRITINGFB][0],running.c_str());
						usleep(100);
					}
				}

				int q;

				for(int g = 0; g < counter; g++){


					string osrm = temproute[g][10] + "," +temproute[g][37]+ "," +temproute[g][38]+ "," +temproute[g][39];

					for(int d = 0; d < MAXREQUESTS; d++){

						if(requestIsEmpty(d)){
							usleep(10);
							if(requestIsEmpty(d)){
								q = d;
								break;
							}

						}
						if(d+1 == MAXREQUESTS)
							d = -1;
					}
					if(DEBUG == 1) gse << "q is " << q << endl;

					string function = "FindBestDistSINGLE";

					time_t t = time(NULL);
					struct tm tm = *localtime(&t);
					char timebuffer[100];
					sprintf(timebuffer, "%s", asctime(&tm));
					string localtimestr = timebuffer;
					localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());


					updateRequest(q, clientdate,  "NUM");
					updateRequest(q, function, "FUNC");
					updateRequest(q, localtimestr, "TIMESTAMP");
					updateRequest(q, to_string(g), "ID");
					updateRequest(q, osrm, "LATLONG");
					updateRequest(q, temproute[g][20], "TRIPIDX");
					updateRequest(q, to_string(NUMBER_OF_EDGES[0]), "NUMBEROFEDGES");


					waitingforosrm++;

				}


				strcpy(shared_process_tab[WRITINGFB][0],"READY");




				int datafromosrm = 0;
				int g = 0;
				while(true){

					for(int q = 0; q < MAXREQUESTS; q++){

						if(fetchRequest(q, "DISTANCE") != "" &&  fetchRequest(q, "TIME") != "" && fetchRequest(q, "ID") == to_string(g) && fetchRequest(q, "NUM") == clientdate && fetchRequest(q, "FUNC") == "FindBestDistSINGLE"){
							string dist = fetchRequest(q, "DISTANCE");
							string timetonextstop = fetchRequest(q, "TIME");
							temproute[g][6] = (dist);
							temproute[g][28] = (timetonextstop);

							if(DEBUG == 1) gse << fetchRequest(q, "ID") << " " << schd_tab[(int)to_number(fetchRequest(q, "TRIPIDX"))][3] << " " << dist << endl;
							clearRequest(q);
							while(!requestIsEmpty(q)){
							}
							//f++;
							g++;
							datafromosrm++;

						}
					}
					if(datafromosrm == waitingforosrm )
						break;
				}







				/* for(int g = 0; g < counter; g++){
                //for(int y = 0; y < 20; y++){
                       if(DEBUG == 1) gse << temproute[g][2] <<"|" << temproute[g][6] <<"|"<< temproute[g][10] <<"|"<< temproute[g][19] ;
                //}
                   if(DEBUG == 1) gse << endl;

            }*/


				std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>  varHolder;
				string p_customer;
				bool notFound;


				string last_segment_id;

				if(counter > 0){
					//   if(DEBUG == 1) gse << "COUNTER " << counter << endl;
					if(DEBUG == 1) gse <<"Stop  prom time    eta   etd     dist ttime stoptype    wc    amb \t esc"<< endl;
				}

				std::string  promisedtime1;
				int prom_time;
				std::string est_traveltime1;
				std::string arrivetime1;
				std::string departtime1 ;
				std::string perftime1 ;
				int p_perf_time;
				std::string starttime1 ;
				std::string endtime1;
				std::string timetonextstop1 ;
				std::string eta1 ;
				int eta;
				std::string etd1; /// fix this hack in get next token
				int etd;
				std::string  lat1  ;
				std::string lon1   ;
				std::string lat2 ;
				std::string lon2; /// fix this hack in get next token
				std::string  amb_occ1 ;
				std::string wc_occ1 ;
				int cs_cap = 0;
				int bs_cap = 0;
				std::string amb_cap1 ;
				std::string wc_cap1 ; /// fix this hack in get next token
				int p_amb_occ;
				int p_wc_occ;
				int p_cs_occ;
				int p_bs_occ;
				int p_grp_cnt_wc;
				int p_grp_cnt_amb;
				int s_trip_appt_time;
				int p_latency;
				int p_prev_stop_num;
				int p_prev_perf_time;
				int OffLoaded;
				string p_trip_type ;
				string p_spl_other_desc ;
				int last_wc_occ = 0, last_cs_occ = 0, last_bs_occ = 0;
				int last_amb_occ = 0;
				int last_dep_time ;
				int last_arr_time ;
				int tot_driv_time = 0;
				double tot_miles = 0;
				string p_latestoptime ="";
				string p_earlystoptime= "";
				double p_disttonextstop = 0.0;
				int p_timetonextstop = 0;
				string p_name ;
				string p_return_trip ;
				string p_stop_type ;
				string p_disability = "" ;
				int p_esc;
				string p_td_segmentid = "";
				int stopnum1;
				int p_stop_num;
				int p_early_morning_factor = 0;
				string p_street_by_street = "T";
				string p_citytown;
				string time_zone2 = "*";
				string time_zone;// = "*";
				int petaint;
				string rteStr;
				double disttrav;
				string grp_cnt_amb;
				string grp_cnt_wc;
				string dist;
				string p_promised_time;
				string p_eta;
				string p_etd;
				string capacity;
				string times;
				string prev_perftime1,prev_eta1,prev_etd1, prev_amb_occ1, prev_wc_occ1;
				int prev_eta,prev_etd,prev_p_perf_time;
				//int index;
				//int cnt = 0;
				double disttrav2;
				double prev_distance = 0;
				int timetostop = 0;
				//int actualTT;
				//bool recalc = false;


				// int aStp = 999;
				//string indicies = to_string(puid) + "," +to_string(doid);
				string indafter1;string indafter2;


				string pueta;
				string doeta;
				string disttravpu;
				string disttravdo;
				string pustp;
				string dostp;
				string puetd;
				string doetd;
				string latlon1;
				string latlon2;
				string latlon3;
				string latlon4;
				bool finished = false;
				string oResult;
				bool triedRecalc;
				bool aStpfinished = false;
				finished = false;
				bool finishedrecalc = false;
				int AGRPCOUNTER = 0;
				int APRVGRPCOUNTER = 0;


				int p_WHEELLOAD1;
				int p_AMBLOAD1;
				int p_MAXEARLYDROPOFFFACTOR1;
				int p_DIALRIDEEARLYPICKFACTOR1;
				int p_DIALRIDELATEPICKFACTOR1;
				int p_OTHEREARLYPICKFACTOR1;
				int p_OTHERLATEPICKFACTOR1;
				string IGNOREPUTIMES1;
				int p_SHORTBREAK1;
				int p_LUNCHBREAK1;
				int p_PROXIMITYFACTOR1;
				int a_mediumshortdistance1;
				int a_mediumlongdistance1;
				int a_shorttriptime1;
				int a_longtriptime1;
				int a_mediumtriptime1;
				int a_extra_loadtime1;
				string ZONE_DESCR1;
				string IGNORE_DEPOTS_CUTOFF1;
				string p_prev_promised_time = "0000A";

				int local_s_tab[MAXSTOPS];

				for(int y = 0; y < counter; y++){
					local_s_tab[y] = (int)to_number(temproute[y][20]);
				}


				create_group(local_s_tab,counter);

				int grouptraveltimeallowance[MAXTRIPIDX];


				for(int y = 0; y < MAXTRIPIDX; y++){
					grouptraveltimeallowance[y] = 0;
				}
				int extratraveltime = 0;
				int groupid = 1;
				bool secondpassinsertedtrip = false;
				int aStp = 1 ;

				for(int y = 0; y < counter;y++){

					string groupmark = schd_tab[local_s_tab[y]][GRPIDX];


					if(strcmp(schd_tab[local_s_tab[y]][2],MAXSTOPNUM[0])!=0){
						if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"D")==0  && groupmark!= ""){
							//strcpy(schd_tab[local_s_tab[y]][GRPIDX],to_string(groupid).c_str());
							//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[y]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
							int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
							grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
						}
						if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"P")==0 && groupmark!= "" ){
							groupid++;
						}
					}

				}

				////bool isVol = isVolSegment(temproute[0][0], temproute[0][1],temproute[0][14]);
				getCS_CY_cap(cs_cap, bs_cap, temproute[0][SEGMENTTYPE]);


				for(int i = 0; i < counter; i++)
				{

					// string temp =  temproute[i][4];
					promisedtime1 = temproute[i][4];
					prom_time =(int)to_number(promisedtime1);
					//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
					p_promised_time = itms_minutes_to_ampm(prom_time);
					est_traveltime1 = temproute[i][22];
					arrivetime1 = temproute[i][23];
					arrivetime1 = padStr( arrivetime1);
					departtime1 =temproute[i][24];
					departtime1 = padStr(departtime1);
					perftime1 = temproute[i][25];
					//perftime1 = padStr(perftime1);
					p_perf_time = (int)to_number(perftime1);
					starttime1 = temproute[i][26];
					//starttime1  = padStr(starttime1 );
					endtime1 = temproute[i][27];
					//endtime1 = padStr(endtime1);
					timetonextstop1 = temproute[i][28] ;
					eta1 = temproute[i][29];
					eta = (int)to_number(eta1);
					eta1 = itms_minutes_to_ampm(eta);

					etd1 = temproute[i][30]; /// fix this hack in get next token
					etd = (int)to_number(etd1);
					etd1 = itms_minutes_to_ampm(etd);
					//temp =  temproute[i][10];
					lat1 =  temproute[i][10];
					lon1 =  temproute[i][37];
					lat2 =  temproute[i][38];
					lon2 =  temproute[i][39]; /// fix this hack in get next token
					//temp =  temproute[i][12];
					amb_occ1 =  temproute[i][31];
					wc_occ1 =  temproute[i][32];
					p_cs_occ = to_number(temproute[i][CS_OCC]);
					p_bs_occ =to_number(temproute[i][BS_OCC]);
					if(temproute[i][2] == "1"){
						amb_cap1 =  temproute[0][33];
						wc_cap1 =  temproute[0][34]; /// fix this hack in get next token
					}

					grp_cnt_amb = temproute[i][35];
					p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
					grp_cnt_wc = temproute[i][36];
					p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

					p_disability = temproute[i][12];
					//p_amb_occ = to_number(amb_occ1);
					//p_wc_occ = to_number(wc_occ1);
					p_trip_type =  temproute[i][8];
					p_spl_other_desc =  temproute[i][9];
					//last_dep_time = prom_time;
					//last_arr_time = prom_time;
					p_name =  temproute[i][14];
					p_return_trip =  temproute[i][18];
					p_stop_type =  temproute[i][7];
					p_esc = (int)to_number(temproute[i][13]);
					p_td_segmentid =  temproute[i][0];
					p_stop_num = (int)to_number( temproute[i][2]);

					if (p_stop_num == 1){
						last_dep_time = prom_time;
						last_arr_time = prom_time;
					}
					if(p_stop_num != 1){
						prev_distance = to_number(temproute[i-1][6]);
						timetostop = to_number(temproute[i-1][28]);
					}
					//  if(DEBUG == 1) gse << " Distances " << prev_distance << " " << disttrav << endl;

					//   if(DEBUG == 1) gse << "aSTp " << p_stop_num << " " << aStp << endl;

					disttrav = to_number(temproute[i][6]);

					p_citytown =  temproute[i][11];


					//   if(DEBUG == 1) gse << "Time zone " << time_zone << " " << p_eta << " " << p_promised_time << " " << ignorepu[0] << endl;

					/* if (aStp == 0 && temproute[i][5]=="Y"){

                            aStp = (int)to_number(temproute[i][2]);
                            //  if(DEBUG == 1) gse << "aSTp " << aStp << endl;
                        }*/
					int p_WHEELLOAD1;
					int p_AMBLOAD1;
					int p_MAXEARLYDROPOFFFACTOR1;
					int p_DIALRIDEEARLYPICKFACTOR1;
					int p_DIALRIDELATEPICKFACTOR1;
					int p_OTHEREARLYPICKFACTOR1;
					int p_OTHERLATEPICKFACTOR1;
					string IGNOREPUTIMES1;
					int p_SHORTBREAK1;
					int p_LUNCHBREAK1;
					int p_PROXIMITYFACTOR1;
					int a_mediumshortdistance1;
					int a_mediumlongdistance1;
					int a_shorttriptime1;
					int a_longtriptime1;
					int a_mediumtriptime1;
					int a_extra_loadtime1;
					string ZONE_DESCR1;
					string IGNORE_DEPOTS_CUTOFF1;



					int grouppickupcnt = 0;

					string groupmark = schd_tab[(int)to_number(temproute[i][20])][GRPIDX];
					if(groupmark != ""){
						int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
						grouppickupcnt = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
						//  if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
					}

					string pReturn_trip = temproute[i][18];
					string  pDisability = temproute[i][12];
					string p_trip_type1 =temproute[i][8];


					set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
							p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
							a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

					double estdisttrip = to_number(temproute[i][21]);

					int aAllowedTT;



					int allowedDW;
					double esttime = to_number(temproute[i][22]);
					if(estdisttrip < a_mediumshortdistance1){
						aAllowedTT = a_shorttriptime1 + extratraveltime;
						allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
					}
					else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
						allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
						aAllowedTT = a_mediumtriptime1 + extratraveltime;
					}
					else{
						aAllowedTT = a_longtriptime1 + extratraveltime;
						allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
					}

					if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
						allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
						aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
					}


					int p_perf_time;
					string pDisposition = schd_tab[(int)to_number(temproute[i][20])][DISPOSITION];
					set_p_perf_time(pDisposition,pDisability, p_perf_time, p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1 );


					int est_time;
					string tripid = schd_tab[(int)to_number(temproute[i][20])][3];
					tripid = tripid.substr(0,1);
					string endtime2;
					if(tripid == "S"){
						endtime2 =to_string( (int)itms_to_minutes(ampm2fullhrs(p_promised_time)));
					}

					if(p_stop_type == "P"){
						if((int)to_number(starttime1)!= 0)
							est_time = (int)to_number(starttime1);
						else{
							est_time =  (int)to_number(endtime2) - (int)to_number(est_traveltime1);
						}
					}
					else{
						if((int)to_number(endtime2)!= 0)
							est_time = (int)to_number(endtime2);
						else{

							est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
						}
					}
					//p_eta = eta1;
					if(p_stop_num ==1){
						p_eta = p_promised_time;
						p_etd = etd1;
					}
					else{
						p_eta = eta1;
						p_etd = etd1;
					}
					string timezonetime = itms_minutes_to_ampm(est_time);
					string route = schd_tab[(int)to_number(temproute[i][20])][0];
					if( (route == "" || timeZones(p_eta, timezonetime) != timeZones(timezonetime,p_eta))  && !secondpassinsertedtrip){time_zone = timeZones(p_eta, timezonetime); secondpassinsertedtrip = true;}
					else{  if(F_GET_TRAVEL_TIME (1.0 , timeZones(p_eta, timezonetime), "*") > F_GET_TRAVEL_TIME (1.0 , timeZones(timezonetime,p_eta), "*")){
						time_zone = timeZones(p_eta, timezonetime);secondpassinsertedtrip = false;
					}
					else{
						time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
					}
					//time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
					}
					//time_zone = timeZones(p_eta, timezonetime);
					string timezone2;
					if (p_stop_num != 1) {
						if (!isSameLocation((int)to_number(temproute[i][20]),(int)to_number(temproute[i-1][20])))
							timezone2 = "#"; // not the same lat/long
						else
							timezone2 = "*";
					}







					varHolder = itms_calcroute( arrivetime1, departtime1,timetostop,  rteStr ,   p_citytown ,     p_street_by_street ,     p_eta  ,    p_promised_time ,     p_perf_time ,   p_early_morning_factor ,  p_stop_num ,
							p_td_segmentid,  p_wc_occ   , p_amb_occ,   p_esc  ,  p_disability  , p_stop_type  ,  p_WHEELLOAD[0] ,  p_AMBLOAD[0] ,
							p_customer ,   p_return_trip  ,  p_DIALRIDEEARLYPICKFACTOR[0]  ,  p_DIALRIDELATEPICKFACTOR[0] ,  p_PROXIMITYFACTOR[0],  p_SHORTBREAK[0]  ,
							p_LUNCHBREAK[0]   ,   p_MAXEARLYDROPOFFFACTOR[0]  , p_OTHEREARLYPICKFACTOR[0]  ,  p_OTHERLATEPICKFACTOR[0] ,   p_name    ,
							p_timetonextstop , p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
							OffLoaded   , p_trip_type ,    p_prev_perf_time ,   p_prev_stop_num , p_latency   ,  s_trip_appt_time ,  p_grp_cnt_amb ,
							p_grp_cnt_wc,  ignorepu[0],  IGNORE_DEPOTS_CUTOFF[0], time_zone, timezone2, starttime1,p_cs_occ   , p_bs_occ,last_cs_occ,last_bs_occ,pDisposition);

					//   if(DEBUG == 1) gse << "ETa " << p_eta << " " << p_etd << endl;

					p_eta = std::get<0>(varHolder);
					p_wc_occ=std::get<1>(varHolder);
					p_amb_occ=std::get<2>(varHolder);
					p_esc=std::get<3>(varHolder);
					p_timetonextstop=std::get<4>(varHolder);
					p_disttonextstop=std::get<5>(varHolder);
					p_earlystoptime=std::get<6>(varHolder);
					p_latestoptime=std::get<7>(varHolder);
					tot_miles=std::get<8>(varHolder);
					tot_driv_time=std::get<9>(varHolder);
					p_etd=std::get<10>(varHolder);
					OffLoaded=std::get<11>(varHolder);
					p_perf_time = std::get<12>(varHolder);
					p_cs_occ = std::get<13>(varHolder);
					p_bs_occ = std::get<14>(varHolder);

					if(!secondpassinsertedtrip){
						p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) - p_perf_time);
						if (p_stop_num != 1 && p_stop_num != (int)to_number(MAXSTOPNUM[0])) {
							if (timetostop == 0 && temproute[i][7] == temproute[i-1][7])

								AGRPCOUNTER = AGRPCOUNTER + 1;
							else{
								if (AGRPCOUNTER > 0  && temproute[i][7] == temproute[i-1][7])
								{
									APRVGRPCOUNTER = AGRPCOUNTER + 1;
								}
								AGRPCOUNTER = 0;
							}


							if(p_disability.find("WC",0) == string::npos && p_disability.find("SC",0) == string::npos && p_disability.find("XLT",0) == string::npos){


								if (AGRPCOUNTER > 0 && temproute[i][7] == temproute[i-1][7]){

									p_perf_time = p_perf_time / AGRPCOUNTER;
								}


								if (APRVGRPCOUNTER > 0 && temproute[i][7] == temproute[i-1][7]) {

									p_perf_time = p_perf_time / APRVGRPCOUNTER;
									APRVGRPCOUNTER = 0;
								}
							}
							else{

								if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


									if (AGRPCOUNTER > 0 && temproute[i][7] == temproute[i-1][7]) {

										p_perf_time = p_perf_time / AGRPCOUNTER;
									}

									if (APRVGRPCOUNTER > 0 && temproute[i][7] == temproute[i-1][7]) {

										p_perf_time = p_perf_time / APRVGRPCOUNTER;
										APRVGRPCOUNTER = 0;
									}
								}
							}

						}
						p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) + p_perf_time);
					}
					//   if(DEBUG == 1) gse << "ETa2 " << p_eta << " " << p_etd << endl;

					bool changedeta = false;

					if(to_string(itms_to_minutes (ampm2fullhrs (p_eta))) != temproute[i][29])
						changedeta = true;



					if(p_stop_type  == "P"){
						string tripidforwait = temproute[i][3];
						int DW = getDWByStop (tripidforwait, p_stop_type ,itms_to_minutes (ampm2fullhrs (p_eta)) , itms_to_minutes (ampm2fullhrs (p_etd))  ,(int)to_number(starttime1), p_perf_time);
						int PW = getPWByStop (tripidforwait,  p_stop_type  ,itms_to_minutes (ampm2fullhrs (p_eta))    , (int)to_number(starttime1));
						temproute[i][DWWAIT] = to_string(DW);
						temproute[i][PWWAIT] = to_string(PW);
					}
					else{

						int eta = itms_to_minutes (ampm2fullhrs (p_eta));
						int etd = (int)to_number(temproute[i-1][30]);
						int TT = (int)to_number(temproute[i-1][CALCULATEDTIME]);
						string tripidforwait = temproute[i][3];
						int DW = eta - etd + TT;
						int PW = getPWByStop (tripidforwait,  temproute[i][7],eta, (int)to_number(endtime1));
						temproute[i][DWWAIT] = to_string(DW);
						temproute[i][PWWAIT] = to_string(PW);
					}


					temproute[i][4] = to_string(itms_to_minutes (ampm2fullhrs ( p_promised_time)));
					temproute[i][22] =est_traveltime1;
					temproute[i][23] =arrivetime1;
					temproute[i][24] =departtime1;
					temproute[i][25] =to_string(p_perf_time);
					temproute[i][26] =starttime1;
					temproute[i][27] =endtime1 ;
					if(i > 0){
						temproute[i-1][28] = to_string(timetostop) ;
						temproute[i-1][CALCULATEDTIME] =to_string(p_timetonextstop) ;
					}

					temproute[i][29] =to_string(itms_to_minutes (ampm2fullhrs (p_eta)));
					temproute[i][30] =to_string(itms_to_minutes (ampm2fullhrs (p_etd)));
					//temproute[i][6] = to_string(disttrav);
					temproute[i][31] =  to_string(p_amb_occ);
					temproute[i][32] =to_string(p_wc_occ);


					prev_eta1 = temproute[i][29];
					prev_eta = to_number(prev_eta1);
					prev_eta1 = itms_minutes_to_ampm(prev_eta);

					int t = i;
					string timezone3;
					if (p_stop_num != 1) {
						if (!isSameLocation((int)to_number(temproute[t][20]),(int)to_number(temproute[t-1][20])))
							timezone3 = "#"; // not the same lat/long
							else
								timezone3 = "*";



						if(timezone3 == "*" && temproute[t][7]==temproute[t-1][7] && temproute[t-1][2] != "1" && temproute[t][41]==temproute[t-1][41] ){
							temproute[t][29] = temproute[t-1][29];
							int l = t;
							while(isSameLocation((int)to_number(temproute[l][20]),(int)to_number(temproute[l-1][20])) && temproute[l-1][7]== temproute[l][7] && tripid.substr(0,1)!="S" && temproute[l-1][41]== temproute[l][41]  ){
								temproute[l-1][30] = temproute[l][30];
								l--;
								tripid = schd_tab[(int)to_number(temproute[l][20])][3];
								if(l == 0)
									break;
							}
						}
					}


					if(secondpassinsertedtrip){  if(DEBUG == 1) gse << "REDOING" << endl; i--;continue;}

					prev_perftime1 = temproute[i][25];

					prev_p_perf_time = to_number(prev_perftime1);


					prev_etd1 = temproute[i][30]; /// fix this hack in get next token
					prev_etd = to_number(prev_etd1);
					prev_etd1 = itms_minutes_to_ampm(prev_etd);
					//temp = temproute[i][12];
					prev_amb_occ1 =  temproute[i][31];
					prev_wc_occ1 =  temproute[i][32];

					//amb_cap1 = getNextToken(&(temp), ",");
					//wc_cap1 =getNextToken(&(temp), ",");
					last_dep_time=prev_etd;
					last_arr_time=prev_eta;
					string prev_cs_occ = temproute[i][CS_OCC];
					string prev_bs_occ = temproute[i][BS_OCC];
					last_cs_occ=to_number(prev_cs_occ);
					last_bs_occ=to_number(prev_bs_occ);
					last_amb_occ=to_number(prev_amb_occ1);
					last_wc_occ=to_number(prev_wc_occ1);

					p_prev_perf_time = prev_p_perf_time;
					p_prev_stop_num = to_number(temproute[i][2]);
					p_prev_promised_time = p_promised_time;








					// temp = temproute[i][4];


					/*if(temproute[i][20] == "0" && temproute[i-1][20] != "0"){
                               if(DEBUG == 1) gse << "Stop Num " << temproute[i-1][2] << endl;
                        temp = temproute[i-1][12];
                        getNextToken(&(temp), ",");
                        getNextToken(&(temp), ",");
                        amb_cap1 = getNextToken(&(temp), ",");
                        wc_cap1 =getNextToken(&(temp), ",");
                        }*/

					//   if(DEBUG == 1) gse << last_dep_time << endl;











					string tripid2 = temproute[i][3];
					string p_trip_type2 = temproute[i][8];

					if(temproute[i][7] == "D" && (tripid2.substr(0,1) == "T" ||tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN" ){

						int doeta1;
						int puetd1;


						for(int b = 0; b < counter; b++){
							if(temproute[b][3] == tripid2 && temproute[b][7] == "P"){
								doeta1 = (int)to_number(temproute[i][30])- (int)to_number(temproute[i][25]);
								puetd1 = (int)to_number(temproute[b][30]);
								break;
							}
						}


						actualTT = doeta1 - puetd1; //flipped eta/etd
						if(DEBUG == 1) gse << "Actual travel time of " << temproute[i][3] << " " << actualTT << endl;
					}

					else
						actualTT = 0;


					p_eta = itms_minutes_to_ampm((int)to_number(temproute[i][29]));
					p_etd = itms_minutes_to_ampm((int)to_number(temproute[i][30]));




					int aLatepickup;

					if (p_return_trip == "Y"){
						aLatepickup = p_OTHERLATEPICKFACTOR1;
					}
					else{
						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
					}

					if(p_stop_num == (int)to_number(MAXSTOPNUM[0])){
						endtime1 = to_string((int)itms_to_minutes(ampm2fullhrs(p_promised_time))); // to make sure segments do not go beyond the end'
						//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
					}

					bool preassigntripchange = true;
					if(strcmp(schd_tab[(int)to_number(temproute[i][20])][LATEDEVIATION],"")!=0 || strcmp(schd_tab[(int)to_number(temproute[i][20])][TRVLTIMEDEVIATION],"")!=0){
						if(DEBUG == 1) gse << "Preassign is false " << endl;
						preassigntripchange = false;
						if ((p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {
							if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup)//p_DIALRIDELATEPICKFACTOR )
							{
								int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(starttime1) + aLatepickup);
								if(dev > (int)to_number(schd_tab[(int)to_number(temproute[i][20])][LATEDEVIATION])){
									if(DEBUG == 1) gse << "Preassign is true " << endl;
									preassigntripchange = true;
								}

							}
						}


						if ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000")
						{
							if((((itms_to_minutes(ampm2fullhrs(p_eta))) >  (int)to_number(endtime1)) && prom_time != 0))
							{

								int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(endtime1));
								if(dev > (int)to_number(schd_tab[(int)to_number(temproute[i][20])][LATEDEVIATION])){
									if(DEBUG == 1) gse << "Preassign is true " << endl;
									preassigntripchange = true;
								}


							}
						}

						if((actualTT > aAllowedTT  && actualTT > 0)){
							if((actualTT - aAllowedTT) > (int)to_number(schd_tab[(int)to_number(temproute[i][20])][TRVLTIMEDEVIATION])){
								if(DEBUG == 1) gse << "Preassign is true " << endl;
								preassigntripchange = true;
							}
						}
					}


					//   if(DEBUG == 1) gse << "Stop number " <<p_stop_num << " ..  " <<  aStp << " " << temproute[i-1][5]<< endl;


					//else if(temproute[i-1][5] == "Y" && p_stop_num < aStp + 5 && aStpfinished){ //back to back insertion
					//  if(DEBUG == 1) gse <<" Distance3 " << disttravpu <<  " " << prev_distance << " " << origdistpu << endl;

					//}






					if(DEBUG == 1) gse << p_stop_num << " \t " << p_promised_time << " \t " << p_eta << " \t " << p_etd << " \t "  << setprecision(2) << prev_distance <<  "  \t" << p_timetonextstop << " \t " << p_stop_type << "\t " << p_wc_occ << " \t" << p_amb_occ << "\t" << p_esc << " " << arrivetime1 << " " << departtime1 << " " << p_trip_type << " " << temproute[i][20] << " " << temproute[i][3] <<  " end time: " <<  endtime1 << " lat longs " << temproute[i][10] << "," << temproute[i][37] << endl;


					//    if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;

					/*** 1. Check for WC violations ***/
					if (temproute[i][0] == "" && p_disability.find("WC") != string::npos && p_stop_num >=aStp) {
						if (to_number(wc_cap1) == 0) {
							if(!finished){
								oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
								//strcpy( schd_tab[local_s_tab[i]][0] ,"");


								//    if(DEBUG == 1) gse << "1 " << a_route << endl;



								if(DEBUG == 1) gse <<  oResult << "\n\n";
								ontime = false;
								//recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
								// break;
							}
							finished = true;


						}
					} //general


					/*** 2. Check for Capacity Violation ***/
					if ((p_wc_occ> (int)to_number(wc_cap1)) &&  p_stop_num >=aStp || (p_amb_occ > (int)to_number(amb_cap1) && p_stop_num >=aStp)
							|| (p_cs_occ > cs_cap  &&  p_stop_num >=aStp) || (p_bs_occ > bs_cap  &&  p_stop_num >=aStp)) {
						//   if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;
						if(!finished){
							// string route = schd_tab[local_s_tab[1]][0];
							oResult = "NOK Capacity Violation when assigning Trip on Segment " + p_td_segmentid;
							//strcpy( schd_tab[local_s_tab[i]][0] ,"");


							//  if(DEBUG == 1) gse << "2 " << a_route << endl;

							if(DEBUG == 1) gse <<  oResult <<"\n\n";
							//recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
							ontime = false;
							/// break;
						}
						finished = true;


					} //per stop number




					if (p_return_trip == "Y"){
						aLatepickup = p_OTHERLATEPICKFACTOR1;
					}
					else{
						aLatepickup = p_DIALRIDELATEPICKFACTOR1;
					}


					if(preassigntripchange){

						if(DEBUG == 1) gse << "It is not a preassigned trip" << endl;

						/***3. Pickup Window violation *****/
						if (true && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" && (p_stop_num >= aStp )) {

							if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50) )// p_DIALRIDELATEPICKFACTOR )
							{
								//   if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
								// oDropETA = " Dropoff ETA:  ;" ;




								if(!finished /*&& !triedRecalc*/){

									if(DEBUG == 1) gse << "Outside pick up window " << endl;


									/* if(!finishedrecalc){
                    triedRecalc = recalcUpFB(&(temproute), i-1);
                    //if(!triedRecalc){
                        //i--; ////// commented SJ
                        finishedrecalc = true;
                    continue;
                   // }
                }*/

									//    if(DEBUG == 1) gse << "After recalc up times1: " << endl;
									//for(int p = 0; p < i+1; p++){
									//    if(DEBUG == 1) gse << temproute[p][2] << " \t " << temproute[p][4]  << " \t " << temproute[p][29]  << " \t " << temproute[p][30]  << " \t "  << setprecision(2) << temproute[p][6]  <<  "  \t" << temproute[p][28]  << " \t " << temproute[p][7]  << "\t " << temproute[p][32]  << " \t" << temproute[p][31] << "\t" << temproute[p][13]  << " " << temproute[p][23]  << " " << temproute[p][24]  << " " << temproute[p][8]  << " " << temproute[p][20] <<  " end time: " <<  temproute[p][27]  << endl;
									//}

									string tripid4 = temproute[i][3];
									oResult = "Impact: " + tripid4 +" Pickup is outside the window with start time: " + itms_minutes_to_ampm(((int)to_number(starttime1)+aLatepickup)); //oResult
									//  strcpy( schd_tab[local_s_tab[i]][0] ,"");


									//   if(DEBUG == 1) gse << "3 " << a_route << endl;

									if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
									ontime = false; //-------------------------------------------------------------------------------------remove in production
									//recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
									// break;
									finished = true;
									triedRecalc = true;
								}


								//finished = true;

							}

						}



						/*** 4. Check if someone is late for Appointment ***/
						/** Added condition if the appt. time is not null and return_trip = Y **/
						if (true && p_stop_num >=aStp && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"&& (p_stop_num >= aStp)))
						{

							if((((itms_to_minutes(ampm2fullhrs(p_eta))) > /*12 +*/ (int)to_number(endtime1) + floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0))
							{



								if(!finished /*&& !triedRecalc*/){

									if(DEBUG == 1) gse << "possibly late "<<endl;
									//   if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;
									// triedRecalc = recalcUpFB(&(temproute), i-1);

									/* if(!finishedrecalc){
                    triedRecalc = recalcUpFB(&(temproute), i-1);
                    //if(!triedRecalc){
                        //i--; ////// commented SJ
                        finishedrecalc = true;
                    continue;
                   // }
                }*/

									//     if(DEBUG == 1) gse << "After recalc up times2: " << endl;
									//for(int p = 0; p < i+1; p++){
									//    if(DEBUG == 1) gse << temproute[p][2] << " \t " << temproute[p][4]  << " \t " << temproute[p][29]  << " \t " << temproute[p][30]  << " \t "  << setprecision(2) << temproute[p][6]  <<  "  \t" << temproute[p][28]  << " \t " << temproute[p][7]  << "\t " << temproute[p][32]  << " \t" << temproute[p][31] << "\t" << temproute[p][13]  << " " << temproute[p][23]  << " " << temproute[p][24]  << " " << temproute[p][8]  << " " << temproute[p][20] <<  " end time: " <<  temproute[p][27]  << endl;
									//}
									string tripid4 = temproute[i][3];
									oResult = "Impact: " +  tripid4 + " will be late: " + to_string((int)itms_to_minutes(ampm2fullhrs(p_eta)) - (int)to_number(endtime1) ) +
											" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
									// strcpy( schd_tab[local_s_tab[i]][0] ,"");
									if(DEBUG == 1) gse <<   oResult <<"\n\n";


									//  if(DEBUG == 1) gse << "4 " << a_route << endl;
									ontime = false;// -------------------------------------------------------------------------------------remove in production
									//recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
									// break;
									finished = true;
								}
								//finished = true;
							}
						}


						/**** 5. Check if it exceeds the Travel Time ****/
						if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ &&  actualTT > 0 && p_stop_num >=aStp){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {
							if(!finished){
								string tripid4 = temproute[i][3];
								oResult = "Impact: Travel Time Violation on Trip: " + tripid4  + " TT: " + to_string( actualTT) + " Allowed: " + to_string(aAllowedTT) + " Seg: " + temproute[i][0];
								// strcpy( schd_tab[local_s_tab[i]][0] ,"");

								if(DEBUG == 1) gse << oResult;


								ontime = false; //-------------------------------------------------------------------------------------remove in production
								//  if(DEBUG == 1) gse << "5 " << a_route << endl;
								//recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
								//break;



							}
							finished = true;

						}



					}

					if(p_stop_num==(int)to_number(MAXSTOPNUM[0])){



						//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }


						if(oResult == "")   if(DEBUG == 1) gse << "The indicies are inserted after " << indafter1 << " and " << indafter2  << " and the segment is " << temproute[i][0] << " with tripid " << temproute[i][3] <<endl;

						if(/*oResult == "" &&*/ ontime == true){
							if(DEBUG == 1) gse << "Final times " << endl;
							for(int p = 0; p < counter; p++){
								if(DEBUG == 1) gse << temproute[p][2] << " \t " << temproute[p][4]  << " \t " << temproute[p][29]  << " \t " << temproute[p][30]  << " \t "  << setprecision(2) << temproute[p][6]  <<  "  \t" << temproute[p][28]  << " \t " << temproute[p][7]  << "\t " << temproute[p][32]  << " \t" << temproute[p][31] << "\t" << temproute[p][13]  << " " << temproute[p][23]  << " " << temproute[p][24]  << " " << temproute[p][8]  << " " << temproute[p][20] <<  " end time: " <<  temproute[p][27]  << " lat longs " << temproute[p][10] << "," << temproute[p][37] << endl;
							}
							oResult = "Impact: On time";


							/* for(int i = 1; i < counter; i++){

            if(DEBUG == 1) gse << s_tab[m][i] << endl;

      }
							 */

							if(DEBUG == 1) gse << "Checking " << process_tab[LOADDB][0] << endl;

							if(DEBUG == 1) gse << "finished calculating" <<endl;

							if(DEBUG == 1) gse << "Printing S_Tab" << endl;

							for(int k = 1; k < MAXSTOPS; k++){
								if(s_tab[m][k]== 0){break;}
								// while(strcmp(schd_tab[s_tab[m][k]][0],segmentroute.c_str())==0){
								if(DEBUG == 1) gse << s_tab[m][k] << endl;
								// }
							}


							for(int k = 1; k < MAXSTOPS; k++){

								if(s_tab[m][k]== 0){break;}

								// while(strcmp(schd_tab[s_tab[m][k]][0],segmentroute.c_str())==0){
								s_tab[m][k]=0;
								// }
							}
							int deletecount =0;

							strcpy((process_tab[FB][0]) , ("RUNNING"));
							if(DEBUG == 1) gse << "Im going to start deleting " << endl;

							for(int i = 0; i < counter; i++){
								if(DEBUG == 1) gse << i << " out of " << counter << endl;
								if(i ==0 ){
									if(temproute[i][43]== "Y" || (temproute[i+1][43]== "Y" && i+1 != counter)){
										int t=0;
										if(strcmp(schd_tab_delete[0][2], "")!=0){
											for(int z = 0; z < MAXSEGMENTS; z++){
												if(strcmp(schd_tab_delete[z][2], "")==0){
													t = z;
													break;
												}
											}
											strcpy((schd_tab_delete)[t][0] , segment.c_str());
											strcpy((schd_tab_delete)[t][1] , date.c_str());
											strcpy((schd_tab_delete)[t][2] , temproute[i][20].c_str());
											deletecount++;
										}
										else{
											strcpy((schd_tab_delete)[0][0] , segment.c_str());
											strcpy((schd_tab_delete)[0][1] , date.c_str());
											strcpy((schd_tab_delete)[0][2] , temproute[i][20].c_str());
											deletecount++;

										}

										if(DEBUG == 1) gse << "Inserting into delete for " << temproute[i][20] << endl;
									}

								}
								else{
									if(temproute[i][43]== "Y" || (temproute[i-1][43]== "Y" && i != 0)|| (temproute[i+1][43]== "Y" && i+1 != counter)){
										int t=0;
										if(strcmp(schd_tab_delete[0][2], "")!=0){
											for(int z = 0; z < MAXSEGMENTS; z++){
												if(strcmp(schd_tab_delete[z][2], "")==0){
													t = z;
													break;
												}
											}
											strcpy((schd_tab_delete)[t][0] , segment.c_str());
											strcpy((schd_tab_delete)[t][1] , date.c_str());
											strcpy((schd_tab_delete)[t][2] , temproute[i][20].c_str());
											deletecount++;
										}
										else{
											strcpy((schd_tab_delete)[0][0] , segment.c_str());
											strcpy((schd_tab_delete)[0][1] , date.c_str());
											strcpy((schd_tab_delete)[0][2] , temproute[i][20].c_str());
											deletecount++;

										}

										if(DEBUG == 1) gse << "Inserting into delete for " << temproute[i][20] << endl;
									}

								}



							}


							strcpy((process_tab[FB][0]) , ("DONE"));
							if(DEBUG == 1) gse << "Done! " <<endl;
							int stopnum;
							int stopnum2;


							int b = 0;
							while (true){

								if(strcmp(schd_tab_delete[b][2], "") == 0){
									b++;
									if(DEBUG == 1) gse << b << " out of " << deletecount << endl;
								}
								if(b == deletecount || deletecount == 0)
									break;
							}

							if(DEBUG == 1) gse << "The counter " << counter << endl;


							strcpy((process_tab[FB][0]) , ("RUNNING"));

							for(int i = 0; i < counter; i++){
								int o = i+1;


								if(temproute[i][2] == "1") {
									stopnum = 1;
									stopnum2 = 5;
								}
								else if(temproute[i][2] == MAXSTOPNUM[0]){
									stopnum = (int)to_number(MAXSTOPNUM[0]);
									stopnum2 = (int)to_number(MAXSTOPNUM[0]);
								}
								else  {
									stopnum  = stopnum+5;
									stopnum2  = stopnum+5;
								}


								strcpy((schd_tab_unprocess)[o][0] ,temproute[0][0].c_str());
								strcpy((schd_tab_unprocess[o][1]) , temproute[i][1].c_str());
								strcpy((schd_tab_unprocess[o][2]) , to_string(stopnum).c_str());
								strcpy((schd_tab_unprocess[o][3]) , temproute[i][3].c_str());
								strcpy((schd_tab_unprocess[o][4]) , temproute[i][4].c_str());
								strcpy((schd_tab_unprocess[o][5]) , temproute[i][5].c_str());
								strcpy((schd_tab_unprocess[o][6]) , temproute[i][6].c_str());
								//   if(DEBUG == 1) gse << temproute[i][20] << "  " <<   temproute[i][6] << endl;
								strcpy((schd_tab_unprocess[o][7]) , temproute[i][7].c_str());
								strcpy((schd_tab_unprocess[o][8]) , temproute[i][8].c_str());
								strcpy((schd_tab_unprocess[o][9]) , temproute[i][9].c_str());
								strcpy((schd_tab_unprocess[o][10]) , temproute[i][10].c_str());
								strcpy((schd_tab_unprocess[o][11]) , temproute[i][11].c_str());
								strcpy((schd_tab_unprocess[o][12]) , temproute[i][12].c_str());
								strcpy((schd_tab_unprocess[o][13]) , temproute[i][13].c_str());
								strcpy((schd_tab_unprocess[o][14]) , temproute[i][14].c_str());
								strcpy((schd_tab_unprocess[o][15]) , temproute[i][15].c_str());
								strcpy((schd_tab_unprocess[o][16]) , temproute[i][16].c_str());
								strcpy((schd_tab_unprocess[o][17]) , temproute[i][17].c_str());
								strcpy((schd_tab_unprocess[o][18]) , temproute[i][18].c_str());
								strcpy((schd_tab_unprocess[o][19]) , to_string(stopnum2).c_str());
								strcpy((schd_tab_unprocess[o][20]) , temproute[i][20].c_str());
								strcpy((schd_tab_unprocess[o][21]) , temproute[i][21].c_str());
								strcpy((schd_tab_unprocess[o][22]) , temproute[i][22].c_str());
								strcpy((schd_tab_unprocess[o][23]) , temproute[i][23].c_str());
								strcpy((schd_tab_unprocess[o][24]) , temproute[i][24].c_str());
								strcpy((schd_tab_unprocess[o][25]) , temproute[i][25].c_str());
								strcpy((schd_tab_unprocess[o][26]) , temproute[i][26].c_str());
								strcpy((schd_tab_unprocess[o][27]) , temproute[i][27].c_str());
								strcpy((schd_tab_unprocess[o][28]) , temproute[i][28].c_str());
								strcpy((schd_tab_unprocess[o][29]) , temproute[i][29].c_str());
								strcpy((schd_tab_unprocess[o][30]) , temproute[i][30].c_str());
								strcpy((schd_tab_unprocess[o][31]) , temproute[i][31].c_str());
								strcpy((schd_tab_unprocess[o][32]) , temproute[i][32].c_str());
								strcpy((schd_tab_unprocess[o][33]) , temproute[i][33].c_str());
								strcpy((schd_tab_unprocess[o][34]) , temproute[i][34].c_str());
								strcpy((schd_tab_unprocess[o][35]) , temproute[i][35].c_str());
								strcpy((schd_tab_unprocess[o][36]) , temproute[i][36].c_str());
								strcpy((schd_tab_unprocess[o][37]) , temproute[i][37].c_str());
								strcpy((schd_tab_unprocess[o][38]) , temproute[i][38].c_str());
								strcpy((schd_tab_unprocess[o][39]) , temproute[i][39].c_str());
								strcpy((schd_tab_unprocess[o][41]) , temproute[i][41].c_str());
								strcpy((schd_tab_unprocess[o][42]) , temproute[i][42].c_str());
								strcpy((schd_tab_unprocess[o][DIRTYBIT]) , ("N"));
								strcpy((schd_tab_unprocess[o][OPER_ID]) , temproute[i][OPER_ID].c_str());
								strcpy((schd_tab_unprocess[o][SUGG_RES_NUM]) , temproute[i][SUGG_RES_NUM].c_str());
								strcpy((schd_tab_unprocess[o][ORIG_PROMTIME]) , temproute[i][ORIG_PROMTIME].c_str());
								strcpy((schd_tab_unprocess[o][SITE]) , temproute[i][SITE].c_str());
								strcpy((schd_tab_unprocess[o][NEIGHBORS]) , temproute[i][NEIGHBORS].c_str());
								strcpy((schd_tab_unprocess[o][PICKUPIDX]) , temproute[i][PICKUPIDX].c_str());
								strcpy((schd_tab_unprocess[o][GRPIDX]) , temproute[i][GRPIDX].c_str());
								strcpy((schd_tab_unprocess[o][DWWAIT]) , temproute[i][DWWAIT].c_str());
								strcpy((schd_tab_unprocess[o][PWWAIT]) , temproute[i][PWWAIT].c_str());
								strcpy((schd_tab_unprocess[o][CS_OCC]) , temproute[i][CS_OCC].c_str());
								strcpy((schd_tab_unprocess[o][BS_OCC]) , temproute[i][BS_OCC].c_str());
								strcpy((schd_tab_unprocess[o][SEGMENTTYPE]), temproute[i][SEGMENTTYPE].c_str());
								strcpy((schd_tab_unprocess[o][43]) , ("Y"));
								strcpy((schd_tab_unprocess[o][44]) , ("Y"));

								if(DEBUG == 1) gse << "Inputting " <<temproute[0][0] << " " <<  stopnum << " " << temproute[i][3] << endl;

								/*if(temproute[i+1][5]== "Y" || temproute[i][5]== "Y" ){
            strcpy((schd_tab_unprocess[o][43]) , ("Y"));
            strcpy((schd_tab_unprocess[o][44]) , ("Y"));
            }
            else{
            strcpy((schd_tab_unprocess[o][43]) , ("N"));
            strcpy((schd_tab_unprocess[o][44]) , ("N"));
            }*/

								/* if(temproute[i][5]== "Y"){
            command = "Update "+table_itms_trips +" set  RES_NUM = '" + temproute[i][0] + "', LAST_SEGMENTID = '"+last_seg+"', pu_last_segmentid = '"+last_seg+"', do_last_segmentid = '"+last_seg+"' where tripid = '" + temproute[i][3] +"'";
              if(DEBUG == 1) gse << command << endl;
                    stmt = conn->createStatement (command);
                    stmt->executeUpdate();
                    conn->commit();
                    conn->terminateStatement(stmt);
            }*/




								//   if(DEBUG == 1) gse << temproute[i][0] << endl;

								if(stopnum == 1) {
									//    if(DEBUG == 1) gse << "reseting stop numb" <<endl;
									stopnum = 0;
									//stopnum2 = 5;
								}



							}


							strcpy((process_tab[FB][0]) , ("DONE"));




							if(DEBUG == 1) gse << "waiting on dbwrite" <<endl;


							bool once = false;

							if(DEBUG == 1) gse << "Checking " << schd_tab_unprocess[1][10] << " " << process_tab[FB][0] << " " << process_tab[LOADDB][0] << " " << schd_tab_delete[0][0] <<  endl;

							if(DEBUG == 1) gse << "Starting while true loop " << endl;
							int t = 1;
							while (true){

								/* if(strcmp(schd_tab_unprocess[t][10],"")==0 && t < counter){
                t++;
                  if(DEBUG == 1) gse << "T is " << t << " and counter " << counter << endl;
            }

                if(strcmp(schd_tab_unprocess[t][10],"")==0 && !once){
                   if(DEBUG == 1) gse << "schd_tab_unprocess is empty" <<endl;

                    once = true;
                }
								 */
								if(strcmp(process_tab[ACCESS][0], ("READY")) == 0 && strcmp((process_tab[DBWRITE][0]) , ("DONE"))==0){
									if(DEBUG == 1) gse << "Finished and breaking" <<endl;
									break;
								}
								if(strcmp(process_tab[ACCESS][0], ("READY")) == 0 && strcmp((process_tab[DBWRITE][0]) , ("DONE"))==0){
									if(DEBUG == 1) gse << "After Finished and breaking" <<endl;
								}
							}

							if(DEBUG == 1) gse << "after while true loop" <<endl;

							if(DEBUG == 1) gse << "Recalc after insert " << endl;
							string loaddb = "nohup /usr/local/bin/GSE_"+siteSize+"/gse_calc " + client + " "+ " S" + to_string(routeint) + " 1 " + date;
							strcpy(process_tab[RECALCSTATUS][0], ("RUNNING"));
							std::system(loaddb.c_str()); //---------------recalc
							if(DEBUG == 1) gse <<loaddb <<endl;

							//  if(DEBUG == 1) gse <<process_tab[RECALCSTATUS][0] <<" " <<RECALCSTATUS <<endl;
							while (true) {
								if (strcmp(process_tab[RECALCSTATUS][0], ("DONE")) == 0)
									break;
							}


							if(strcmp(USEREVERSECALC[0],"Y")==0){
								if(DEBUG == 1) gse << "We are going to reverse calc on the segment now " << endl;

								for(int i = 0; i < MAXSEGMENTS; i++){
									if(s_tab[i][0] == 0)
										break;
									if(s_tab[i][0] == routeint){
										string loaddb = "nohup /usr/local/bin/GSE_"+siteSize+"/gse_reversecalc " + client +" BATS" + to_string(routeint) +  " 1 " + date;
										strcpy(process_tab[RECALCSTATUS][0], ("RUNNING"));
										std::system(loaddb.c_str()); //---------------recalc
										if(DEBUG == 1) gse <<loaddb <<endl;
										break;
									}
								}

								while (true){
									if(strcmp((process_tab[DBWRITE][0]) , ("DONE"))==0){
										if(DEBUG == 1) gse << "Finished and breaking" <<endl;

										break;
									}

								}

							}




							/*         if(DEBUG == 1) gse << "Matching dates? " << schd_tab[puid][1] << " " << schd_tab[doid][1] << " " << date << endl;
            if(strcmp(schd_tab[puid][1],date.c_str())==0 && strcmp(schd_tab[doid][1],date.c_str())==0){
             Environment* env = Environment::createEnvironment();
            Connection* conn = env->createConnection( username, password, connectString );
             if(DEBUG == 1) gse << "Environment and Connection created" << endl;


            string command = "BEGIN ITMS_AVL_SEND_CHANGES_SRVR ('"+date+"', '"+schd_tab[doid][0]+"'); END;";
              if(DEBUG == 1) gse << command << endl;
            Statement *stmt = conn->createStatement(command);
            stmt->execute();

            env->terminateConnection(conn);
            }

							 */
							/*   if(DEBUG == 1) gse <<" after clearing " << endl;
      for(int i = 1; i < counter; i++){

            if(DEBUG == 1) gse << s_tab[m][i] << endl;

      }*/
							// sleep(6); /////clean sleep!



							if(DEBUG == 1) gse << "finished inserting into new segment" <<endl;

							//updateDatabase(counter,m, env, conn, schd_tab,s_tab, table_itms_segments, table_itms_trips);


							return true;



						}


					}


				}


			}


		}

	}



	return false;





}


void UPDATE_REVERSE_CALCULATE_TEMPARRAY (int counter, string (*temproute)[MAXSTOPS][TRIPCOLSIZE]){
	string aTravel_Date;
	int aStop_num;
	string aStop_type;
	int aPerf_time;
	int aPromised_time;
	int aETA;
	int aETD;
	int aTIMETONEXTSTOP;
	string aTripid;
	string aReturn_trip;
	int aNew_etd;
	int aNew_eta;
	int aPrev_etd = 0;
	int aPrev_eta = 0;
	int aPrev_pt = 0;
	int aPrev_tt = 0;
	int aEndTime;
	int aTetd;
	string aDisability;
	string aTripType;
	int index;
	int nextindex = 0;
	int previndex = 0;
	int aPwtime = 0;



	if(DEBUG == 1) gse << "In reverse " << endl;

	for(int m = counter-1; m >= 0; m--){

		if((int)to_number((*temproute)[m][20]) == 0){
			if(DEBUG == 1) gse << "Test index " << endl;
			continue;
		}


		if(DEBUG == 1) gse << "Found the route .." << (*temproute)[m][20] << " recalcing " << endl;


		aTravel_Date = (*temproute)[m][1];
		aStop_num = (int)to_number((*temproute)[m][2]);
		aStop_type = (*temproute)[m][7];
		aPerf_time = (int)to_number((*temproute)[m][25]);
		aPromised_time = (int)to_number((*temproute)[m][4]);
		aETA = (int)to_number((*temproute)[m][29]);
		aETD = (int)to_number((*temproute)[m][30]);
		aEndTime = (int)to_number((*temproute)[m][27]);
		if(m>0){
			aTIMETONEXTSTOP = (int)to_number((*temproute)[m-1][CALCULATEDTIME]); //because it's technically timeFROMlaststop
			if(DEBUG == 1) gse << "aTIMETONEXTSTOP " << aTIMETONEXTSTOP << " " <<(*temproute)[m][20] << " " << CALCULATEDTIME<< " " << (*temproute)[m][CALCULATEDTIME] <<  endl;
		}
		else
			aTIMETONEXTSTOP = 0;
		aTripid = (*temproute)[m][3];
		aReturn_trip = (*temproute)[m][18];
		aDisability = (*temproute)[m][12];
		aTripType = (*temproute)[m][8];
		index = (int)to_number((*temproute)[m][20]);

		if( m+1 != counter && m+1 != counter){
			nextindex = (int)to_number((*temproute)[m+1][20]);
			if(DEBUG == 1) gse << "Next index is " << nextindex << endl;
		}
		else {
			nextindex = 0;
		}

		if(m != 0 ){
			previndex = (int)to_number((*temproute)[m-1][20]);
		}
		else{
			previndex = 0;
		}



		int p_WHEELLOAD1;
		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;
		string pReturn_trip = (*temproute)[m][18];
		string pDisability = (*temproute)[m][12];
		string p_trip_type1 = (*temproute)[m][8];

		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

		int aLatepickup;
		int aStartTime =  (int)to_number((*temproute)[m][26]);

		if (pReturn_trip == "Y"){
			aLatepickup = p_OTHERLATEPICKFACTOR1;
		}
		else{
			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
		}

		if(pReturn_trip == "N" && aStop_type == "P" && ((aStartTime > 0 && aETA < aStartTime + aLatepickup) || (aStartTime == 0))){

			if (m !=counter-1 && aPrev_etd != 0 && (int)to_number((*temproute)[m][20]) != 0)
			{

				if (aStop_type == "D")
				{
					if (aPerf_time == 0){

						aPerf_time = 0;
					}

					aNew_etd = aPrev_etd - aPrev_pt - aPrev_tt;
					if (aPrev_eta > 0){
						if(DEBUG == 1) gse << "Prev eta " << aPrev_eta << endl;
						aNew_etd = aPrev_eta - aPrev_tt;
						if(DEBUG == 1) gse << "Prev eta 2 " << aNew_etd << " " << aPrev_tt << endl;
					}

					if (aNew_etd < aETD)
					{
						if(DEBUG == 1) gse << "here " << aETD << endl;
						aETD = aNew_etd;
					}


					if (!CheckIfBreak ("Dummy", aTripType))
					{
						if (aDisability.find("WC",0)!= string::npos)
						{
							aNew_eta = aNew_etd - aPerf_time;
							if(DEBUG == 1) gse << "New Eta " << aNew_eta << " " << aNew_etd << endl;

							if(aEndTime > 0 && aNew_eta > aEndTime){
								if(DEBUG == 1) gse << "aEndTime " << aEndTime  <<  endl;
								aNew_eta = aEndTime;
								aNew_etd = aNew_eta+aPerf_time;
							}
							aPrev_pt = aPerf_time;
						}
						else
						{
							aNew_eta = aNew_etd - aPerf_time;
							if(DEBUG == 1) gse << "New Eta " << aNew_eta << endl;

							if(aEndTime > 0 && aNew_eta > aEndTime){
								if(DEBUG == 1) gse << "aEndTime " << aEndTime  <<  endl;
								aNew_eta = aEndTime;
								aNew_etd = aNew_eta+aPerf_time;
							}
							aPrev_pt = aPerf_time;
						}
					}
					else {
						aNew_eta = aETA;
					}


					aETD = aNew_etd;
					aETA = aNew_eta;
					aPrev_etd = aETD;
					aPrev_eta = aETA;
					aPrev_pt = aPerf_time;
					aPrev_tt = aTIMETONEXTSTOP;
				}
				else{
					if (aPerf_time == 0)
					{
						aPerf_time = 0;
					}

					if (!CheckIfBreak ("Dummy", aTripType))
					{

						aNew_etd = aPrev_etd - aPrev_pt - aPrev_tt;
						if (aPrev_eta  > 0){
							aNew_etd = aPrev_eta - aPrev_tt;
							if(DEBUG == 1) gse << "Using etd" << aNew_etd << endl;
						}

						if(DEBUG == 1) gse << "The index is " << (*temproute)[m][20] << endl;



						aNew_eta = aNew_etd - aPerf_time;
						if(DEBUG == 1) gse << "New Eta " << aNew_eta << endl;

						if(aStartTime > 0 && aNew_eta > aStartTime + aLatepickup){
							if(DEBUG == 1) gse << "aStartTime + aLatepickup " << aStartTime << " + " <<  aLatepickup <<  endl;
							aNew_eta = aStartTime + aLatepickup;
							aNew_etd = aNew_eta+aPerf_time;
						}


					}
					else{
						aNew_etd = aETD;
						aNew_eta = aETA;
					}

					aETD = aNew_etd;
					aETA = aNew_eta;
					aPrev_etd = aETD;
					aPrev_eta = aETA;
					aPrev_pt = aPerf_time;
					aPrev_tt = aTIMETONEXTSTOP;
				}





				if(isSameLocation(nextindex,index) && strcmp(schd_tab[nextindex][7],schd_tab[index][7])==0){
					(*temproute)[m][25]= to_string(aPerf_time);
					int h = m;
					strcpy(schd_tab[index][29], to_string(aETA).c_str());
					//  if(DEBUG == 1) gse << "m/h is " << m << " " << schd_tab[s_tab[i][h]][2] << endl;
					while(h+1 != counter && isSameLocation((int)to_number((*temproute)[h+1][20]),index) && strcmp(schd_tab[(int)to_number((*temproute)[h+1][20])][7],schd_tab[index][7])==0 ){
						strcpy(schd_tab[(int)to_number((*temproute)[h+1][20])][29], to_string(aETA).c_str());
						h++;
						if(DEBUG == 1) gse << "h is " << (int)to_number((*temproute)[h][20]) << " " << (int)to_number((*temproute)[h+1][20]) <<  endl;
					}
					int r = h-1;
					strcpy(schd_tab[index][30], to_string(aETD).c_str());
					//   if(DEBUG == 1) gse << "r is " << r << " " <<  schd_tab[s_tab[i][r]][2] << endl;
					while(r!= 0 && (int)to_number((*temproute)[r][20]) != 0 && r+1 != counter && isSameLocation((int)to_number((*temproute)[r][20]),index) && strcmp(schd_tab[(int)to_number((*temproute)[r][20])][7],schd_tab[index][7])==0){
						strcpy(schd_tab[(int)to_number((*temproute)[r][20])][30],to_string(aETD).c_str());
						r--;
					}
					if(DEBUG == 1) gse << "Done " << endl;

					aETA = (int)to_number((*temproute)[m][29]);
					aETD = (int)to_number((*temproute)[m][30]);
					aPrev_etd = aETD;
					aPrev_eta = aETA;

					//if (aStop_num != 1)
						if(DEBUG == 1) gse << "Same stops " <<  aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;
				}



				else{


					(*temproute)[m][25]= to_string(aPerf_time);
					(*temproute)[m][29]= to_string(aETA);
					(*temproute)[m][30]= to_string(aETD);
					if (aStop_num != 1)
						if(DEBUG == 1) gse << aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;


					if(m+1 != counter){

						string aStop_type1 = (*temproute)[m+1][7];

						if(aStop_type1 == "P"){
							aPwtime = (int)to_number((*temproute)[m][26]);
						}
						else{
							aPwtime = (int)to_number((*temproute)[m][27]);
						}

						int eta = (int)to_number((*temproute)[m+1][29]);
						int etd = aETD;
						int TT = aTIMETONEXTSTOP;
						int prom_time = (int)to_number((*temproute)[m+1][4]);
						int perf_time = (int)to_number((*temproute)[m+1][25]);

						string tripidforwait = (*temproute)[m+1][3];
						int DW = eta - etd + TT;
						int PW = getPWByStop (tripidforwait,  (*temproute)[m+1][7],eta, aPwtime);
						(*temproute)[m+1][DWWAIT],to_string(DW);
						(*temproute)[m+1][PWWAIT],to_string(PW);

					}

				}




				if (m == 0)
				{
					if (aTripid.substr(0,1) == "S")
					{
						if (aETD < 30)
						{
							aETA = 0;
						}
						else
						{
							aETA = (aETD - 30);
						}

						(*temproute)[m][29]= to_string(aETA);
						(*temproute)[m][30]= to_string(aETD);
						if(DEBUG == 1) gse << aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;


						if(m+1 != counter){

							string aStop_type1 = (*temproute)[m+1][7];

							if(aStop_type1 == "P"){
								aPwtime = (int)to_number((*temproute)[m][26]);
							}
							else{
								aPwtime = (int)to_number((*temproute)[m][27]);
							}

							int eta = (int)to_number((*temproute)[m+1][29]);
							int etd = aETD;
							int TT = aTIMETONEXTSTOP;
							int prom_time = (int)to_number((*temproute)[m+1][4]);
							int perf_time = (int)to_number((*temproute)[m+1][25]);

							string tripidforwait = (*temproute)[m+1][3];
							int DW = eta - etd + TT;
							int PW = getPWByStop (tripidforwait,  (*temproute)[m+1][7],eta, aPwtime);
							(*temproute)[m+1][DWWAIT]=to_string(DW);
							(*temproute)[m+1][PWWAIT]=to_string(PW);

						}

					}

				}
			}
			else {
				aPrev_etd = (int)to_number((*temproute)[m][30]);
				aPrev_pt = (int)to_number((*temproute)[m][25]);
				aPrev_tt = (int)to_number((*temproute)[m-1][CALCULATEDTIME]);
				aPrev_eta = aPrev_etd - aPrev_pt;
				string tripid = (*temproute)[m][3];
				(*temproute)[m][29]= to_string(aPrev_eta);
				(*temproute)[m][30]= to_string(aPrev_etd);
				if(DEBUG == 1) gse << "End stop " <<  aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aPrev_eta) << " etd " << itms_minutes_to_ampm(aPrev_etd) << " perf time " << aPerf_time << " " <<   endl;

			}
		}
		else{
			aPrev_etd = (int)to_number((*temproute)[m][30]);
			aPrev_eta = (int)to_number((*temproute)[m][29]);
			aPrev_pt = (int)to_number((*temproute)[m][25]);
			if(m>0)
				aPrev_tt = (int)to_number((*temproute)[m-1][CALCULATEDTIME]);
			if(DEBUG == 1) gse << aStop_num << " Not a outbound pickup " << aStop_type << " eta " << itms_minutes_to_ampm(aPrev_eta) << " etd " << itms_minutes_to_ampm(aPrev_etd) << " perf time " << aPrev_pt << " " <<  aPrev_tt << endl;

		}


	}


}

void UPDATE_REVERSE_CALCULATE_BATCH(int counter,int * local_s_tab, string a_route){
	string aTravel_Date;
	int aStop_num;
	string aStop_type;
	int aPerf_time;
	int aPromised_time;
	int aETA;
	int aETD;
	int aTIMETONEXTSTOP;
	string aTripid;
	string aReturn_trip;
	int aNew_etd;
	int aNew_eta;
	int aPrev_etd = 0;
	int aPrev_eta = 0;
	int aPrev_pt = 0;
	int aPrev_tt = 0;
	int aEndTime;
	int aTetd;
	string aDisability;
	string aTripType;
	int index;
	int nextindex = 0;
	int previndex = 0;
	int aPwtime = 0;



	if(DEBUG == 1) gse << "In reverse " << endl;

	if(a_route == ""){


		for(int m = counter-1; m >= 0; m--){

			if(local_s_tab[m] == 0){
				if(DEBUG == 1) gse << "Test index " << endl;
				continue;
			}


			if(DEBUG == 1) gse << "Found the route .." << local_s_tab[m] << " recalcing " << endl;


			aTravel_Date = schd_tab[local_s_tab[m]][1];
			aStop_num = (int)to_number(schd_tab[local_s_tab[m]][2]);
			aStop_type = schd_tab[local_s_tab[m]][7];
			aPerf_time = (int)to_number(schd_tab[local_s_tab[m]][25]);
			aPromised_time = (int)to_number(schd_tab[local_s_tab[m]][4]);
			aETA = (int)to_number(schd_tab[local_s_tab[m]][29]);
			aETD = (int)to_number(schd_tab[local_s_tab[m]][30]);
			aEndTime = (int)to_number(schd_tab[local_s_tab[m]][27]);
			if(m>0){
				aTIMETONEXTSTOP = (int)to_number(schd_tab[local_s_tab[m-1]][CALCULATEDTIME]); //because it's technically timeFROMlaststop
				if(DEBUG == 1) gse << "aTIMETONEXTSTOP " << aTIMETONEXTSTOP << " " <<local_s_tab[m] << " " << CALCULATEDTIME<< " " << schd_tab[local_s_tab[m]][CALCULATEDTIME] <<  endl;
			}
			else
				aTIMETONEXTSTOP = 0;
			aTripid = schd_tab[local_s_tab[m]][3];
			aReturn_trip = schd_tab[local_s_tab[m]][18];
			aDisability = schd_tab[local_s_tab[m]][12];
			aTripType = schd_tab[local_s_tab[m]][8];
			index = (int)to_number(schd_tab[local_s_tab[m]][20]);

			if( m+1 != counter && local_s_tab[m+1] != 0){
				nextindex = (int)to_number(schd_tab[local_s_tab[m+1]][20]);
				if(DEBUG == 1) gse << "Next index is " << nextindex << endl;
			}
			else {
				nextindex = 0;
			}

			if(m != 0 && local_s_tab[m-1] != 0){
				previndex = (int)to_number(schd_tab[local_s_tab[m-1]][20]);
			}
			else{
				previndex = 0;
			}


			int p_WHEELLOAD1;
			int p_AMBLOAD1;
			int p_MAXEARLYDROPOFFFACTOR1;
			int p_DIALRIDEEARLYPICKFACTOR1;
			int p_DIALRIDELATEPICKFACTOR1;
			int p_OTHEREARLYPICKFACTOR1;
			int p_OTHERLATEPICKFACTOR1;
			string IGNOREPUTIMES1;
			int p_SHORTBREAK1;
			int p_LUNCHBREAK1;
			int p_PROXIMITYFACTOR1;
			int a_mediumshortdistance1;
			int a_mediumlongdistance1;
			int a_shorttriptime1;
			int a_longtriptime1;
			int a_mediumtriptime1;
			int a_extra_loadtime1;
			string ZONE_DESCR1;
			string IGNORE_DEPOTS_CUTOFF1;


			string pReturn_trip = schd_tab[local_s_tab[m]][18];
			string pDisability = schd_tab[local_s_tab[m]][12];
			string p_trip_type1 = schd_tab[local_s_tab[m]][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

			int aLatepickup;
			int aStartTime =  (int)to_number(schd_tab[local_s_tab[m]][26]);

			if (pReturn_trip == "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}


			if(pReturn_trip == "N" && aStop_type == "P" && ((aStartTime > 0 && aETA < aStartTime + aLatepickup)|| (aStartTime == 0))){


				if (m !=counter-1 && aPrev_etd != 0 && local_s_tab[m] != 0)
				{

					if (aStop_type == "D")
					{
						if (aPerf_time == 0){

							aPerf_time = 0;
						}

						aNew_etd = aPrev_etd - aPrev_pt - aPrev_tt;
						if (aPrev_eta > 0){
							if(DEBUG == 1) gse << "Prev eta " << aPrev_eta << endl;
							aNew_etd = aPrev_eta - aPrev_tt;
							if(DEBUG == 1) gse << "Prev eta 2 " << aNew_etd << " " << aPrev_tt << endl;
						}

						if (aNew_etd < aETD)
						{
							if(DEBUG == 1) gse << "here " << aETD << endl;
							aETD = aNew_etd;
						}


						if (!CheckIfBreak ("Dummy", aTripType))
						{
							if (aDisability.find("WC",0)!= string::npos)
							{
								aNew_eta = aNew_etd - aPerf_time;
								if(DEBUG == 1) gse << "New Eta " << aNew_eta << " " << aNew_etd << endl;

								if(aEndTime > 0 && aNew_eta > aEndTime){
									if(DEBUG == 1) gse << "aEndTime " << aEndTime  <<  endl;
									aNew_eta = aEndTime;
									aNew_etd = aNew_eta+aPerf_time;
								}
								aPrev_pt = aPerf_time;
							}
							else
							{
								aNew_eta = aNew_etd - aPerf_time;
								if(DEBUG == 1) gse << "New Eta " << aNew_eta << endl;

								if(aEndTime > 0 && aNew_eta > aEndTime){
									if(DEBUG == 1) gse << "aEndTime " << aEndTime  <<  endl;
									aNew_eta = aEndTime;
									aNew_etd = aNew_eta+aPerf_time;
								}
								aPrev_pt = aPerf_time;
							}
						}
						else {
							aNew_eta = aETA;
						}


						aETD = aNew_etd;
						aETA = aNew_eta;
						aPrev_etd = aETD;
						aPrev_eta = aETA;
						aPrev_pt = aPerf_time;
						aPrev_tt = aTIMETONEXTSTOP;
					}
					else{
						if (aPerf_time == 0)
						{
							aPerf_time = 0;
						}

						if (!CheckIfBreak ("Dummy", aTripType))
						{

							aNew_etd = aPrev_etd - aPrev_pt - aPrev_tt;
							if (aPrev_eta  > 0){
								aNew_etd = aPrev_eta - aPrev_tt;
								if(DEBUG == 1) gse << "Using etd" << aNew_etd << endl;
							}


							if(DEBUG == 1) gse << "The index is " << local_s_tab[m] << endl;

							string pReturn_trip = schd_tab[local_s_tab[m]][18];
							string pDisability = schd_tab[local_s_tab[m]][12];
							string p_trip_type1 = schd_tab[local_s_tab[m]][8];

							set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
									p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
									a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

							int aLatepickup;
							int aStartTime =  (int)to_number(schd_tab[local_s_tab[m]][26]);

							if (pReturn_trip == "Y"){
								aLatepickup = p_OTHERLATEPICKFACTOR1;
							}
							else{
								aLatepickup = p_DIALRIDELATEPICKFACTOR1;
							}

							aNew_eta = aNew_etd - aPerf_time;
							if(DEBUG == 1) gse << "New Eta " << aNew_eta << endl;

							if(aStartTime > 0 && aNew_eta > aStartTime + aLatepickup){
								if(DEBUG == 1) gse << "aStartTime + aLatepickup " << aStartTime << " + " <<  aLatepickup <<  endl;
								aNew_eta = aStartTime + aLatepickup;
								aNew_etd = aNew_eta+aPerf_time;
							}


						}
						else{
							aNew_etd = aETD;
							aNew_eta = aETA;
						}

						aETD = aNew_etd;
						aETA = aNew_eta;
						aPrev_etd = aETD;
						aPrev_eta = aETA;
						aPrev_pt = aPerf_time;
						aPrev_tt = aTIMETONEXTSTOP;
					}





					if(isSameLocation(nextindex,index) && strcmp(schd_tab[nextindex][7],schd_tab[index][7])==0){
						strcpy(schd_tab[local_s_tab[m]][25], to_string(aPerf_time).c_str());
						int h = m;
						strcpy(schd_tab[index][29], to_string(aETA).c_str());
						//  if(DEBUG == 1) gse << "m/h is " << m << " " << schd_tab[s_tab[i][h]][2] << endl;
						while(h+1 != counter && local_s_tab[h+1] != 0 && local_s_tab[h] != 0 && isSameLocation(local_s_tab[h+1],index) && strcmp(schd_tab[local_s_tab[h+1]][7],schd_tab[index][7])==0 ){
							strcpy(schd_tab[local_s_tab[h+1]][29], to_string(aETA).c_str());
							h++;
							if(DEBUG == 1) gse << "h is " << local_s_tab[h] << " " << local_s_tab[h+1] <<  endl;
						}
						int r = h-1;
						strcpy(schd_tab[index][30], to_string(aETD).c_str());
						//   if(DEBUG == 1) gse << "r is " << r << " " <<  schd_tab[s_tab[i][r]][2] << endl;
						while(r!= 0 && local_s_tab[r] != 0 && local_s_tab[r+1] != 0 && isSameLocation(local_s_tab[r],index) && strcmp(schd_tab[local_s_tab[r]][7],schd_tab[index][7])==0){
							strcpy(schd_tab[local_s_tab[r]][30],to_string(aETD).c_str());
							r--;
						}
						if(DEBUG == 1) gse << "Done " << endl;

						//aETA = (int)to_number(schd_tab[local_s_tab[m]][29]);
						//aETD = (int)to_number(schd_tab[local_s_tab[m]][30]);
						aPrev_etd = aETD;
						aPrev_eta = aETA;

						//if (aStop_num != 1)
						if(DEBUG == 1) gse << "Same stops " <<  aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;
					}



					else{


						strcpy(schd_tab[local_s_tab[m]][25], to_string(aPerf_time).c_str());
						strcpy(schd_tab[local_s_tab[m]][29], to_string(aETA).c_str());
						strcpy(schd_tab[local_s_tab[m]][30], to_string(aETD).c_str());
						//if (aStop_num != 1)
						if(DEBUG == 1) gse << aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;


						if(local_s_tab[m+1] != 0){

							string aStop_type1 = schd_tab[local_s_tab[m+1]][7];

							if(aStop_type1 == "P"){
								aPwtime = (int)to_number(schd_tab[local_s_tab[m]][26]);
							}
							else{
								aPwtime = (int)to_number(schd_tab[local_s_tab[m]][27]);
							}

							int eta = (int)to_number(schd_tab[local_s_tab[m+1]][29]);
							int etd = aETD;
							int TT = aTIMETONEXTSTOP;
							int prom_time = (int)to_number(schd_tab[local_s_tab[m+1]][4]);
							int perf_time = (int)to_number(schd_tab[local_s_tab[m+1]][25]);

							string tripidforwait = schd_tab[local_s_tab[m+1]][3];
							int DW = eta - etd + TT;
							int PW = getPWByStop (tripidforwait,  schd_tab[local_s_tab[m+1]][7],eta, aPwtime);
							strcpy(schd_tab[local_s_tab[m+1]][DWWAIT],to_string(DW).c_str());
							strcpy(schd_tab[local_s_tab[m+1]][PWWAIT],to_string(PW).c_str());

						}

					}




					if (m == 0)
					{
						// if (aTripid.substr(0,1) == "S")
						// {
						if (aETD < 30)
						{
							aETA = 0;
						}
						else
						{
							aETA = (aETD - 30);
						}

						strcpy(schd_tab[local_s_tab[m]][29], to_string(aETA).c_str());
						strcpy(schd_tab[local_s_tab[m]][30], to_string(aETD).c_str());
						if(DEBUG == 1) gse << aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;


						if(local_s_tab[m+1] != 0){

							string aStop_type1 = schd_tab[local_s_tab[m+1]][7];

							if(aStop_type1 == "P"){
								aPwtime = (int)to_number(schd_tab[local_s_tab[m]][26]);
							}
							else{
								aPwtime = (int)to_number(schd_tab[local_s_tab[m]][27]);
							}

							int eta = (int)to_number(schd_tab[local_s_tab[m+1]][29]);
							int etd = aETD;
							int TT = aTIMETONEXTSTOP;
							int prom_time = (int)to_number(schd_tab[local_s_tab[m+1]][4]);
							int perf_time = (int)to_number(schd_tab[local_s_tab[m+1]][25]);

							string tripidforwait = schd_tab[local_s_tab[m+1]][3];
							int DW = eta - etd + TT;
							int PW = getPWByStop (tripidforwait,  schd_tab[local_s_tab[m+1]][7],eta, aPwtime);
							strcpy(schd_tab[local_s_tab[m+1]][DWWAIT],to_string(DW).c_str());
							strcpy(schd_tab[local_s_tab[m+1]][PWWAIT],to_string(PW).c_str());

						}

						// }

					}
				}
				else {
					aPrev_etd = (int)to_number(schd_tab[local_s_tab[m]][30]);
					aPrev_pt = (int)to_number(schd_tab[local_s_tab[m]][25]);
					aPrev_tt = (int)to_number(schd_tab[local_s_tab[m-1]][CALCULATEDTIME]);
					aPrev_eta = aPrev_etd - aPrev_pt;
					string tripid = schd_tab[local_s_tab[m]][3];
					strcpy(schd_tab[local_s_tab[m]][29], to_string(aPrev_eta).c_str());
					strcpy(schd_tab[local_s_tab[m]][30], to_string(aPrev_etd).c_str());
					if(DEBUG == 1) gse << "End stop in normal reverse " <<  aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aPrev_eta) << " etd " << itms_minutes_to_ampm(aPrev_etd) << " perf time " << aPerf_time << " " <<   endl;

				}
			}
			else{
				aPrev_etd = (int)to_number(schd_tab[local_s_tab[m]][30]);
				aPrev_eta = (int)to_number(schd_tab[local_s_tab[m]][29]);
				aPrev_pt = (int)to_number(schd_tab[local_s_tab[m]][25]);
				if(m>0)
					aPrev_tt = (int)to_number(schd_tab[local_s_tab[m-1]][CALCULATEDTIME]);
				if(DEBUG == 1) gse << aStop_num << " Not a outbound pickup " << aStop_type << " eta " << itms_minutes_to_ampm(aPrev_eta) << " etd " << itms_minutes_to_ampm(aPrev_etd) << " perf time " << aPrev_pt << " " <<  aPrev_tt << endl;

			}


		}
	}
	else{

		int routeint = (int)to_number(a_route.substr(1,a_route.length()));
		if(DEBUG == 1) gse  << "Route is " <<a_route << endl;

		for(int i = 0; i < MAXSEGMENTS; i++){

			if(s_tab[i][0]==routeint){

				//cout << "Found the route .." << s_tab[i][0] << " recalcing " << endl;

				for(int k = MAXSTOPS-1; k >= 1; k--){

					//if(DEBUG == 1) gse  << "k is " << k << " " <<  schd_tab[s_tab[i][k]][2] << endl;

					if(strcmp(schd_tab[s_tab[i][k]][2],MAXSTOPNUM[0])==0){
						counter = k;
						if(DEBUG == 1) gse << "Found the route .." << s_tab[i][0] << " recalcing " << endl;

						for(int m = counter; m >= 1; m--){



							aTravel_Date = schd_tab[s_tab[i][m]][1];
							aStop_num = (int)to_number(schd_tab[s_tab[i][m]][2]);
							aStop_type = schd_tab[s_tab[i][m]][7];
							aPerf_time = (int)to_number(schd_tab[s_tab[i][m]][25]);
							aPromised_time = (int)to_number(schd_tab[s_tab[i][m]][4]);
							aEndTime = (int)to_number(schd_tab[s_tab[i][m]][27]);
							aETA = (int)to_number(schd_tab[s_tab[i][m]][29]);
							aETD = (int)to_number(schd_tab[s_tab[i][m]][30]);
							if(m>1)
								aTIMETONEXTSTOP = (int)to_number(schd_tab[s_tab[i][m-1]][CALCULATEDTIME]); //because it's technically timeFROMlaststop
								else
									aTIMETONEXTSTOP = 0;
							aTripid = schd_tab[s_tab[i][m]][3];
							aReturn_trip = schd_tab[s_tab[i][m]][18];
							aDisability = schd_tab[s_tab[i][m]][12];
							aTripType = schd_tab[s_tab[i][m]][8];
							index = (int)to_number(schd_tab[s_tab[i][m]][20]);

							if(s_tab[i][m+1] != 0 && strcmp(schd_tab[s_tab[i][m]][2],MAXSTOPNUM[0])!=0 && strcmp(schd_tab[s_tab[i][m+1]][2],MAXSTOPNUM[0])!=0){
								nextindex = (int)to_number(schd_tab[s_tab[i][m+1]][20]);
							}
							else {
								nextindex = 0;
							}

							if(m > 1 && strcmp(schd_tab[s_tab[i][m]][2],"1")!=0 && strcmp(schd_tab[s_tab[i][m-1]][2],"1")!=0){
								previndex = (int)to_number(schd_tab[s_tab[i][m-1]][20]);
							}
							else{
								previndex = 0;
							}


							int p_WHEELLOAD1;
							int p_AMBLOAD1;
							int p_MAXEARLYDROPOFFFACTOR1;
							int p_DIALRIDEEARLYPICKFACTOR1;
							int p_DIALRIDELATEPICKFACTOR1;
							int p_OTHEREARLYPICKFACTOR1;
							int p_OTHERLATEPICKFACTOR1;
							string IGNOREPUTIMES1;
							int p_SHORTBREAK1;
							int p_LUNCHBREAK1;
							int p_PROXIMITYFACTOR1;
							int a_mediumshortdistance1;
							int a_mediumlongdistance1;
							int a_shorttriptime1;
							int a_longtriptime1;
							int a_mediumtriptime1;
							int a_extra_loadtime1;
							string ZONE_DESCR1;
							string IGNORE_DEPOTS_CUTOFF1;


							string pReturn_trip = schd_tab[s_tab[i][m]][18];
							string pDisability = schd_tab[s_tab[i][m]][12];
							string p_trip_type1 = schd_tab[s_tab[i][m]][8];

							set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
									p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
									a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

							int aLatepickup;
							int aStartTime =  (int)to_number(schd_tab[s_tab[i][m]][26]);

							if (pReturn_trip == "Y"){
								aLatepickup = p_OTHERLATEPICKFACTOR1;
							}
							else{
								aLatepickup = p_DIALRIDELATEPICKFACTOR1;
							}



							if(pReturn_trip == "N" && aStop_type == "P" && ((aStartTime > 0 && aETA < aStartTime + aLatepickup)|| (aStartTime == 0))){

								if (m < counter)
								{

									if (aStop_type == "D")
									{
										if (aPerf_time == 0){

											aPerf_time = 0;
										}

										aNew_etd = aPrev_etd - aPrev_pt - aPrev_tt;
										if (aPrev_eta >0){
											if(DEBUG == 1) gse << "Prev eta " << aPrev_eta << endl;
											aNew_etd = aPrev_eta - aPrev_tt;
										}

										if (aNew_etd < aETD)
										{
											aETD = aNew_etd;
										}


										if (!CheckIfBreak ("Dummy", aTripType))
										{
											if (aDisability.find("WC",0)!= string::npos)
											{
												aNew_eta = aNew_etd - aPerf_time;
												if(DEBUG == 1) gse << "New Eta " << aNew_eta << endl;

												if(aEndTime > 0 && aNew_eta > aEndTime){
													if(DEBUG == 1) gse << "aEndTime " << aEndTime  <<  endl;
													aNew_eta = aEndTime;
													aNew_etd = aNew_eta+aPerf_time;
												}
												aPrev_pt = aPerf_time;
											}
											else
											{
												aNew_eta = aNew_etd - aPerf_time;
												if(DEBUG == 1) gse << "New Eta " << aNew_eta << endl;

												if(aEndTime > 0 && aNew_eta > aEndTime){
													if(DEBUG == 1) gse << "aEndTime " << aEndTime  <<  endl;
													aNew_eta = aEndTime;
													aNew_etd = aNew_eta+aPerf_time;
												}
												aPrev_pt = aPerf_time;
											}
										}
										else {
											aNew_eta = aETA;
										}


										aETD = aNew_etd;
										aETA = aNew_eta;
										aPrev_etd = aETD;
										aPrev_eta = aETA;
										aPrev_pt = aPerf_time;
										aPrev_tt = aTIMETONEXTSTOP;
									}
									else{
										if (aPerf_time == 0)
										{
											aPerf_time = 0;
										}

										if (!CheckIfBreak ("Dummy", aTripType))
										{

											aNew_etd = aPrev_etd - aPrev_pt - aPrev_tt;
											if (aPrev_eta  > 0){
												aNew_etd = aPrev_eta - aPrev_tt;
											}


											aNew_eta = aNew_etd - aPerf_time;
											if(DEBUG == 1) gse << "New Eta " << aNew_eta << endl;

											if(aStartTime > 0 && aNew_eta > aStartTime + aLatepickup){
												if(DEBUG == 1) gse << "aStartTime + aLatepickup " << aStartTime << " + " <<  aLatepickup <<  endl;
												aNew_eta = aStartTime + aLatepickup;
												aNew_etd = aNew_eta+aPerf_time;
											}


										}
										else{
											aNew_etd = aETD;
											aNew_eta = aETA;
										}

										aETD = aNew_etd;
										aETA = aNew_eta;
										aPrev_etd = aETD;
										aPrev_eta = aETA;
										aPrev_pt = aPerf_time;
										aPrev_tt = aTIMETONEXTSTOP;
									}



									if(isSameLocation(nextindex,index) && strcmp(schd_tab[nextindex][7],schd_tab[index][7])==0){
										strcpy(schd_tab[s_tab[i][m]][25], to_string(aPerf_time).c_str());
										int h = m;
										strcpy(schd_tab[index][29], to_string(aETA).c_str());
										//  if(DEBUG == 1) gse << "m/h is " << m << " " << schd_tab[s_tab[i][h]][2] << endl;
										while(h+1 != counter && s_tab[i][h+1] != 0 && s_tab[i][h] != 0 && isSameLocation(s_tab[i][h+1],index) && strcmp(schd_tab[s_tab[i][h+1]][7],schd_tab[index][7])==0 ){
											strcpy(schd_tab[s_tab[i][h+1]][29], to_string(aETA).c_str());
											h++;
										}
										int r = h-1;
										strcpy(schd_tab[index][30], to_string(aETD).c_str());
										//   if(DEBUG == 1) gse << "r is " << r << " " <<  schd_tab[s_tab[i][r]][2] << endl;
										while(r!= 0 && s_tab[i][r] != 0 && s_tab[i][r+1] != 0 && isSameLocation(s_tab[i][r],index) && strcmp(schd_tab[s_tab[i][r]][7],schd_tab[index][7])==0){
											strcpy( schd_tab[s_tab[i][r]][30],to_string(aETD).c_str());
											r--;
										}

										aETA = (int)to_number(schd_tab[s_tab[i][m]][29]);
										aETD = (int)to_number(schd_tab[s_tab[i][m]][30]);
										aPrev_etd = aETD;
										aPrev_eta = aETA;



										//if (aStop_num != 1)
										//  if(DEBUG == 1) gse << "Same as other stop " << aStop_num << " " << aStop_type << " " << aETA << " " << aETD << " " << aPerf_time << " " <<   endl;
									}

									else{
										strcpy(schd_tab[s_tab[i][m]][25], to_string(aPerf_time).c_str());
										strcpy(schd_tab[s_tab[i][m]][29], to_string(aETA).c_str());
										strcpy(schd_tab[s_tab[i][m]][30], to_string(aETD).c_str());

										//if (aStop_num != 1)
										if(DEBUG == 1) gse << aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;


										if(s_tab[i][m+1] != 0){
											int eta = (int)to_number(schd_tab[s_tab[i][m+1]][29]);
											int etd = aETD;
											int TT = aTIMETONEXTSTOP;
											int prom_time = (int)to_number(schd_tab[s_tab[i][m+1]][4]);
											int perf_time = (int)to_number(schd_tab[s_tab[i][m+1]][25]);

											string tripidforwait = schd_tab[s_tab[i][m+1]][3];
											int DW = eta - etd + TT;
											int PW = getPWByStop (tripidforwait,  schd_tab[s_tab[i][m+1]][7],eta, prom_time);
											strcpy(schd_tab[s_tab[i][m+1]][DWWAIT],to_string(DW).c_str());
											strcpy(schd_tab[s_tab[i][m+1]][PWWAIT],to_string(PW).c_str());
										}


									}





									if (m == 1)
									{
										// if (aTripid.substr(0,1) == "S")
										//{
										if (aETD < 30)
										{
											aETA = 0;
										}
										else
										{
											aETA = (aETD - 30);
										}

										strcpy(schd_tab[s_tab[i][m]][29], to_string(aETA).c_str());
										strcpy(schd_tab[s_tab[i][m]][30], to_string(aETD).c_str());

										if(DEBUG == 1) gse << aStop_num << " stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;

										if(s_tab[i][m+1] != 0){

											string aStop_type1 = schd_tab[s_tab[i][m+1]][7];

											if(aStop_type1 == "P"){
												aPwtime = (int)to_number(schd_tab[s_tab[i][m]][26]);
											}
											else{
												aPwtime = (int)to_number(schd_tab[s_tab[i][m]][27]);
											}

											int eta = (int)to_number(schd_tab[s_tab[i][m+1]][29]);
											int etd = aETD;
											int TT = aTIMETONEXTSTOP;
											int prom_time = (int)to_number(schd_tab[s_tab[i][m+1]][4]);
											int perf_time = (int)to_number(schd_tab[s_tab[i][m+1]][25]);

											string tripidforwait = schd_tab[s_tab[i][m+1]][3];
											int DW = eta - etd + TT;
											int PW = getPWByStop (tripidforwait,  schd_tab[s_tab[i][m+1]][7],eta, aPwtime);
											strcpy(schd_tab[s_tab[i][m+1]][DWWAIT],to_string(DW).c_str());
											strcpy(schd_tab[s_tab[i][m+1]][PWWAIT],to_string(PW).c_str());

										}


										// }

									}
								}
								else {
									aPrev_etd = (int)to_number(schd_tab[s_tab[i][m]][30]);
									aPrev_pt = (int)to_number(schd_tab[s_tab[i][m]][25]);
									aPrev_tt = (int)to_number(schd_tab[s_tab[i][m-1]][CALCULATEDTIME]);
									aPrev_eta = aPrev_etd - aPrev_pt;
									strcpy(schd_tab[s_tab[i][m]][29], to_string(aPrev_eta).c_str());
									strcpy(schd_tab[s_tab[i][m]][30], to_string(aPrev_etd).c_str());

									if(DEBUG == 1) gse << aStop_num << " End stop one seg stop type " << aStop_type << " eta " << itms_minutes_to_ampm(aETA) << " etd " << itms_minutes_to_ampm(aETD) << " perf time " << aPerf_time << " " <<   endl;
								}
							}
							else{
								aPrev_etd = (int)to_number(schd_tab[s_tab[i][m]][30]);
								aPrev_eta = (int)to_number(schd_tab[s_tab[i][m]][29]);
								aPrev_pt = (int)to_number(schd_tab[s_tab[i][m]][25]);
								if(m>1)
									aPrev_tt = (int)to_number(schd_tab[s_tab[i][m-1]][CALCULATEDTIME]);
								if(DEBUG == 1) gse << aStop_num << " Not a outbound pickup " << aStop_type << " eta " << itms_minutes_to_ampm(aPrev_eta) << " etd " << itms_minutes_to_ampm(aPrev_etd) << " perf time " << aPrev_pt << " " <<  aPrev_tt << endl;

							}








						}

						break;

					}




				}

				break;

			}
		}
	}

}


int reversecalclocal_returnindex(int counter, int * local_s_tab, bool ontime){


	UPDATE_REVERSE_CALCULATE_BATCH(counter, local_s_tab,"");

	create_group(local_s_tab,counter);

	int grouptraveltimeallowance[MAXTRIPIDX];


	for(int i = 0; i < MAXTRIPIDX; i++){
		grouptraveltimeallowance[i] = 0;
	}
	int extratraveltime = 0;
	int groupid = 1;

	string segmenttype = "";
	for(int i = 0; i < counter; i++){
		if(DEBUG == 1) gse << " CHECKING i " << i << " "  << schd_tab[local_s_tab[i]][3] << " " << counter << endl;
		if(strcmp(schd_tab[local_s_tab[i]][0],"")!=0 && strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0 && segmenttype == ""){
			segmenttype = schd_tab[local_s_tab[i]][SEGMENTTYPE];
		}
	}
	int cs_cap = 0;
	int bs_cap = 0;
	//bool isVol = isVolSegment((*temproute)[0][0], (*temproute)[0][1],(*temproute)[0][14]);

	if(segmenttype == ""){
		cs_cap = 999;
		bs_cap = 999;
	}
	else{
		getCS_CY_cap(cs_cap, bs_cap, segmenttype);
	}

	for(int i = 0; i < counter; i++){

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];

		if(DEBUG == 1) gse << " i " << i << " " << groupmark << " " << schd_tab[local_s_tab[i]][3] << endl;



		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"D")==0  && groupmark!= ""){
			//strcpy(schd_tab[local_s_tab[i]][GRPIDX],to_string(groupid).c_str());
			//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
		}
		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"P")==0  && groupmark!= ""){
			groupid++;
		}


	}

	for(int i = 0; i < counter; i++)
	{

		string p_promised_time = schd_tab[local_s_tab[i]][4];
		string p_stop_type =schd_tab[local_s_tab[i]][7];
		string endtime1 = schd_tab[local_s_tab[i]][27];
		string starttime1 = schd_tab[local_s_tab[i]][26];
		string wc_cap1 = schd_tab[local_s_tab[0]][34];
		string amb_cap1 = schd_tab[local_s_tab[0]][33];
		if((int)to_number(schd_tab[local_s_tab[0]][20]) == 0 || strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])!=0){
			wc_cap1 = "999";
			amb_cap1 = "999";
		}
		int p_wc_occ = to_number(schd_tab[local_s_tab[i]][32]);
		int p_amb_occ = to_number(schd_tab[local_s_tab[i]][31]);
		int p_cs_occ = to_number(schd_tab[local_s_tab[i]][CS_OCC]);
		int p_bs_occ = to_number(schd_tab[local_s_tab[i]][BS_OCC]);
		int prom_time = (int)to_number(p_promised_time);
		string est_traveltime1 = schd_tab[local_s_tab[i]][22];
		string p_return_trip = schd_tab[local_s_tab[i]][18];
		int p_stop_num = to_number(schd_tab[local_s_tab[i]][2]);
		int p_eta = to_number(schd_tab[local_s_tab[i]][29]);
		int p_etd = to_number(schd_tab[local_s_tab[i]][30]);
		string oResult = "";
		int actualTT;
		int p_WHEELLOAD1;
		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;

		string pReturn_trip = schd_tab[local_s_tab[i]][18];
		string pDisability = schd_tab[local_s_tab[i]][12];
		string p_trip_type1 = schd_tab[local_s_tab[i]][8];

		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);



		double estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);

		int aAllowedTT;
		/*if(to_number(estdist[0]) < 3.0)
                            aAllowedTT = 50;
                        else if(to_number(estdist[0]) >= 3.0 &&  to_number(estdist[0]) < 6.0)
                            aAllowedTT = 65;
                        else if(to_number(estdist[0]) >= 6.0 &&  to_number(estdist[0])< 9.0)
                            aAllowedTT = 95;
                        else if(to_number(estdist[0]) >= 9.0 &&  to_number(estdist[0]) < 12.0)
                            aAllowedTT = 115;
                        else if(to_number(estdist[0])>= 12.0 && to_number(estdist[0]) < 14.0)
                            aAllowedTT = 135;
                        else if(to_number(estdist[0]) > 14.0)
                            aAllowedTT = 155;*/

		int extratraveltime = 0;

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];
		if(groupmark != ""){
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			extratraveltime = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
			if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
		}


		int allowedDW;
		double esttime = to_number(schd_tab[local_s_tab[i]][22]);

		if(estdisttrip < a_mediumshortdistance1){
			aAllowedTT = a_shorttriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
		}
		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
			aAllowedTT = a_mediumtriptime1 + extratraveltime;
		}
		else{
			aAllowedTT = a_longtriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
		}

		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
		}


		string tripid2 = schd_tab[local_s_tab[i]][3];
		string p_trip_type2 = schd_tab[local_s_tab[i]][8];

		if(strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && (tripid2.substr(0,1) == "T" ||  tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN"){

			int pickupid = (int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX]);
			int doeta1 = (int)to_number(schd_tab[local_s_tab[i]][30]) - (int)to_number(schd_tab[local_s_tab[i]][25]);
			int puetd1 = (int)to_number(schd_tab[pickupid][30]);
			int stopafter;

			for(int t = 0; t < counter; t++){
				if(local_s_tab[t] == pickupid){
					stopafter = local_s_tab[t+1];
					break;
				}
			}

			string pReturn_trip1 = schd_tab[pickupid][18];
			string pDisability1 = schd_tab[pickupid][12];
			string p_trip_type11 = schd_tab[pickupid][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type11);
			int aLatepickup;

			if (pReturn_trip1== "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}


			if((int)to_number(schd_tab[stopafter][30]) - (int)to_number(schd_tab[stopafter][25])  >= (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]) + (int)to_number(schd_tab[pickupid][CALCULATEDTIME])){

				puetd1 = (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]);

				if(DEBUG == 1) gse << "Changing puetd to " << puetd1 << " " << (int)to_number(schd_tab[stopafter][30]) << "  " <<  (int)to_number(schd_tab[stopafter][25]) <<  endl;
			}



			actualTT = doeta1 - puetd1; //flipped eta/etd
			if(DEBUG == 1) gse << "Actual travel time of " << schd_tab[local_s_tab[i]][3] << " " << actualTT << " out of " << aAllowedTT << endl;
		}

		else
			actualTT = 0;




		int aLatepickup;

		if (p_return_trip == "Y"){
			aLatepickup = p_OTHERLATEPICKFACTOR1;
		}
		else{
			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
		}

		if(p_stop_num == (int)to_number(MAXSTOPNUM[0]) && i+1 == counter){
			endtime1 = p_promised_time; // to make sure segments do not go beyond the end'
			//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
		}

		bool preassigntripchange = true;
		if(strcmp(schd_tab[local_s_tab[i]][LATEDEVIATION],"")!=0 || strcmp(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION],"")!=0){
			preassigntripchange = false;
			if ((p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {
				if( p_eta  > (int)to_number(starttime1) + aLatepickup)//p_DIALRIDELATEPICKFACTOR )
				{
					int dev =  p_eta - ((int)to_number(starttime1) + aLatepickup);
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}

				}
			}


			if ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000")
			{
				if((((p_eta)) >  (int)to_number(endtime1) && prom_time != 0))
				{

					int dev =  p_eta - ((int)to_number(endtime1));
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}


				}
			}

			if((actualTT > aAllowedTT  && actualTT > 0)){
				if((actualTT - aAllowedTT) > (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION])){
					if(DEBUG == 1) gse << "The dev is " << (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION]) << endl;
					preassigntripchange = true;
				}
			}
		}

		if(ontime){
			preassigntripchange = false;
		}

		string disability = schd_tab[local_s_tab[i]][12];
		if (schd_tab[local_s_tab[i]][0] == "" && disability.find("WC")>=0) {
			if (to_number(wc_cap1) == 0) {

				oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
				//strcpy( schd_tab[local_s_tab[i]][0] ,"");

				//    if(DEBUG == 1) gse << "1 " << a_route << endl;

				if(DEBUG == 1) gse <<  oResult << "\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }


				if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
					return local_s_tab[i-1];
				}
				else{
					return local_s_tab[i];
				};


			}
		} //general

		/*** 2. Check for Capacity Violation ***/
		if ((p_wc_occ> (int)to_number(wc_cap1) ) || (p_amb_occ > (int)to_number(amb_cap1) )
				|| (p_cs_occ > cs_cap ) || (p_bs_occ > bs_cap  )) {
			//   if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;

			// string route = schd_tab[local_s_tab[1]][0];
			string seg =schd_tab[local_s_tab[i]][0];
			oResult = "NOK Capacity Violation when assigning Trip on Segment " + seg + " with capacities wc, amb " + wc_cap1 + " " + amb_cap1 +" " + to_string(cs_cap) + " " + to_string(bs_cap);
			//strcpy( schd_tab[local_s_tab[i]][0] ,"");


			//  if(DEBUG == 1) gse << "2 " << a_route << endl;


			if(DEBUG == 1) gse <<  oResult <<"\n\n";
			if(DEBUG == 1) gse << " Counts " << p_wc_occ << " " << p_amb_occ << " " << p_cs_occ << " " << p_bs_occ << endl;
			//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

			if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
				return local_s_tab[i-1];
			}
			else{
				return local_s_tab[i];
			};



		} //per stop number


		bool changedeta = true;
		if(changedeta){

			/***3. Pickup Window violation *****/
			if ( preassigntripchange && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {

				if( p_eta  > (int)to_number(starttime1) + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
				{
					//   if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
					// oDropETA = " Dropoff ETA:  ;" ;


					// string route = schd_tab[local_s_tab[1]][0];
					string tripid = schd_tab[local_s_tab[i]][3];
					oResult = "Impact: " + tripid +" Pickup is outside the window with start time: " + itms_minutes_to_ampm((int)to_number(starttime1) + aLatepickup);
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");


					//  if(DEBUG == 1) gse << "2 " << a_route << endl;


					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

					if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
						return local_s_tab[i-1];
					}
					else{
						return local_s_tab[i];
					};

				}

			}



			/*** 4. Check if someone is late for Appointment ***/
			/** Added condition if the appt. time is not null and return_trip = Y **/
			if ( preassigntripchange && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"))
			{



				if((((p_eta)) > /*12 +*/ (int)to_number(endtime1) + floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0)
				{
					if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;

					string tripid = schd_tab[local_s_tab[i]][3];
					oResult = "Impact: " +  tripid + " will be late: " + to_string(p_eta - (int)to_number(endtime1) ) +
							" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
					// strcpy( schd_tab[local_s_tab[i]][0] ,"");
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");


					//  if(DEBUG == 1) gse << "2 " << a_route << endl;


					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

					if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
						return local_s_tab[i-1];
					}
					else{
						return local_s_tab[i];
					};
				}
			}


			/**** 5. Check if it exceeds the Travel Time ****/
			if((preassigntripchange && actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && actualTT > 0)){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {

				string tripid = schd_tab[local_s_tab[i]][3];
				oResult = "Impact: Travel Time Violation on Trip: " + tripid  + " TT: " + to_string(actualTT) + " Allowed: " + to_string(aAllowedTT) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
				// strcpy( schd_tab[local_s_tab[i]][0] ,"");
				//strcpy( schd_tab[local_s_tab[i]][0] ,"");


				//  if(DEBUG == 1) gse << "2 " << a_route << endl;


				if(DEBUG == 1) gse <<  oResult <<"\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

				if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
					return local_s_tab[i-1];
				}
				else{
					return local_s_tab[i];
				};

			}







			if((i>0 &&  ((int)to_number(schd_tab[local_s_tab[i-1]][31]) > 0 || (int)to_number(schd_tab[local_s_tab[i-1]][32]) > 0) && strcmp(schd_tab[local_s_tab[i]][0],"")==0 && strcmp(schd_tab[local_s_tab[i-1]][3],schd_tab[local_s_tab[i-1]][0])!=0 && strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i-1]][3])!=0  && p_stop_type == "P" &&  (int)to_number(schd_tab[local_s_tab[i]][DWWAIT]) > allowedDW + floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && (int)to_number(schd_tab[local_s_tab[i]][DWWAIT]) > 0)){
				string tripid = schd_tab[local_s_tab[i]][3];
				oResult = "Impact: Passenger wait violation: " + tripid  + " PW: " + schd_tab[local_s_tab[i]][DWWAIT] + " Allowed: " + to_string(allowedDW) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
				if(DEBUG == 1) gse <<  oResult <<"\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

				if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
					return local_s_tab[i-1];
				}
				else{
					return local_s_tab[i];
				};
			}





		}

	}
	return 0;
}

bool reversecalclocal_TEMPARRAY(int counter, string (* temproute)[MAXSTOPS][TRIPCOLSIZE], double * tripscore, bool ontime){

	int origscore = *tripscore;
	string oResult = "";

	UPDATE_REVERSE_CALCULATE_TEMPARRAY(counter, &(*temproute));

	int local_s_tab[MAXSTOPS];

	for(int y = 0; y < counter; y++){
		local_s_tab[y] = (int)to_number((*temproute)[y][20]);
	}


	create_group(local_s_tab,counter);

	int grouptraveltimeallowance[MAXTRIPIDX];


	for(int i = 0; i < MAXTRIPIDX; i++){
		grouptraveltimeallowance[i] = 0;
	}
	int extratraveltime = 0;
	int groupid = 1;

	string segmenttype = "";
	for(int i = 0; i < counter; i++){
		if(DEBUG == 1) gse << " CHECKING i " << i << " "  << schd_tab[local_s_tab[i]][3] << " " << counter << endl;
		if(strcmp(schd_tab[local_s_tab[i]][0],"")!=0 && strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0 && segmenttype == ""){
			segmenttype = schd_tab[local_s_tab[i]][SEGMENTTYPE];
		}
	}
	int cs_cap = 0;
	int bs_cap = 0;
	//bool isVol = isVolSegment((*temproute)[0][0], (*temproute)[0][1],(*temproute)[0][14]);

	if(segmenttype == ""){
		cs_cap = 999;
		bs_cap = 999;
	}
	else{
		getCS_CY_cap(cs_cap, bs_cap, segmenttype);
	}

	for(int i = 0; i < counter; i++){

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];

		if(DEBUG == 1) gse << " i " << i << " " << groupmark << " " << schd_tab[local_s_tab[i]][3] << endl;



		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"D")==0  && groupmark!= ""){
			//strcpy(schd_tab[local_s_tab[i]][GRPIDX],to_string(groupid).c_str());
			//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
		}
		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"P")==0  && groupmark!= ""){
			groupid++;
		}


	}


	for(int i = 0; i < counter; i++)
	{

		string p_promised_time = (*temproute)[i][4];
		string p_stop_type =(*temproute)[i][7];
		string endtime1 = (*temproute)[i][27];
		string starttime1 = (*temproute)[i][26];
		string wc_cap1 = (*temproute)[0][34];
		string amb_cap1 = (*temproute)[0][33];
		if((int)to_number((*temproute)[0][20]) == 0 ||(*temproute)[0][3] != (*temproute)[0][0]){
			wc_cap1 = "999";
			amb_cap1 = "999";
		}
		int p_wc_occ = to_number((*temproute)[i][32]);
		int p_amb_occ = to_number((*temproute)[i][31]);
		int p_cs_occ = to_number((*temproute)[i][CS_OCC]);
		int p_bs_occ = to_number((*temproute)[i][BS_OCC]);
		int prom_time = (int)to_number(p_promised_time);
		string est_traveltime1 = (*temproute)[i][22];
		string p_return_trip = (*temproute)[i][18];
		int p_stop_num = to_number((*temproute)[i][2]);
		int p_eta = to_number((*temproute)[i][29]);
		int p_etd = to_number((*temproute)[i][30]);

		int actualTT;
		int p_WHEELLOAD1;
		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;

		string pReturn_trip = (*temproute)[i][18];
		string pDisability = (*temproute)[i][12];
		string p_trip_type1 = (*temproute)[i][8];

		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);



		double estdisttrip = to_number((*temproute)[i][21]);

		int aAllowedTT;
		/*if(to_number(estdist[0]) < 3.0)
                            aAllowedTT = 50;
                        else if(to_number(estdist[0]) >= 3.0 &&  to_number(estdist[0]) < 6.0)
                            aAllowedTT = 65;
                        else if(to_number(estdist[0]) >= 6.0 &&  to_number(estdist[0])< 9.0)
                            aAllowedTT = 95;
                        else if(to_number(estdist[0]) >= 9.0 &&  to_number(estdist[0]) < 12.0)
                            aAllowedTT = 115;
                        else if(to_number(estdist[0])>= 12.0 && to_number(estdist[0]) < 14.0)
                            aAllowedTT = 135;
                        else if(to_number(estdist[0]) > 14.0)
                            aAllowedTT = 155;*/

		int extratraveltime = 0;

		string groupmark = (*temproute)[i][GRPIDX];
		if(groupmark != ""){
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			extratraveltime = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
			if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
		}


		int allowedDW;
		double esttime = to_number((*temproute)[i][22]);

		if(estdisttrip < a_mediumshortdistance1){
			aAllowedTT = a_shorttriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
		}
		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
			aAllowedTT = a_mediumtriptime1 + extratraveltime;
		}
		else{
			aAllowedTT = a_longtriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
		}

		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
		}


		string tripid2 = (*temproute)[i][3];
		string p_trip_type2 = (*temproute)[i][8];

		if((*temproute)[i][7]=="D" && (tripid2.substr(0,1) == "T" ||  tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN"){



			int stopafter;
			int pickupid = (int)to_number((*temproute)[i][PICKUPIDX]);
			if(DEBUG == 1) gse << "pick  " << pickupid << endl;
			for(int t = 0; t < counter; t++){
				if(DEBUG == 1) gse << "t is " << t << endl;
				if((int)to_number((*temproute)[t][20]) == pickupid){
					if(DEBUG == 1) gse << "i is  " << i << " pickup is " << t << endl;
					pickupid = t;
					stopafter = t+1;
					break;
				}
			}
			int doeta1 = (int)to_number((*temproute)[i][30]) - (int)to_number((*temproute)[i][25]);
			int puetd1 = (int)to_number((*temproute)[pickupid][30]);




			string pReturn_trip1 = (*temproute)[pickupid][18];
			string pDisability1 = (*temproute)[pickupid][12];
			string p_trip_type11 = (*temproute)[pickupid][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type11);
			int aLatepickup;

			if (pReturn_trip1== "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}


			if((int)to_number((*temproute)[stopafter][30]) - (int)to_number((*temproute)[stopafter][25])  >= (int)to_number((*temproute)[pickupid][4]) + aLatepickup+ (int)to_number((*temproute)[pickupid][25]) + (int)to_number((*temproute)[pickupid][CALCULATEDTIME])){

				puetd1 = (int)to_number((*temproute)[pickupid][4]) + aLatepickup+ (int)to_number((*temproute)[pickupid][25]);

				if(DEBUG == 1) gse << "Changing puetd to " << puetd1 << " " << (int)to_number((*temproute)[stopafter][30]) << "  " <<  (int)to_number((*temproute)[stopafter][25]) <<  endl;
			}



			actualTT = doeta1 - puetd1; //flipped eta/etd
			if(DEBUG == 1) gse << "Actual travel time of " << (*temproute)[i][3] << " " << actualTT << " out of " << aAllowedTT << endl;
		}

		else
			actualTT = 0;




		int aLatepickup;

		if (p_return_trip == "Y"){
			aLatepickup = p_OTHERLATEPICKFACTOR1;
		}
		else{
			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
		}

		if(p_stop_num == (int)to_number(MAXSTOPNUM[0]) && i+1 == counter){
			endtime1 = p_promised_time; // to make sure segments do not go beyond the end'
			//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
		}

		bool preassigntripchange = true;


		if((int)to_number(schd_tab[(int)to_number((*temproute)[i][20])][LATEDEVIATION])!=0 || (int)to_number(schd_tab[(int)to_number((*temproute)[i][20])][TRVLTIMEDEVIATION])!=0){
			preassigntripchange = false;
			if ((p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {
				if( p_eta  > (int)to_number(starttime1) + aLatepickup)//p_DIALRIDELATEPICKFACTOR )
				{
					int dev =  p_eta - ((int)to_number(starttime1) + aLatepickup);
					if(dev > (int)to_number(schd_tab[(int)to_number((*temproute)[i][20])][LATEDEVIATION])){
						preassigntripchange = true;
					}

				}
			}


			if ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000")
			{
				if((((p_eta)) >  (int)to_number(endtime1) && prom_time != 0))
				{

					int dev =  p_eta - ((int)to_number(endtime1));
					if(dev > (int)to_number(schd_tab[(int)to_number((*temproute)[i][20])][LATEDEVIATION])){
						preassigntripchange = true;
					}


				}
			}

			if((actualTT > aAllowedTT  && actualTT > 0)){
				if((actualTT - aAllowedTT) > (int)to_number(schd_tab[(int)to_number((*temproute)[i][20])][TRVLTIMEDEVIATION])){
					if(DEBUG == 1) gse << "The dev is " << (int)to_number(schd_tab[(int)to_number((*temproute)[i][20])][TRVLTIMEDEVIATION]) << endl;
					preassigntripchange = true;
				}
			}
		}

		//if(ontime){
		//  preassigntripchange = false;
		//}


		string disability = (*temproute)[i][12];
		if ((*temproute)[i][0] == "" && disability.find("WC")>=0) { //JDC comparison of unsigned expression >= 0 is always true [-Wtype-limits]
			if (to_number(wc_cap1) == 0) {

				oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
				//strcpy( (*temproute)[i][0] ,"");

				//    if(DEBUG == 1) gse << "1 " << a_route << endl;

				if(DEBUG == 1) gse <<  oResult << "\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
				*tripscore = *tripscore - 500;



				//return false;


			}
		} //general

		/*** 2. Check for Capacity Violation ***/
		if ((p_wc_occ> (int)to_number(wc_cap1) ) || (p_amb_occ > (int)to_number(amb_cap1) )
				|| (p_cs_occ > cs_cap ) || (p_bs_occ > bs_cap  )) {
			//   if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;

			// string route = schd_tab[local_s_tab[1]][0];
			string seg =(*temproute)[i][0];
			oResult = "NOK Capacity Violation when assigning Trip on Segment " + seg + " with capacities wc, amb " + wc_cap1 + " " + amb_cap1 +" " + to_string(cs_cap) + " " + to_string(bs_cap);
			//strcpy( (*temproute)[i][0] ,"");


			if(p_wc_occ> (int)to_number(wc_cap1)){
				*tripscore = *tripscore - 300;
			}
			if(p_amb_occ > (int)to_number(amb_cap1)){
				*tripscore = *tripscore - 200;

			}
			//  if(DEBUG == 1) gse << "2 " << a_route << endl;


			if(DEBUG == 1) gse <<  oResult <<"\n\n";
			if(DEBUG == 1) gse << " Counts " << p_wc_occ << " " << p_amb_occ << " " << p_cs_occ << " " << p_bs_occ << endl;
			//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

			//return false;



		} //per stop number


		bool changedeta = true;
		if(changedeta){

			/***3. Pickup Window violation *****/
			if ( preassigntripchange && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {

				if( p_eta  > (int)to_number(starttime1) + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
				{
					//   if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
					// oDropETA = " Dropoff ETA:  ;" ;

					int P = p_eta - ((int)to_number(starttime1) + aLatepickup);
					*tripscore = *tripscore - (3*P);
					// string route = schd_tab[local_s_tab[1]][0];
					string tripid = (*temproute)[i][3];
					oResult = "Impact: " + tripid +" Pickup is outside the window with start time: " + itms_minutes_to_ampm((int)to_number(starttime1) + aLatepickup);
					//strcpy( (*temproute)[i][0] ,"");


					//  if(DEBUG == 1) gse << "2 " << a_route << endl;


					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

					//return false;

				}

			}



			/*** 4. Check if someone is late for Appointment ***/
			/** Added condition if the appt. time is not null and return_trip = Y **/
			if ( preassigntripchange && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"))
			{



				if((((p_eta)) > /*12 +*/ (int)to_number(endtime1) + floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0)
				{
					if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;
					int D = p_eta - ((int)to_number(endtime1));
					*tripscore = *tripscore - (5*D);
					string tripid = (*temproute)[i][3];
					oResult = "Impact: " +  tripid + " will be late: " + to_string(p_eta - (int)to_number(endtime1) ) +
							" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
					// strcpy( (*temproute)[i][0] ,"");
					//strcpy( (*temproute)[i][0] ,"");


					//  if(DEBUG == 1) gse << "2 " << a_route << endl;


					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

					//return false;
				}
			}


			/**** 5. Check if it exceeds the Travel Time ****/
			if((preassigntripchange && actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && actualTT > 0)){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {
				int T = actualTT - aAllowedTT;
				*tripscore = *tripscore - (1*T);
				string tripid = (*temproute)[i][3];
				oResult = "Impact: Travel Time Violation on Trip: " + tripid  + " TT: " + to_string(actualTT) + " Allowed: " + to_string(aAllowedTT) + " dist " + to_string(estdisttrip) + " Seg: " + (*temproute)[i][0] + "\n";
				// strcpy( (*temproute)[i][0] ,"");
				//strcpy( (*temproute)[i][0] ,"");


				//  if(DEBUG == 1) gse << "2 " << a_route << endl;


				if(DEBUG == 1) gse <<  oResult <<"\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

				//return false;

			}



			if((i>0 && preassigntripchange && ((int)to_number((*temproute)[i-1][31]) > 0 || (int)to_number((*temproute)[i-1][32]) > 0) && (*temproute)[i-1][0]!=(*temproute)[i-1][3] && (*temproute)[i][3]!=(*temproute)[i-1][3] && (*temproute)[i][0]=="" && p_stop_type == "P" &&  (int)to_number((*temproute)[i][DWWAIT]) > allowedDW + floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && (int)to_number((*temproute)[i][DWWAIT]) > 0)){
				string tripid = (*temproute)[i][3];

				int T = (int)to_number((*temproute)[i][DWWAIT]) - allowedDW;
				*tripscore = *tripscore - (1*T);
				oResult = "Impact: Passenger wait violation: " + tripid  + " PW: " + (*temproute)[i][DWWAIT] + " Allowed: " + to_string(allowedDW) + " dist " + to_string(estdisttrip) + " Seg: " + (*temproute)[i][0] + "\n";
				if(DEBUG == 1) gse <<  oResult <<"\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

				//return false;
			}





		}

	}

	if(oResult != ""){
		return false;
	}
	else{
		return true;
	}

}

bool reversecalclocal(int counter, int * local_s_tab, bool ontime){


	UPDATE_REVERSE_CALCULATE_BATCH(counter, local_s_tab,"");

	create_group(local_s_tab,counter);

	int grouptraveltimeallowance[MAXTRIPIDX];


	for(int i = 0; i < MAXTRIPIDX; i++){
		grouptraveltimeallowance[i] = 0;
	}
	int extratraveltime = 0;
	int groupid = 1;

	string segmenttype = "";
	for(int i = 0; i < counter; i++){
		if(DEBUG == 1) gse << " CHECKING i is " << i << " "  << schd_tab[local_s_tab[i]][3] << " " << counter << endl;
		if(strcmp(schd_tab[local_s_tab[i]][0],"")!=0 && strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0 && segmenttype == ""){
			segmenttype = schd_tab[local_s_tab[i]][SEGMENTTYPE];

		}
	}
	int cs_cap = 0;
	int bs_cap = 0;
	//bool isVol = isVolSegment((*temproute)[0][0], (*temproute)[0][1],(*temproute)[0][14]);

	if(segmenttype == ""){

		cs_cap = 999;
		bs_cap = 999;
	}
	else{
		getCS_CY_cap(cs_cap, bs_cap, segmenttype);
	}

	for(int i = 0; i < counter; i++){

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];

		if(DEBUG == 1) gse << " i " << i << " " << groupmark << " " << schd_tab[local_s_tab[i]][3] << endl;


		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"D")==0  && groupmark!= ""){
			//strcpy(schd_tab[local_s_tab[i]][GRPIDX],to_string(groupid).c_str());
			//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
		}
		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"P")==0  && groupmark!= ""){
			groupid++;
		}


	}


	//bool isVol = isVolSegment(schd_tab[local_s_tab[0]][0], schd_tab[local_s_tab[0]][1],schd_tab[local_s_tab[0]][14]);


	if(DEBUG == 1) gse << "Starting viocheck v1" << endl;

	for(int i = 0; i < counter; i++)
	{

		if(DEBUG == 1) gse << "i is " << i << endl;

		string p_promised_time = schd_tab[local_s_tab[i]][4];
		string p_stop_type =schd_tab[local_s_tab[i]][7];
		string endtime1 = schd_tab[local_s_tab[i]][27];
		string starttime1 = schd_tab[local_s_tab[i]][26];
		string wc_cap1 = schd_tab[local_s_tab[0]][34];
		string amb_cap1 = schd_tab[local_s_tab[0]][33];
		if((int)to_number(schd_tab[local_s_tab[0]][20]) == 0 || strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])!=0){
			wc_cap1 = "999";
			amb_cap1 = "999";
		}
		int p_wc_occ = to_number(schd_tab[local_s_tab[i]][32]);
		int p_amb_occ = to_number(schd_tab[local_s_tab[i]][31]);
		int p_cs_occ = to_number(schd_tab[local_s_tab[i]][CS_OCC]);
		int p_bs_occ = to_number(schd_tab[local_s_tab[i]][BS_OCC]);
		int prom_time = (int)to_number(p_promised_time);
		string est_traveltime1 = schd_tab[local_s_tab[i]][22];
		string p_return_trip = schd_tab[local_s_tab[i]][18];
		int p_stop_num = to_number(schd_tab[local_s_tab[i]][2]);
		int p_eta = to_number(schd_tab[local_s_tab[i]][29]);
		int p_etd = to_number(schd_tab[local_s_tab[i]][30]);
		string oResult = "";
		int actualTT;
		int p_WHEELLOAD1;
		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;

		string pReturn_trip = schd_tab[local_s_tab[i]][18];
		string pDisability = schd_tab[local_s_tab[i]][12];
		string p_trip_type1 = schd_tab[local_s_tab[i]][8];

		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);



		double estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);

		int aAllowedTT;
		/*if(to_number(estdist[0]) < 3.0)
                            aAllowedTT = 50;
                        else if(to_number(estdist[0]) >= 3.0 &&  to_number(estdist[0]) < 6.0)
                            aAllowedTT = 65;
                        else if(to_number(estdist[0]) >= 6.0 &&  to_number(estdist[0])< 9.0)
                            aAllowedTT = 95;
                        else if(to_number(estdist[0]) >= 9.0 &&  to_number(estdist[0]) < 12.0)
                            aAllowedTT = 115;
                        else if(to_number(estdist[0])>= 12.0 && to_number(estdist[0]) < 14.0)
                            aAllowedTT = 135;
                        else if(to_number(estdist[0]) > 14.0)
                            aAllowedTT = 155;*/

		int extratraveltime = 0;

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];
		if(groupmark != ""){
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			extratraveltime = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
			if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
		}


		int allowedDW;
		double esttime = to_number(schd_tab[local_s_tab[i]][22]);

		if(estdisttrip < a_mediumshortdistance1){
			aAllowedTT = a_shorttriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
		}
		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
			aAllowedTT = a_mediumtriptime1 + extratraveltime;
		}
		else{
			aAllowedTT = a_longtriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
		}

		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
		}


		string tripid2 = schd_tab[local_s_tab[i]][3];
		string p_trip_type2 = schd_tab[local_s_tab[i]][8];

		if(strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && (tripid2.substr(0,1) == "T" ||  tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN" && i != 0 && i+1!=counter){

			int pickupid = (int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX]);
			int doeta1 = (int)to_number(schd_tab[local_s_tab[i]][30]) - (int)to_number(schd_tab[local_s_tab[i]][25]);
			int puetd1 = (int)to_number(schd_tab[pickupid][30]);
			int stopafter;

			for(int t = 0; t < counter; t++){
				if(local_s_tab[t] == pickupid){
					stopafter = local_s_tab[t+1];
					break;
				}
			}

			string pReturn_trip1 = schd_tab[pickupid][18];
			string pDisability1 = schd_tab[pickupid][12];
			string p_trip_type11 = schd_tab[pickupid][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type11);
			int aLatepickup;

			if (pReturn_trip1== "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}


			if((int)to_number(schd_tab[stopafter][30]) - (int)to_number(schd_tab[stopafter][25])  >= (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]) + (int)to_number(schd_tab[pickupid][CALCULATEDTIME])){

				puetd1 = (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]);

				if(DEBUG == 1) gse << "Changing puetd to " << puetd1 << " " << (int)to_number(schd_tab[stopafter][30]) << "  " <<  (int)to_number(schd_tab[stopafter][25]) <<  endl;
			}



			actualTT = doeta1 - puetd1; //flipped eta/etd
			if(DEBUG == 1) gse << "Actual travel time of " << schd_tab[local_s_tab[i]][3] << " " << actualTT << " out of " << aAllowedTT << endl;
		}

		else
			actualTT = 0;




		int aLatepickup;

		if (p_return_trip == "Y"){
			aLatepickup = p_OTHERLATEPICKFACTOR1;
		}
		else{
			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
		}

		if(p_stop_num == (int)to_number(MAXSTOPNUM[0]) && i+1 == counter){
			endtime1 = p_promised_time; // to make sure segments do not go beyond the end'
			//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
		}

		bool preassigntripchange = true;
		if(strcmp(schd_tab[local_s_tab[i]][LATEDEVIATION],"")!=0 || strcmp(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION],"")!=0){
			preassigntripchange = false;
			if ((p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {
				if( p_eta  > (int)to_number(starttime1) + aLatepickup)//p_DIALRIDELATEPICKFACTOR )
				{
					int dev =  p_eta - ((int)to_number(starttime1) + aLatepickup);
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}

				}
			}


			if ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000")
			{
				if((((p_eta)) >  (int)to_number(endtime1) && prom_time != 0))
				{

					int dev =  p_eta - ((int)to_number(endtime1));
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}


				}
			}

			if((actualTT > aAllowedTT  && actualTT > 0)){
				if((actualTT - aAllowedTT) > (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION])){
					if(DEBUG == 1) gse << "The dev is " << (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION]) << endl;
					preassigntripchange = true;
				}
			}
		}

		if(ontime){
			preassigntripchange = false;
		}


		string disability = schd_tab[local_s_tab[i]][12];
		if (schd_tab[local_s_tab[i]][0] == "" && disability.find("WC")>=0) {
			if (to_number(wc_cap1) == 0) {

				oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
				//strcpy( schd_tab[local_s_tab[i]][0] ,"");

				//    if(DEBUG == 1) gse << "1 " << a_route << endl;

				if(DEBUG == 1) gse <<  oResult << "\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }


				return false;


			}
		} //general

		/*** 2. Check for Capacity Violation ***/
		if ((p_wc_occ> (int)to_number(wc_cap1) ) || (p_amb_occ > (int)to_number(amb_cap1) )
				|| (p_cs_occ > cs_cap ) || (p_bs_occ > bs_cap  )) {
			//   if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;

			// string route = schd_tab[local_s_tab[1]][0];
			string seg =schd_tab[local_s_tab[i]][0];
			oResult = "NOK Capacity Violation when assigning Trip on Segment " + seg + " with capacities wc, amb " + wc_cap1 + " " + amb_cap1 +" " + to_string(cs_cap) + " " + to_string(bs_cap);

			//strcpy( schd_tab[local_s_tab[i]][0] ,"");


			//  if(DEBUG == 1) gse << "2 " << a_route << endl;


			if(DEBUG == 1) gse <<  oResult << " Counts " << p_wc_occ << " " << p_amb_occ << " " << p_cs_occ << " " << p_bs_occ << endl;


			//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

			return false;



		} //per stop number


		bool changedeta = true;
		if(changedeta){

			/***3. Pickup Window violation *****/
			if ( preassigntripchange && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {

				if( p_eta  > (int)to_number(starttime1) + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
				{
					//   if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
					// oDropETA = " Dropoff ETA:  ;" ;


					// string route = schd_tab[local_s_tab[1]][0];
					string tripid = schd_tab[local_s_tab[i]][3];
					oResult = "Impact: " + tripid +" Pickup is outside the window with start time: " + itms_minutes_to_ampm((int)to_number(starttime1) + aLatepickup);
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");


					//  if(DEBUG == 1) gse << "2 " << a_route << endl;


					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

					return false;

				}

			}



			/*** 4. Check if someone is late for Appointment ***/
			/** Added condition if the appt. time is not null and return_trip = Y **/
			if ( preassigntripchange && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"))
			{



				if((((p_eta)) > /*12 +*/ (int)to_number(endtime1) + floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0)
				{
					if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;

					string tripid = schd_tab[local_s_tab[i]][3];
					oResult = "Impact: " +  tripid + " will be late: " + to_string(p_eta - (int)to_number(endtime1) ) +
							" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
					// strcpy( schd_tab[local_s_tab[i]][0] ,"");
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");


					//  if(DEBUG == 1) gse << "2 " << a_route << endl;


					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

					return false;
				}
			}


			/**** 5. Check if it exceeds the Travel Time ****/
			if((preassigntripchange && actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && actualTT > 0)){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {

				string tripid = schd_tab[local_s_tab[i]][3];
				oResult = "Impact: Travel Time Violation on Trip: " + tripid  + " TT: " + to_string(actualTT) + " Allowed: " + to_string(aAllowedTT) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
				// strcpy( schd_tab[local_s_tab[i]][0] ,"");
				//strcpy( schd_tab[local_s_tab[i]][0] ,"");


				//  if(DEBUG == 1) gse << "2 " << a_route << endl;


				if(DEBUG == 1) gse <<  oResult <<"\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

				return false;

			}



			if((i>0 &&  ((int)to_number(schd_tab[local_s_tab[i-1]][31]) > 0 || (int)to_number(schd_tab[local_s_tab[i-1]][32]) > 0) && strcmp(schd_tab[local_s_tab[i]][0],"")==0 && strcmp(schd_tab[local_s_tab[i-1]][3],schd_tab[local_s_tab[i-1]][0])!=0 && strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i-1]][3])!=0  && p_stop_type == "P" &&  (int)to_number(schd_tab[local_s_tab[i]][DWWAIT]) > allowedDW + floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && (int)to_number(schd_tab[local_s_tab[i]][DWWAIT]) > 0)){
				string tripid = schd_tab[local_s_tab[i]][3];
				oResult = "Impact: Passenger wait violation: " + tripid  + " PW: " + schd_tab[local_s_tab[i]][DWWAIT] + " Allowed: " + to_string(allowedDW) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
				if(DEBUG == 1) gse <<  oResult <<"\n\n";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

				return false;
			}





		}

	}
	return true;
}




bool checkgrp(int counter, double * distances, int * local_s_tab){


	int p_WHEELLOAD1;
	int p_AMBLOAD1;
	int p_MAXEARLYDROPOFFFACTOR1;
	int p_DIALRIDEEARLYPICKFACTOR1;
	int p_DIALRIDELATEPICKFACTOR1;
	int p_OTHEREARLYPICKFACTOR1;
	int p_OTHERLATEPICKFACTOR1;
	string IGNOREPUTIMES1;
	int p_SHORTBREAK1;
	int p_LUNCHBREAK1;
	int p_PROXIMITYFACTOR1;
	int a_mediumshortdistance1;
	int a_mediumlongdistance1;
	int a_shorttriptime1;
	int a_longtriptime1;
	int a_mediumtriptime1;
	int a_extra_loadtime1;
	string ZONE_DESCR1;
	string IGNORE_DEPOTS_CUTOFF1;


	if(DEBUG == 1) gse << "CHECKING GROUP 1" << endl;

	string origetaholder[counter]; //JDC warning: ISO C++ forbids variable length array origetaholder [-Wvla]
	string origetdholder[counter];
	string origCalculatedTime[counter];

	for(int y = 0; y < counter;y++){

		if(strcmp(schd_tab[local_s_tab[y]][0],"")!=0){
			origetaholder[y] = schd_tab[local_s_tab[y]][29];
			origetdholder[y] = schd_tab[local_s_tab[y]][30];
			origCalculatedTime[y] = schd_tab[local_s_tab[y]][CALCULATEDTIME];
		}
	}




	create_group(local_s_tab,counter);

	int grouptraveltimeallowance[MAXTRIPIDX];


	for(int i = 0; i < MAXTRIPIDX; i++){
		grouptraveltimeallowance[i] = 0;
	}
	int extratraveltime = 0;
	int groupid = 1;

	for(int i = 0; i < counter; i++){
		if(DEBUG == 1) gse << " CHECKING i " << i << " "  << schd_tab[local_s_tab[i]][3] << " " << counter << endl;
	}

	for(int i = 0; i < counter; i++){

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];

		if(DEBUG == 1) gse << " i " << i << " " << groupmark << " " << schd_tab[local_s_tab[i]][3] << endl;



		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"D")==0  && groupmark!= ""){
			//strcpy(schd_tab[local_s_tab[i]][GRPIDX],to_string(groupid).c_str());
			//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
		}
		if(i+1 < counter && strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && strcmp(schd_tab[local_s_tab[i+1]][7],"P")==0  && groupmark!= ""){
			groupid++;
		}


	}



	if(DEBUG == 1) gse << "CHECKING GROUP 1" << endl;

	//  if(DEBUG == 1) gse << "checking late and early factors " <<  p_DIALRIDEEARLYPICKFACTOR[0] << " " <<p_DIALRIDELATEPICKFACTOR[0] << endl;


	//   if(DEBUG == 1) gse << "made it2 " << endl;



	/*string lat1db[2], lon1db[2], tripid1db[1], disabilitydb[1], estdist[1];

//  if(DEBUG == 1) gse << "local " <<  schd_tab[puid][0] << " id " << puid << endl;

 lat1db[0] = schd_tab[puid][10];
 lon1db[0] = schd_tab[puid][37];
 lat1db[1] = schd_tab[puid][10];
 lon1db[1] = schd_tab[puid][37];
tripid1db[0] = schd_tab[puid][3];
disabilitydb[0] = schd_tab[puid][12];
estdist[0] = schd_tab[puid][21];*/
	int SEGSTART  = 0;

	bool routeFound = false;
	string a_route = "STEST";

	//  if(DEBUG == 1) gse << "made it2 " << endl;


	int s_tab_idx;

	if(counter > 0){
		//   if(DEBUG == 1) gse << "COUNTER " << counter << endl;
		if(DEBUG == 1) gse <<"Stop  prom time    eta   etd     dist ttime stoptype    wc    amb \t esc"<< endl;
	}
	std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>  varHolder;
	string p_customer;
	bool notFound;
	int f1 = 0;
	int f2 = 0;


	std::string  promisedtime1;
	int prom_time;
	std::string est_traveltime1;
	std::string arrivetime1;
	std::string departtime1 ;
	std::string perftime1 ;
	int p_perf_time;
	std::string starttime1 ;
	std::string endtime1;
	std::string timetonextstop1 ;
	std::string eta1;
	int eta;
	std::string etd1; /// fix this hack in get next token
	int etd;
	std::string  lat1  ;
	std::string lon1   ;
	std::string lat2 ;
	std::string lon2;
	/// fix this  p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
	///OffLoaded   , p_trip_type ,    p_hack in get next token
	std::string  amb_occ1 ;
	std::string wc_occ1 ;
	int cs_cap = 0;
	int bs_cap = 0;
	std::string amb_cap1 ;
	std::string wc_cap1 ; /// fix this hack in get next token
	int p_amb_occ;
	int p_wc_occ;
	int p_cs_occ;
	int p_bs_occ;
	int p_grp_cnt_wc;
	int p_grp_cnt_amb;
	int s_trip_appt_time = 0;
	int p_latency = 0;
	int p_prev_stop_num;
	int p_prev_perf_time;
	int OffLoaded;
	string p_trip_type ;
	string p_spl_other_desc ;
	int last_wc_occ = 0, last_cs_occ = 0, last_bs_occ = 0;
	int last_amb_occ = 0;
	int last_dep_time ;
	int last_arr_time ;
	int tot_driv_time = 0;
	double tot_miles = 0;
	string p_latestoptime ="";
	string p_earlystoptime= "";
	double p_disttonextstop = 0.0;
	int p_timetonextstop = 0;
	string p_name ;
	string p_return_trip ;
	string p_stop_type ;
	string p_disability = "" ;
	int p_esc;
	string p_td_segmentid = "";
	int stopnum1;
	int p_stop_num;
	int p_early_morning_factor = 0;
	string p_street_by_street = "T";
	string p_citytown;
	string time_zone2 = "*";
	string time_zone;// = "*";
	int petaint;
	string rteStr;
	double disttrav;
	string grp_cnt_amb;
	string grp_cnt_wc;
	string dist;
	string p_promised_time;
	string p_eta;
	string p_etd;
	string capacity;
	string times;
	string prev_perftime1,prev_eta1,prev_etd1, prev_amb_occ1, prev_wc_occ1;
	int prev_eta,prev_etd,prev_p_perf_time;
	//int index;
	//int cnt = 0;
	double disttrav2;
	double prev_distance = 0;


	int AGRPCOUNTER = 0;
	int APRVGRPCOUNTER = 0;
	//bool recalc = false;


	// string indicies = to_string(puid) + "," +to_string(doid);
	string indafter1;string indafter2;


	string pueta;
	string doeta;
	string disttravpu;
	string disttravdo;
	string pustp;
	string dostp;
	string puetd;
	string doetd;
	string latlon1;
	string latlon2;
	string latlon3;
	string latlon4;
	string oResult;
	int actualTT = 0;
	string distholder[counter];
	string origdistholder[MAXSTOPS];
	bool finished = false;
	string route = "STEST";
	//int routeint = (int)to_number(route.substr(1,route.length()));
	int aStp = 1;//first stop to be inserted.
	double estdisttrip = 0.0;
	int numberofpickups = 0;
	string segment = "";
	int cap = (int)to_number(MAXSTOPNUM[0]);
	int wccap = (int)to_number(MAXSTOPNUM[0]);
	int cscap = (int)to_number(MAXSTOPNUM[0]);
	int bscap = (int)to_number(MAXSTOPNUM[0]);
	int index;
	int routeint;
	bool ontime = true;
	string p_prev_promised_time = "0000A";



	//  if(DEBUG == 1) gse << "Counter " << counter << endl;




	if(DEBUG == 1) gse << "Distances and stopnumber and trip id " << endl;
	for(int i = 0; i < counter; i++){

		if(local_s_tab[i] != 0){
			if(strcmp(schd_tab[local_s_tab[i]][7],"P")==0){
				numberofpickups++;
			}
			if(DEBUG == 1) gse << schd_tab[local_s_tab[i]][2] << " " << schd_tab[local_s_tab[i]][3] << " " << distances[i] << endl;
		}
	}

	for(int i = 0; i < counter; i++){

		if(local_s_tab[i] != 0){
			if(strcmp(schd_tab[local_s_tab[i]][0],"")!=0){
				segment = schd_tab[local_s_tab[i]][0];
				break;

			}
		}
	}



	if(segment != ""){

		if(DEBUG == 1) gse << "Segment is " << segment << endl;
		routeint = (int)to_number(segment.substr(1, segment.length()));

		for(int i = 0; i < MAXSEGMENTS; i++){
			if(s_tab[i][0] == routeint){
				index = s_tab[i][1];
				break;
			}
		}
		cap = (int)to_number(schd_tab[index][33]);
		wccap = (int)to_number(schd_tab[index][34]);
		getCS_CY_cap(cscap, bscap, schd_tab[index][SEGMENTTYPE]);
	}

	extratraveltime = EXTRAGRPTT[0]*numberofpickups;


	bool secondpassinsertedtrip = false;

	for(int i = 0; i < counter; i++)
	{
		if(DEBUG == 1) gse << "The next index is " << local_s_tab[i+1] << endl;


		if(i == 0){


			if(local_s_tab[i] != 0){
				if(DEBUG == 1) gse << "using real numbers" << endl;
				string  pDisability = schd_tab[local_s_tab[i]][12];
				string  pReturn_trip = schd_tab[local_s_tab[i]][18];
				string  p_trip_type1 = schd_tab[local_s_tab[i]][8];
				int  aEarlypickup;

				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);




				promisedtime1 = schd_tab[local_s_tab[i]][4];

				prom_time = (int)to_number(promisedtime1);
				//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
				p_promised_time = itms_minutes_to_ampm(prom_time);
				est_traveltime1 = schd_tab[local_s_tab[i]][22];
				arrivetime1 =schd_tab[local_s_tab[i]][23];
				arrivetime1 = padStr( arrivetime1);
				departtime1 =schd_tab[local_s_tab[i]][24];
				departtime1 = padStr(departtime1);
				perftime1 = schd_tab[local_s_tab[i]][25];
				//perftime1 = padStr(perftime1);
				p_perf_time = (int)to_number(perftime1);
				starttime1 = schd_tab[local_s_tab[i]][26];
				starttime1  = padStr(starttime1);
				endtime1 = schd_tab[local_s_tab[i]][27];
				endtime1 = padStr(endtime1);
				s_trip_appt_time = (int)to_number(endtime1);
				timetonextstop1 = schd_tab[local_s_tab[i]][28];
				eta1 = schd_tab[local_s_tab[i]][29];
				//   if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
				eta = (int)to_number(eta1);
				//   if(DEBUG == 1) gse << "eat and int " << eta << endl;
				eta1 = itms_minutes_to_ampm(eta);
				//  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
				etd1 = schd_tab[local_s_tab[i]][30]; /// fix this hack in get next token
				etd = (int)to_number(etd1);
				etd1 = itms_minutes_to_ampm(etd);
				//temp = schd_tab[local_s_tab[i]][10];
				lat1 =  schd_tab[local_s_tab[i]][10];
				lon1 =  schd_tab[local_s_tab[i]][37];
				lat2 =  schd_tab[local_s_tab[i+1]][10];

				lon2 = schd_tab[local_s_tab[i+1]][37]; /// fix this hack in get next token
				// temp = schd_tab[local_s_tab[i]][12];
				amb_occ1 =  schd_tab[local_s_tab[i]][31];
				wc_occ1 =  schd_tab[local_s_tab[i]][32];
				p_cs_occ = (int)to_number(schd_tab[local_s_tab[i]][CS_OCC]);
				p_bs_occ = (int)to_number(schd_tab[local_s_tab[i]][BS_OCC]);
				amb_cap1 =  to_string(cap);
				cs_cap = cscap;
				bs_cap = bscap;
				//temp = temp+",";
				wc_cap1 =  to_string(wccap); /// fix this hack in get next token
				grp_cnt_amb = schd_tab[local_s_tab[i]][35];
				p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
				grp_cnt_wc = schd_tab[local_s_tab[i]][36];
				p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

				p_disability = schd_tab[local_s_tab[i]][12];
				//p_amb_occ = to_number(amb_occ1);
				//p_wc_occ = to_number(wc_occ1);
				p_trip_type = schd_tab[local_s_tab[i]][8];
				p_spl_other_desc = schd_tab[local_s_tab[i]][9];
				//last_dep_time = prom_time;
				//last_arr_time = prom_time;
				p_name = schd_tab[local_s_tab[i]][14];
				p_return_trip = schd_tab[local_s_tab[i]][18];
				p_stop_type = schd_tab[local_s_tab[i]][7];
				p_esc = (int)to_number(schd_tab[local_s_tab[i]][13]);
				p_stop_num = 1;
				//    if(DEBUG == 1) gse << "The segment is  " << p_td_segmentid << " " <<  schd_tab[local_s_tab[SEGSTART]][0] << endl;
				//  if(DEBUG == 1) gse << "STop num " << p_stop_num<< endl;
				p_citytown =  schd_tab[local_s_tab[i]][11];
				estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);
				p_td_segmentid = "STEST";

				if (p_stop_num == 1 ){

					string tripid = schd_tab[local_s_tab[i]][3];
					tripid = tripid.substr(0,1);
					if(tripid == "T" || tripid == "R" ){
						last_dep_time = etd;
						last_arr_time = eta;
					}
					else{
						last_dep_time = prom_time;
						last_arr_time = prom_time;
					}

				}

			}
			else{




				string  pDisability = schd_tab[local_s_tab[i+1]][12];
				string  pReturn_trip = schd_tab[local_s_tab[i+1]][18];
				string  p_trip_type1 = schd_tab[local_s_tab[i+1]][8];


				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);
				int  aEarlypickup;


				if (pDisability.find("OT",0) != string::npos)
				{
					if (pReturn_trip == "Y"){

						aEarlypickup = p_OTHEREARLYPICKFACTOR1;             /* C[006] */

						//   if(DEBUG == 1) gse << "here5 " << endl;
					}
					else{
						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */

						//   if(DEBUG == 1) gse << "here4 " << endl;
					}
				}
				else if (pDisability.find("LP",0) != string::npos){
					aEarlypickup = 0;

					//  if(DEBUG == 1) gse << "here3 " << endl;
				}
				else{
					//aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;             /* C[006] */
					//aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

					if (pReturn_trip == "Y"){

						aEarlypickup = p_OTHEREARLYPICKFACTOR1;             /* C[006] */

						//    if(DEBUG == 1) gse << "here2 " << endl;
					}
					else{
						aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */

						//  if(DEBUG == 1) gse << "here1 " << endl;
					}
				}
				promisedtime1 = schd_tab[local_s_tab[i+1]][4];
				prom_time = (int)to_number(promisedtime1) - aEarlypickup;
				//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
				p_promised_time = itms_minutes_to_ampm(prom_time);
				est_traveltime1 = "0";
				arrivetime1 ="0";
				arrivetime1 = padStr( arrivetime1);
				departtime1 ="0";
				departtime1 = padStr(departtime1);
				perftime1 = "0";
				//perftime1 = padStr(perftime1);
				p_perf_time = (int)to_number(perftime1);
				starttime1 = "0";
				starttime1  = padStr(starttime1 );
				endtime1 = "0";
				endtime1 = padStr(endtime1);
				s_trip_appt_time = (int)to_number(endtime1);
				timetonextstop1 = "0";
				eta1 = to_string(prom_time);
				//   if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
				eta = (int)to_number(eta1);
				//   if(DEBUG == 1) gse << "eat and int " << eta << endl;
				eta1 = itms_minutes_to_ampm(eta);
				//  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
				etd1 = to_string(prom_time); /// fix this hack in get next token
				etd = (int)to_number(etd1);
				etd1 = itms_minutes_to_ampm(etd);
				//temp = schd_tab[local_s_tab[i]][10];
				lat1 =  schd_tab[local_s_tab[i+1]][10];
				lon1 =  schd_tab[local_s_tab[i+1]][37];
				lat2 =  schd_tab[local_s_tab[i+1]][38];

				lon2 = schd_tab[local_s_tab[i+1]][39]; /// fix this hack in get next token
				// temp = schd_tab[local_s_tab[i]][12];
				amb_occ1 =  "0";
				wc_occ1 =  "0";
				p_cs_occ = 0;
				p_bs_occ = 0;
				amb_cap1 =  to_string(cap);
				cs_cap = cscap;
				bs_cap = bscap;
				//temp = temp+",";
				wc_cap1 =  to_string(wccap); /// fix this hack in get next token
				grp_cnt_amb = "0";
				p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
				grp_cnt_wc = "0";
				p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

				p_disability = "";
				//p_amb_occ = to_number(amb_occ1);
				//p_wc_occ = to_number(wc_occ1);
				p_trip_type = "NOTRIP";
				p_spl_other_desc = "";
				//last_dep_time = prom_time;
				//last_arr_time = prom_time;
				p_name = "TEST";
				p_return_trip = "N";
				p_stop_type = "P";
				p_esc = 0;
				p_stop_num =  1;
				p_td_segmentid = "STEST";
				estdisttrip = (int)to_number(MAXSTOPNUM[0]);

				if (p_stop_num == 1){
					last_dep_time = prom_time;
					last_arr_time = prom_time;

				}

			}

		}

		else if(i + 1 == counter){

			if(local_s_tab[i] != 0){
				if(DEBUG == 1) gse << "using real numbers" << endl;

				promisedtime1 = schd_tab[local_s_tab[i]][4];

				prom_time = (int)to_number(promisedtime1);
				//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
				p_promised_time = itms_minutes_to_ampm(prom_time);
				est_traveltime1 = schd_tab[local_s_tab[i]][22];
				arrivetime1 =schd_tab[local_s_tab[i]][23];
				arrivetime1 = padStr( arrivetime1);
				departtime1 =schd_tab[local_s_tab[i]][24];
				departtime1 = padStr(departtime1);
				perftime1 = schd_tab[local_s_tab[i]][25];
				//perftime1 = padStr(perftime1);
				p_perf_time = (int)to_number(perftime1);
				starttime1 = schd_tab[local_s_tab[i]][26];
				starttime1  = padStr(starttime1 );
				endtime1 = schd_tab[local_s_tab[i]][27];
				endtime1 = padStr(endtime1);
				s_trip_appt_time = (int)to_number(endtime1);
				timetonextstop1 = schd_tab[local_s_tab[i]][28];
				eta1 = schd_tab[local_s_tab[i]][29];
				//   if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
				eta = (int)to_number(eta1);
				//   if(DEBUG == 1) gse << "eat and int " << eta << endl;
				eta1 = itms_minutes_to_ampm(eta);
				//  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
				etd1 = schd_tab[local_s_tab[i]][30]; /// fix this hack in get next token
				etd = (int)to_number(etd1);
				etd1 = itms_minutes_to_ampm(etd);
				//temp = schd_tab[local_s_tab[i]][10];
				lat1 =  schd_tab[local_s_tab[i]][10];
				lon1 =  schd_tab[local_s_tab[i]][37];
				lat2 =  schd_tab[local_s_tab[i]][10];

				lon2 = schd_tab[local_s_tab[i]][37]; /// fix this hack in get next token
				// temp = schd_tab[local_s_tab[i]][12];
				amb_occ1 =  schd_tab[local_s_tab[i]][31];
				wc_occ1 =  schd_tab[local_s_tab[i]][32];
				p_cs_occ =  to_number(schd_tab[local_s_tab[i]][CS_OCC]);
				p_bs_occ =  to_number(schd_tab[local_s_tab[i]][BS_OCC]);
				amb_cap1 =  to_string(cap);
				cs_cap = cscap;
				bs_cap = bscap;
				//temp = temp+",";
				wc_cap1 =  to_string(wccap); /// fix this hack in get next token
				grp_cnt_amb = schd_tab[local_s_tab[i]][35];
				p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
				grp_cnt_wc = schd_tab[local_s_tab[i]][36];
				p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

				p_disability = schd_tab[local_s_tab[i]][12];
				//p_amb_occ = to_number(amb_occ1);
				//p_wc_occ = to_number(wc_occ1);
				p_trip_type = schd_tab[local_s_tab[i]][8];
				p_spl_other_desc = schd_tab[local_s_tab[i]][9];
				//last_dep_time = prom_time;
				//last_arr_time = prom_time;
				p_name = schd_tab[local_s_tab[i]][14];
				p_return_trip = schd_tab[local_s_tab[i]][18];
				p_stop_type = schd_tab[local_s_tab[i]][7];
				p_esc = (int)to_number(schd_tab[local_s_tab[i]][13]);
				//    if(DEBUG == 1) gse << "The segment is  " << p_td_segmentid << " " <<  schd_tab[local_s_tab[SEGSTART]][0] << endl;
				//  if(DEBUG == 1) gse << "STop num " << p_stop_num<< endl;
				p_citytown =  schd_tab[local_s_tab[i]][11];
				estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);
				p_stop_num =  (int)to_number(MAXSTOPNUM[0]);
				p_td_segmentid = "STEST";

			}
			else{


				promisedtime1 = "1439";
				prom_time = (int)to_number(promisedtime1);
				//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
				p_promised_time = itms_minutes_to_ampm(prom_time);
				est_traveltime1 = "0";
				arrivetime1 ="0";
				arrivetime1 = padStr( arrivetime1);
				departtime1 ="0";
				departtime1 = padStr(departtime1);
				perftime1 = "0";
				//perftime1 = padStr(perftime1);
				p_perf_time = (int)to_number(perftime1);
				starttime1 = "0";
				starttime1  = padStr(starttime1 );
				endtime1 = "0";
				endtime1 = padStr(endtime1);
				s_trip_appt_time = (int)to_number(endtime1);
				timetonextstop1 = "";
				eta1 = schd_tab[local_s_tab[i]][29];
				//   if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
				eta = (int)to_number(eta1);
				//   if(DEBUG == 1) gse << "eat and int " << eta << endl;
				eta1 = itms_minutes_to_ampm(eta);
				//  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
				etd1 = schd_tab[local_s_tab[i]][30]; /// fix this hack in get next token
				etd = (int)to_number(etd1);
				etd1 = itms_minutes_to_ampm(etd);
				//temp = schd_tab[local_s_tab[i]][10];
				lat1 =  schd_tab[local_s_tab[i-1]][10];
				lon1 =  schd_tab[local_s_tab[i-1]][37];
				lat2 =  schd_tab[local_s_tab[i-1]][38];

				lon2 = schd_tab[local_s_tab[i-1]][39]; /// fix this hack in get next token
				// temp = schd_tab[local_s_tab[i]][12];
				amb_occ1 =  "0";
				wc_occ1 =  "0";
				p_cs_occ =  0;
				p_bs_occ =  0;
				amb_cap1 =  to_string(cap);
				cs_cap = cscap;
				bs_cap = bscap;
				//temp = temp+",";
				wc_cap1 =  to_string(wccap); /// fix this hack in get next token
				grp_cnt_amb = "0";
				p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
				grp_cnt_wc = "0";
				p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

				p_disability = "";
				//p_amb_occ = to_number(amb_occ1);
				//p_wc_occ = to_number(wc_occ1);
				p_trip_type = "NOTYPE";
				p_spl_other_desc = "";
				//last_dep_time = prom_time;
				//last_arr_time = prom_time;
				p_name = "TEST";
				p_return_trip = "N";
				p_stop_type = "D";
				p_esc = 0;
				p_stop_num =  (int)to_number(MAXSTOPNUM[0]);
				p_td_segmentid = "STEST";
				estdisttrip = (int)to_number(MAXSTOPNUM[0]);
			}
		}

		else{

			string  pDisability = schd_tab[local_s_tab[i]][12];
			string  pReturn_trip = schd_tab[local_s_tab[i]][18];
			string  p_trip_type1 = schd_tab[local_s_tab[i]][8];
			int  aEarlypickup;

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);




			promisedtime1 = schd_tab[local_s_tab[i]][4];

			prom_time = (int)to_number(promisedtime1);
			//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
			p_promised_time = itms_minutes_to_ampm(prom_time);
			est_traveltime1 = schd_tab[local_s_tab[i]][22];
			arrivetime1 =schd_tab[local_s_tab[i]][23];
			arrivetime1 = padStr( arrivetime1);
			departtime1 =schd_tab[local_s_tab[i]][24];
			departtime1 = padStr(departtime1);
			perftime1 = schd_tab[local_s_tab[i]][25];
			//perftime1 = padStr(perftime1);
			p_perf_time = (int)to_number(perftime1);
			starttime1 = schd_tab[local_s_tab[i]][26];
			starttime1  = padStr(starttime1 );
			endtime1 = schd_tab[local_s_tab[i]][27];
			endtime1 = padStr(endtime1);
			s_trip_appt_time = (int)to_number(endtime1);
			timetonextstop1 = schd_tab[local_s_tab[i]][28];
			eta1 = schd_tab[local_s_tab[i]][29];
			//   if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
			eta = (int)to_number(eta1);
			//   if(DEBUG == 1) gse << "eat and int " << eta << endl;
			eta1 = itms_minutes_to_ampm(eta);
			//  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
			etd1 = schd_tab[local_s_tab[i]][30]; /// fix this hack in get next token
			etd = (int)to_number(etd1);
			etd1 = itms_minutes_to_ampm(etd);
			//temp = schd_tab[local_s_tab[i]][10];
			lat1 =  schd_tab[local_s_tab[i]][10];
			lon1 =  schd_tab[local_s_tab[i]][37];
			lat2 =  schd_tab[local_s_tab[i]][38];

			lon2 = schd_tab[local_s_tab[i]][39]; /// fix this hack in get next token
			// temp = schd_tab[local_s_tab[i]][12];
			amb_occ1 =  schd_tab[local_s_tab[i]][31];
			wc_occ1 =  schd_tab[local_s_tab[i]][32];
			p_cs_occ =  to_number(schd_tab[local_s_tab[i]][CS_OCC]);
			p_bs_occ =  to_number(schd_tab[local_s_tab[i]][BS_OCC]);
			amb_cap1 =  to_string(cap);
			cs_cap = cscap;
			bs_cap = bscap;
			//temp = temp+",";
			wc_cap1 =  to_string(wccap); /// fix this hack in get next token
			grp_cnt_amb = schd_tab[local_s_tab[i]][35];
			p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
			grp_cnt_wc = schd_tab[local_s_tab[i]][36];
			p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

			p_disability = schd_tab[local_s_tab[i]][12];
			//p_amb_occ = to_number(amb_occ1);
			//p_wc_occ = to_number(wc_occ1);
			p_trip_type = schd_tab[local_s_tab[i]][8];
			p_spl_other_desc = schd_tab[local_s_tab[i]][9];
			//last_dep_time = prom_time;
			//last_arr_time = prom_time;
			p_name = schd_tab[local_s_tab[i]][14];
			p_return_trip = schd_tab[local_s_tab[i]][18];
			p_stop_type = schd_tab[local_s_tab[i]][7];
			p_esc = (int)to_number(schd_tab[local_s_tab[i]][13]);

			if(!secondpassinsertedtrip){
				p_stop_num = p_stop_num + 1;
			}


			p_td_segmentid = schd_tab[local_s_tab[SEGSTART]][0];
			//    if(DEBUG == 1) gse << "The segment is  " << p_td_segmentid << " " <<  schd_tab[local_s_tab[SEGSTART]][0] << endl;
			//  if(DEBUG == 1) gse << "STop num " << p_stop_num<< endl;
			p_citytown =  schd_tab[local_s_tab[i]][11];
			estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);

		}
		prev_distance = 0;


		if(p_stop_num != 1){
			prev_distance =  distances[i-1];
			disttrav = prev_distance;
		}


		int grouppickupcnt = 0;

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];
		if(groupmark != ""){
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			grouppickupcnt = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
			//  if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
		}




		if(DEBUG == 1) gse << "Done grouping " << endl;
		int p_WHEELLOAD1;
		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;


		string pReturn_trip = schd_tab[local_s_tab[i]][18];
		string  pDisability = schd_tab[local_s_tab[i]][12];
		string p_trip_type1 = schd_tab[local_s_tab[i]][8];

		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

		double estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);

		int aAllowedTT;


		int allowedDW;
		double esttime = to_number(schd_tab[local_s_tab[i]][22]);

		if(estdisttrip < a_mediumshortdistance1){
			aAllowedTT = a_shorttriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
		}
		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
			aAllowedTT = a_mediumtriptime1 + extratraveltime;
		}
		else{
			aAllowedTT = a_longtriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
		}

		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
		}

		int p_perf_time;
		string pDisposition = schd_tab[local_s_tab[i]][DISPOSITION];
		set_p_perf_time(pDisposition,pDisability, p_perf_time, p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1 );

		int est_time;

		string tripid = schd_tab[local_s_tab[i]][3];
		tripid = tripid.substr(0,1);
		string endtime2;
		if(tripid == "S"){
			endtime2 =to_string( (int)itms_to_minutes(ampm2fullhrs(p_promised_time)));
		}

		if(p_stop_type == "P"){
			if((int)to_number(starttime1)!= 0)
				est_time = (int)to_number(starttime1);
			else{
				est_time =  (int)to_number(endtime2) - (int)to_number(est_traveltime1);
			}
		}
		else{
			if((int)to_number(endtime2)!= 0)
				est_time = (int)to_number(endtime2);
			else{

				est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
			}
		}

		string timezonetime = itms_minutes_to_ampm(est_time);
		if(p_stop_num ==1){
			p_eta = p_promised_time;
			p_etd = etd1;
		}
		else{
			p_eta = eta1;
			p_etd = etd1;
		}
		// p_eta = eta1;
		string route = schd_tab[local_s_tab[i]][0];
		if( (route == "" || timeZones(p_eta, timezonetime) != timeZones(timezonetime,p_eta))  && !secondpassinsertedtrip){time_zone = timeZones(p_eta, timezonetime); secondpassinsertedtrip = true;}
		else{  if(F_GET_TRAVEL_TIME (1.0 , timeZones(p_eta, timezonetime), "*") > F_GET_TRAVEL_TIME (1.0 , timeZones(timezonetime,p_eta), "*")){
			time_zone = timeZones(p_eta, timezonetime);secondpassinsertedtrip = false;
		}
		else{
			time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(p_eta, timezonetime);

		string timezone2;
		if (p_stop_num != 1) {
			if (!isSameLocation(local_s_tab[i],local_s_tab[i-1]))
				timezone2 = "#"; // not the same lat/long
			else
				timezone2 = "*";
		}














		varHolder = itms_calcroute( arrivetime1, departtime1,prev_distance,  rteStr ,   p_citytown ,     p_street_by_street ,     p_eta  ,    p_promised_time ,     p_perf_time ,   p_early_morning_factor ,  p_stop_num ,
				p_td_segmentid,  p_wc_occ   , p_amb_occ,   p_esc  ,  p_disability  , p_stop_type  ,  p_WHEELLOAD[0] ,  p_AMBLOAD[0] ,
				p_customer ,   p_return_trip  ,  p_DIALRIDEEARLYPICKFACTOR[0]  ,  p_DIALRIDELATEPICKFACTOR[0] ,  p_PROXIMITYFACTOR[0],  p_SHORTBREAK[0]  ,
				p_LUNCHBREAK[0]   ,   p_MAXEARLYDROPOFFFACTOR[0]  , p_OTHEREARLYPICKFACTOR[0]  ,  p_OTHERLATEPICKFACTOR[0] ,   p_name    ,
				p_timetonextstop , p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
				OffLoaded   , p_trip_type ,    p_prev_perf_time ,   p_prev_stop_num , p_latency   ,  s_trip_appt_time ,  p_grp_cnt_amb ,
				p_grp_cnt_wc,  ignorepu[0],  IGNORE_DEPOTS_CUTOFF[0], time_zone, timezone2,starttime1, p_cs_occ, p_bs_occ,last_cs_occ,last_bs_occ,pDisposition);

		//    if(DEBUG == 1) gse << "2. I am here " << std::get<4>(varHolder) << endl;

		if(i == 0 and local_s_tab[i] != 0){
			p_eta=itms_minutes_to_ampm(eta);
		}
		else{
			p_eta=std::get<0>(varHolder);
		}

		p_wc_occ=std::get<1>(varHolder);
		p_amb_occ=std::get<2>(varHolder);
		p_esc=std::get<3>(varHolder);
		p_timetonextstop=std::get<4>(varHolder);
		p_disttonextstop=std::get<5>(varHolder);
		p_earlystoptime=std::get<6>(varHolder);
		p_latestoptime=std::get<7>(varHolder);
		tot_miles=std::get<8>(varHolder);
		tot_driv_time=std::get<9>(varHolder);
		p_cs_occ = std::get<13>(varHolder);
		p_bs_occ = std::get<14>(varHolder);

		if(i == 0 and local_s_tab[i] != 0){
			p_etd=itms_minutes_to_ampm(etd);
		}
		else{
			p_etd=std::get<10>(varHolder);
		}
		OffLoaded=std::get<11>(varHolder);
		p_perf_time = std::get<12>(varHolder);

		if(!secondpassinsertedtrip){
			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) - p_perf_time);

			if (p_stop_num != 1 && p_stop_num != (int)to_number(MAXSTOPNUM[0])) {
				if (prev_distance == 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)

					AGRPCOUNTER = AGRPCOUNTER + 1;
				else{
					if (AGRPCOUNTER > 0  && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)
					{
						APRVGRPCOUNTER = AGRPCOUNTER + 1;
					}
					AGRPCOUNTER = 0;
				}


				if(p_disability.find("WC",0) == string::npos && p_disability.find("SC",0) == string::npos && p_disability.find("XLT",0) == string::npos){


					if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0){

						p_perf_time = p_perf_time / AGRPCOUNTER;
					}


					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

						p_perf_time = p_perf_time / APRVGRPCOUNTER;
						APRVGRPCOUNTER = 0;
					}
				}
				else{

					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


						if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / AGRPCOUNTER;
						}

						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / APRVGRPCOUNTER;
							APRVGRPCOUNTER = 0;
						}
					}
				}

			}
			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) + p_perf_time);
		}






		//    if(DEBUG == 1) gse << "Checking for eta 2 " << schd_tab[local_s_tab[i]][29] << endl;



		//   if(DEBUG == 1) gse << "ETa 2" << p_eta << " " << p_etd << endl;

		//  if(DEBUG == 1) gse << "2. I am here " << schd_tab[local_s_tab[0]][0] << endl;

		//  if(DEBUG == 1) gse << " local " << schd_tab[local_s_tab[SEGSTART]][0] << " " << local_s_tab[SEGSTART] << endl;
		//  strcpy( schd_tab[local_s_tab[i]][0] ,schd_tab[local_s_tab[SEGSTART]][0]);



		//  if(DEBUG == 1) gse << "3. I am here " << schd_tab[local_s_tab[0]][0] << endl;


		// temp = temproute[i][4];




		//if(i != 0 && i+1 != counter){
		if(local_s_tab[i] != 0){
			strcpy(  schd_tab[local_s_tab[i]][29] ,to_string(itms_to_minutes (ampm2fullhrs (p_eta))).c_str());
			strcpy(  schd_tab[local_s_tab[i]][30] ,to_string(itms_to_minutes (ampm2fullhrs (p_etd))).c_str());
			strcpy(  schd_tab[local_s_tab[i]][CALCULATEDTIME] ,to_string(p_timetonextstop).c_str());
			strcpy(  schd_tab[local_s_tab[i]][25] ,to_string(p_perf_time).c_str());
		}



		prev_eta1 = to_string(itms_to_minutes (ampm2fullhrs (p_eta)));
		prev_eta = (int)to_number(prev_eta1);
		prev_eta1 = itms_minutes_to_ampm(prev_eta);



		int t = i;
		string timezone3;
		if (p_stop_num != 1) {
			if (!isSameLocation(local_s_tab[t],local_s_tab[t-1]))
				timezone3 = "#"; // not the same lat/long
				else
					timezone3 = "*";


			tripid = schd_tab[local_s_tab[t-1]][3];
			if(timezone3 == "*" && strcmp(schd_tab[local_s_tab[t-1]][7], schd_tab[local_s_tab[t]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[local_s_tab[t-1]][41], schd_tab[local_s_tab[t]][41])==0){
				strcpy(  schd_tab[local_s_tab[t]][29] ,schd_tab[local_s_tab[t-1]][29]);
				int l = t;
				tripid = schd_tab[local_s_tab[l]][3];
				while(isSameLocation(local_s_tab[l],local_s_tab[l-1]) && strcmp(schd_tab[local_s_tab[l-1]][7], schd_tab[local_s_tab[l]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[local_s_tab[l-1]][41], schd_tab[local_s_tab[l]][41])==0){
					strcpy(  schd_tab[local_s_tab[l-1]][30] , schd_tab[local_s_tab[l]][30]);
					l--;
					tripid = schd_tab[local_s_tab[l]][3];
					if(l == 0)
						break;
				}
			}
		}

		if(secondpassinsertedtrip){  if(DEBUG == 1) gse << "REDOING" << endl; i--;continue;}


		prev_perftime1 = to_string(p_perf_time);
		prev_p_perf_time = (int)to_number(prev_perftime1);


		prev_etd1 =to_string(itms_to_minutes (ampm2fullhrs (p_etd))); /// fix this hack in get next token
		prev_etd = (int)to_number(prev_etd1);
		prev_etd1 = itms_minutes_to_ampm(prev_etd);
		//temp = temproute[i][12];
		prev_amb_occ1 =  to_string(p_amb_occ);
		prev_wc_occ1 = to_string(p_wc_occ);
		//amb_cap1 = getNextToken(&(temp), ",");
		//wc_cap1 =getNextToken(&(temp), ",");
		last_dep_time=prev_etd;
		last_arr_time=prev_eta;
		string prev_cs_occ = to_string(p_cs_occ);
		string prev_bs_occ = to_string(p_bs_occ);
		last_cs_occ=to_number(prev_cs_occ);
		last_bs_occ=to_number(prev_bs_occ);
		last_amb_occ=(int)to_number(prev_amb_occ1);
		last_wc_occ=(int)to_number(prev_wc_occ1);
		p_prev_perf_time = prev_p_perf_time;
		p_prev_stop_num = p_stop_num ;
		p_prev_promised_time = p_promised_time;








		/*if(temproute[i][20] == "0" && temproute[i-1][20] != "0"){
                               if(DEBUG == 1) gse << "Stop Num " << temproute[i-1][2] << endl;
                        temp = temproute[i-1][12];
                        getNextToken(&(temp), ",");
                        getNextToken(&(temp), ",");
                        amb_cap1 = getNextToken(&(temp), ",");
                        wc_cap1 =getNextToken(&(temp), ",");
                        }*/

		//   if(DEBUG == 1) gse << last_dep_time << endl;


		//  if(DEBUG == 1) gse << "4. I am here " << schd_tab[local_s_tab[0]][0] << endl;

		/*  if(local_s_tab[i] == puid && p_stop_num == aStp){
        indafter1 = schd_tab[local_s_tab[i-1]][20];
        pueta = p_eta;
         puetd = p_etd;
        disttravpu = to_string(disttrav);
        pustp = to_string(p_stop_num);
        latlon1 = schd_tab[local_s_tab[i-1]][10];
         latlon1= latlon1 +","+ schd_tab[local_s_tab[i-1]][37];
        latlon2 = schd_tab[local_s_tab[i+1]][10];
         latlon2= latlon2+ ","+ schd_tab[local_s_tab[i+1]][37];
        //indicies = temproute[i][20];
       //    if(DEBUG == 1) gse << indicies << endl;
    }





    if(local_s_tab[i] == puid && p_stop_num > aStp){
       doeta = p_eta;
       disttravdo = to_string(disttrav);
       dostp = to_string(p_stop_num);
       doetd = p_etd;
       if(p_stop_num == aStp +1)
        indafter2 = indafter1;
      else
        indafter2 = schd_tab[local_s_tab[i-1]][20];
         latlon3 = schd_tab[local_s_tab[i-1]][10];
         latlon3= latlon3 +","+ schd_tab[local_s_tab[i-1]][37];
         latlon4 = schd_tab[local_s_tab[i+1]][10];
         latlon4= latlon4+ ","+ schd_tab[local_s_tab[i+1]][37];


         actualTT = (itms_to_minutes (ampm2fullhrs (doeta)) - itms_to_minutes (ampm2fullhrs (puetd))); //flipped eta/etd
            if(DEBUG == 1) gse << "Actual travel time " << actualTT << endl;
    }
		 */


		//actual travel time


		string tripid2 = schd_tab[local_s_tab[i]][3];
		string p_trip_type2 = schd_tab[local_s_tab[i]][8];

		if(strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && i != 0 && i!= counter-1 && (tripid2.substr(0,1) == "T" || tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN"){

			int pickupid = (int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX]);
			int doeta1 = (int)to_number(schd_tab[local_s_tab[i]][30])-(int)to_number(schd_tab[local_s_tab[i]][25]);
			int puetd1 = (int)to_number(schd_tab[pickupid][30]);
			int stopafter;

			for(int t = 0; t < counter; t++){
				if(local_s_tab[t] == pickupid){
					stopafter = local_s_tab[t+1];
					break;
				}
			}

			string pReturn_trip1 = schd_tab[pickupid][18];
			string pDisability1 = schd_tab[pickupid][12];
			string p_trip_type11 = schd_tab[pickupid][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type11);
			int aLatepickup;

			if (pReturn_trip1 == "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}

			if((int)to_number(schd_tab[stopafter][30]) - (int)to_number(schd_tab[stopafter][25])  >= (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]) + (int)to_number(schd_tab[pickupid][CALCULATEDTIME])){

				puetd1 = (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]);

				if(DEBUG == 1) gse << "Changing puetd to " << puetd1 << " " << (int)to_number(schd_tab[stopafter][30]) << "  " <<  (int)to_number(schd_tab[stopafter][25]) <<  endl;
			}


			actualTT = doeta1 - puetd1; //flipped eta/etd
			if(DEBUG == 1) gse << schd_tab[local_s_tab[i]][29] << " - " << schd_tab[pickupid][30] << endl;
			if(DEBUG == 1) gse << "Actual travel time of " << schd_tab[local_s_tab[i]][3] << " " << actualTT << endl;
		}
		else
			actualTT = 0;


		p_eta = itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][29]));
		p_etd = itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][30]));

		int aLatepickup;

		if (p_return_trip == "Y"){
			aLatepickup = p_OTHERLATEPICKFACTOR1;
		}
		else{
			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
		}

		if(p_stop_num == (int)to_number(MAXSTOPNUM[0])){
			endtime1 = to_string((int)itms_to_minutes(ampm2fullhrs(p_promised_time))); // to make sure segments do not go beyond the end'
			////  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
		}

		bool preassigntripchange = true;


		if(strcmp(schd_tab[local_s_tab[i]][LATEDEVIATION],"")!=0 || strcmp(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION],"")!=0){
			preassigntripchange = false;
			if ((p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {
				if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup)//p_DIALRIDELATEPICKFACTOR )
				{
					int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(starttime1) + aLatepickup);
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}

				}
			}


			if ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000")
			{
				if((((itms_to_minutes(ampm2fullhrs(p_eta))) >  (int)to_number(endtime1)) && prom_time != 0))
				{

					int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(endtime1));
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}


				}
			}

			if((actualTT > aAllowedTT  && actualTT > 0)){
				if((actualTT - aAllowedTT) > (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION])){
					preassigntripchange = true;
				}
			}
		}




		if(DEBUG == 1) gse << p_stop_num << " \t " << p_promised_time << " \t " <<  itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][29])) << " \t " << itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][30])) << " \t NOT STORING DISTANCE  \t" << p_timetonextstop << " \t " << p_stop_type << "\t wc occ" << p_wc_occ << " \t amb occ" << p_amb_occ << "\t" << p_cs_occ << "\t" << p_bs_occ << "\t" << p_esc << " " << arrivetime1 << " " << departtime1 << " " << p_trip_type << " " << schd_tab[local_s_tab[i]][20] << " " << " " <<schd_tab[local_s_tab[i]][42]<< " " << schd_tab[local_s_tab[i]][41] << " " << local_s_tab[i] << " starttime " << starttime1 << " end time: " << endtime1 << " trip id " <<schd_tab[local_s_tab[i]][3]  << " " << schd_tab[local_s_tab[i]][10] << " " << schd_tab[local_s_tab[i]][37]  <<  endl;




		if(/*strcmp(USEREVERSECALC[0],"Y")!=0*/ true){

			//  if(DEBUG == 1) gse << "5. I am here " << schd_tab[local_s_tab[0]][0] << endl;
			//    if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;

			/*** 1. Check for WC violations ***/
			if (schd_tab[local_s_tab[i]][0] == "" && p_disability.find("WC") != string::npos && p_stop_num >= aStp) {
				if (to_number(wc_cap1) == 0) {
					if(!finished){
						oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
						//strcpy( schd_tab[local_s_tab[i]][0] ,"");

						//a_route = schd_tab[local_s_tab[SEGSTART]][0];
						//    if(DEBUG == 1) gse << "1 " << a_route << endl;

						if(DEBUG == 1) gse << "Back to originial eta " << p_td_segmentid<< endl;
						for(int i = 0; i < counter; i++){
							if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
								strcpy(schd_tab[local_s_tab[i]][29],"");
						}
						for(int d = 0; d < counter; d++){

							if(strcmp(schd_tab[local_s_tab[d]][0],"")!=0)//if it's an unassigned trip, reset eta.
								strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
							strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
							strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());


						}

						if(DEBUG == 1) gse <<  oResult << "\n\n";



						//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }


						return false; //recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
						break;

					}
					finished = true;


				}
			} //general

			/*** 2. Check for Capacity Violation ***/
			if ((p_wc_occ> (int)to_number(wc_cap1) && p_stop_num >= aStp) || (p_amb_occ > (int)to_number(amb_cap1) && p_stop_num >= aStp)
					|| (p_cs_occ > cs_cap  &&  p_stop_num >=aStp) || (p_bs_occ > bs_cap  &&  p_stop_num >=aStp)) {
				//   if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;
				if(!finished){
					// string route = schd_tab[local_s_tab[1]][0];
					oResult = "NOK Capacity Violation when assigning Trip on Segment " + p_td_segmentid + " with capacities wc, amb " + wc_cap1 + " " + amb_cap1;
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");

					//a_route = schd_tab[local_s_tab[SEGSTART]][0];
					//  if(DEBUG == 1) gse << "2 " << a_route << endl;


					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

					for(int i = 0; i < counter; i++){
						if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
							strcpy(schd_tab[local_s_tab[i]][29],"");
					}
					for(int d = 0; d < counter; d++){

						if(strcmp(schd_tab[local_s_tab[d]][0],"")!=0)//if it's an unassigned trip, reset eta.
							strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
						strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
						strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());


					}
					return false; //recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
					break;

				}
				finished = true;


			} //per stop number



			/***3. Pickup Window violation *****/
			if (preassigntripchange && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" && (p_stop_num >= aStp )) {


				if(DEBUG == 1) gse << "checking " << itms_to_minutes(ampm2fullhrs(p_eta)) << " " << (int)to_number(starttime1) << " " << aLatepickup << endl;
				if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
				{
					//   if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
					// oDropETA = " Dropoff ETA:  ;" ;
					if(!finished){
						string tripid = schd_tab[local_s_tab[i]][3];
						oResult = "Impact: " + tripid +" Pickup is outside the window with start time: " + itms_minutes_to_ampm((int)to_number(starttime1)); //oResult
						//  strcpy( schd_tab[local_s_tab[i]][0] ,"");

						//a_route = schd_tab[local_s_tab[SEGSTART]][0];
						//   if(DEBUG == 1) gse << "3 " << a_route << endl;




						if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
						//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
						if(strcmp(USEREVERSECALC[0],"Y")!=0){

							for(int i = 0; i < counter; i++){
								if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
									strcpy(schd_tab[local_s_tab[i]][29],"");
							}
							for(int d = 0; d < counter; d++){

								if(strcmp(schd_tab[local_s_tab[d]][0],"")!=0)//if it's an unassigned trip, reset eta.
									strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
								strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
								strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());


							}
							return false; //recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
							break;
						}
						else{
							ontime = false;
						}

					}
					finished = true;

				}

			}

			if(p_stop_num == (int)to_number(MAXSTOPNUM[0]) && tripid == "S"){
				endtime1 = to_string((int)itms_to_minutes(ampm2fullhrs(p_promised_time))); // to make sure segments do not go beyond the end'
				//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
			}
			/*** 4. Check if someone is late for Appointment ***/
			/** Added condition if the appt. time is not null and return_trip = Y **/
			if (preassigntripchange && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"&& (p_stop_num >= aStp)))
			{



				if((((itms_to_minutes(ampm2fullhrs(p_eta))) > /*12 +*/ (int)to_number(endtime1) + floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0))
				{
					if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;
					if(!finished){
						if(DEBUG == 1) gse << "I will be late " << endl;
						string tripid = schd_tab[local_s_tab[i]][3];
						oResult = "Impact: " +  tripid + " will be late: " + to_string((int)itms_to_minutes(ampm2fullhrs(p_eta)) - (int)to_number(endtime1) ) +
								" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
						// strcpy( schd_tab[local_s_tab[i]][0] ,"");
						if(DEBUG == 1) gse <<   oResult <<"\n\n";

						//a_route = schd_tab[local_s_tab[SEGSTART]][0];
						//  if(DEBUG == 1) gse << "4 " << a_route << endl;

						if(DEBUG == 1) gse << "Back to originial eta " << local_s_tab[0] << endl;

						//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
						if(strcmp(USEREVERSECALC[0],"Y")!=0){

							for(int i = 0; i < counter; i++){
								if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
									strcpy(schd_tab[local_s_tab[i]][29],"");
							}
							for(int d = 0; d < counter; d++){

								if(strcmp(schd_tab[local_s_tab[d]][0],"")!=0)//if it's an unassigned trip, reset eta.
									strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
								strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
								strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());


							}
							return false; //recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
							break;
						}
						else{
							ontime = false;
						}
					}
					finished = true;
				}
			}


			/**** 5. Check if it exceeds the Travel Time ****/
			if((preassigntripchange && actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)/*60*/ && actualTT > 0) && p_stop_num >= aStp){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {
				if(!finished){
					string tripid = schd_tab[local_s_tab[i]][3];
					oResult = "Impact: Travel Time Violation on Trip: " + tripid  + " TT: " + to_string(actualTT) + " Allowed: " + to_string(aAllowedTT) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
					// strcpy( schd_tab[local_s_tab[i]][0] ,"");

					if(DEBUG == 1) gse << oResult;


					if(strcmp(USEREVERSECALC[0],"Y")!=0){

						for(int i = 0; i < counter; i++){
							if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
								strcpy(schd_tab[local_s_tab[i]][29],"");
						}
						for(int d = 0; d < counter; d++){

							if(strcmp(schd_tab[local_s_tab[d]][0],"")!=0)//if it's an unassigned trip, reset eta.
								strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
							strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
							strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());


						}
						return false; //recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
						break;
					}
					else{
						ontime = false;
					}



				}
				finished = true;

			}



		}


		if(p_stop_num==(int)to_number(MAXSTOPNUM[0]) || i + 1 == counter){




			bool usereversefail = true;
			if(strcmp(USEREVERSECALC[0],"Y")==0){
				usereversefail = reversecalclocal(counter, local_s_tab, ontime);
			}
			if(!usereversefail){
				if(DEBUG == 1) gse << "There was a violation so reverse calcing!" << endl;
				//UPDATE_REVERSE_CALCULATE_BATCH(counter, local_s_tab);
				for(int i = 0; i < counter; i++){
					if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
						strcpy(schd_tab[local_s_tab[i]][29],"");
				}
				for(int d = 0; d < counter; d++){

					if(strcmp(schd_tab[local_s_tab[d]][0],"")!=0)//if it's an unassigned trip, reset eta.
						strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
					strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
					strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());
				}

				return false;
			}





			if(  oResult == "")   if(DEBUG == 1) gse << "The indicies are inserted after " << indafter1 << " and " << indafter2  << " and the segment is " << p_td_segmentid <<endl;



			for(int d = 0; d < counter; d++){
				if(strcmp(schd_tab[local_s_tab[d]][0],"")!=0){//if it's an unassigned trip, reset eta.
					if(DEBUG == 1) gse << "Put back eta" << origetaholder[d] << " for trip " << schd_tab[local_s_tab[d]][3] << " " << schd_tab[local_s_tab[d]][7] <<  endl;
					strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
					strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
					strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());
				}


			}




			if(oResult == ""){
				oResult = "Impact: On time";
				//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
				return true;
				routeFound = true;
			}


		}


	}

	//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

	return false;
}
void recalcons_tabREOPTIMIZE(string a_route){

	bool updatedb = true;
	//string p_customer;
	std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>  varHolder;
	string p_customer;
	bool notFound;
	int f1 = 0;
	int f2 = 0;
	std::string  promisedtime1;
	int prom_time;
	std::string est_traveltime1;
	std::string arrivetime1;
	std::string departtime1 ;
	std::string perftime1 ;
	int p_perf_time;
	std::string starttime1 ;
	std::string endtime1;
	std::string timetonextstop1 ;
	std::string eta1 ;
	int eta;
	std::string etd1; /// fix this hack in get next token

	int etd;
	std::string  lat1  ;
	std::string lon1   ;
	std::string lat2 ;
	std::string lon2; /// fix this hack in get next token
	std::string  amb_occ1 ;
	std::string wc_occ1 ;
	int cs_cap = 0;
	int bs_cap = 0;
	std::string amb_cap1 ;
	std::string wc_cap1 ; /// fix this hack in get next token
	int p_amb_occ;
	int p_wc_occ;
	int p_cs_occ;
	int p_bs_occ;
	int p_grp_cnt_wc;
	int p_grp_cnt_amb;
	int s_trip_appt_time = 0;
	int p_latency = 0;
	int p_prev_stop_num;
	int p_prev_perf_time;
	int OffLoaded;
	string p_trip_type ;
	string p_spl_other_desc ;
	int last_wc_occ = 0, last_cs_occ = 0, last_bs_occ = 0;
	int last_amb_occ = 0;
	int last_dep_time ;
	int last_arr_time ;
	int tot_driv_time = 0;
	double tot_miles = 0;
	string p_latestoptime ="";
	string p_earlystoptime= "";
	double p_disttonextstop = 0.0;
	int p_timetonextstop = 0;
	string p_name ;
	string p_return_trip ;
	string p_stop_type ;
	//junk p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time;
	//junk p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc , OffLoaded   , p_trip_type ;    //tofix p_
	string p_disability = "" ;
	int p_esc;
	string p_td_segmentid = "";
	int stopnum1;
	int p_stop_num;
	int p_early_morning_factor = 0;
	string p_street_by_street = "T";
	string p_citytown;
	string time_zone2 = "*";
	string time_zone;// = "*";
	int petaint;
	string rteStr;
	double disttrav;
	string grp_cnt_amb;
	string grp_cnt_wc;
	string dist;
	string p_promised_time;
	string p_eta;
	string p_etd;
	string scity;
	string dcity;
	string p_stop_type2;
	string latlongs;
	string capacity;
	string times;
	string prev_perftime1,prev_eta1,prev_etd1, prev_amb_occ1, prev_wc_occ1;
	int prev_eta,prev_etd,prev_p_perf_time;
	int index;
	int cnt = 0;
	double disttrav2;
	bool recalc = false;
	double prev_distance = 0;
	int indexstart;
	int AGRPCOUNTER = 0;
	int APRVGRPCOUNTER = 0;
	string p_prev_promised_time = "0000A";
	int timetonextstop2 = 0;




	cnt = 0;

	// //  if(DEBUG == 1) gse << "\nCalculating for " << a_route << endl;
	std::clock_t start2 = std::clock();


	//if(strcmp ( schd_tab[i][0], argv[2] ) == 0){
		//(int)to_number(schd_tab[i][0].substr(1,schd_tab[i][0].length()))

	// //  if(DEBUG == 1) gse << "There was a violations for route so recalculating original:  " << a_route << endl;


	int routeint = (int)to_number(a_route.substr(1,a_route.length()));


	/*for(int k = 1;k < MAXSTOPS; k++){
                     if(s_tab[i][k]==0){break;}
                     //  if(DEBUG == 1) gse << s_tab[i][k] << endl;
                }*/

	//// //  if(DEBUG == 1) gse << routeint << endl;
	//// //  if(DEBUG == 1) gse << s_tab[i][0] << endl;

	for(int i = 0; i < MAXSEGMENTS; i++){

		if(s_tab[i][0]==routeint){

			int local_s_tab[MAXSTOPS];
			int counter = 0;

			for(int y = 1; y < MAXSTOPS; y++){
				if(s_tab[i][y] ==0)
					break;
				local_s_tab[counter] = s_tab[i][y];
				counter++;

			}

			//create_group(local_s_tab,counter);

			int grouptraveltimeallowance[MAXTRIPIDX];
			bool secondpassinsertedtrip = false;

			for(int y = 0; y < MAXTRIPIDX; y++){
				grouptraveltimeallowance[y] = 0;
			}
			int extratraveltime = 0;
			int groupid = 1;

			for(int y = 0; y < counter;y++){

				string groupmark = schd_tab[local_s_tab[y]][GRPIDX];


				if(strcmp(schd_tab[local_s_tab[y]][2],MAXSTOPNUM[0])!=0){
					if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"D")==0  && groupmark!= "" ){
						//strcpy(schd_tab[local_s_tab[y]][GRPIDX],to_string(groupid).c_str());
						//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[y]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
						int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
						grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
					}
					if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"P")==0 && groupmark!= "" ){
						groupid++;
					}
				}

			}


			//bool isVol = isVolSegment(schd_tab[s_tab[i][1]][0], schd_tab[s_tab[i][1]][1],schd_tab[s_tab[i][1]][14]);
			getCS_CY_cap(cs_cap, bs_cap, schd_tab[s_tab[i][1]][SEGMENTTYPE]);

			//// //  if(DEBUG == 1) gse << "Here" <<endl;
			for(int k = 1; k < MAXSTOPS; k++){

				// // //  if(DEBUG == 1) gse << "Test " << s_tab[i][k] << endl;
				if(s_tab[i][k]==0){break;}

				p_stop_num = (int)to_number(schd_tab[s_tab[i][k]][2]);

				if(p_stop_num == 1){
					index = s_tab[i][k];
					cnt = 0;
					//// //  if(DEBUG == 1) gse << "Stop " << schd_tab[s_tab[i][k]][2] <<endl;
					disttrav = to_number(schd_tab[s_tab[i][k]][6]);
					dist = schd_tab[s_tab[i][k]][6];//////////////////////////////////move distance to after loop when finished converting binary tree function as
					////////////// because it stores the NEXT distance as distance FROM.


					//temp = schd_tab[s_tab[i][k]][4];
					promisedtime1 = schd_tab[s_tab[i][k]][4];
					prom_time =(int)to_number(promisedtime1);
					//// //  if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
					p_promised_time = itms_minutes_to_ampm(prom_time);
					est_traveltime1 = schd_tab[s_tab[i][k]][22];
					arrivetime1 =schd_tab[s_tab[i][k]][23];
					arrivetime1 = padStr( arrivetime1);
					departtime1 =schd_tab[s_tab[i][k]][24];
					departtime1 = padStr(departtime1);
					perftime1 = schd_tab[s_tab[i][k]][25];
					//perftime1 = padStr(perftime1);
					p_perf_time = (int)to_number(perftime1);
					starttime1 = schd_tab[s_tab[i][k]][26];
					starttime1  = padStr(starttime1 );
					endtime1 = schd_tab[s_tab[i][k]][27];
					endtime1 = padStr(endtime1);
					s_trip_appt_time = (int)to_number(endtime1);
					timetonextstop1 = schd_tab[s_tab[i][k]][28];
					eta1 = schd_tab[s_tab[i][k]][29];
					eta = (int)to_number(eta1);
					eta1 = itms_minutes_to_ampm(eta);

					etd1 = schd_tab[s_tab[i][k]][30]; /// fix this hack in get next token
					etd = (int)to_number(etd1);
					etd1 = itms_minutes_to_ampm(etd);
					//temp = schd_tab[s_tab[i][k]][10];
					lat1 =  schd_tab[s_tab[i][k]][10];
					lon1 =  schd_tab[s_tab[i][k]][37];
					lat2 =  schd_tab[s_tab[i][k]][38];

					lon2 = schd_tab[s_tab[i][k]][39]; /// fix this hack in get next token
					// temp = schd_tab[s_tab[i][k]][12];
					amb_occ1 =  schd_tab[s_tab[i][k]][31];
					wc_occ1 =  schd_tab[s_tab[i][k]][32];
					p_cs_occ = to_number(schd_tab[s_tab[i][k]][CS_OCC]);
					p_bs_occ =to_number(schd_tab[s_tab[i][k]][BS_OCC]);
					amb_cap1 =  schd_tab[s_tab[i][k]][33];
					//temp = temp+",";
					wc_cap1 =  schd_tab[s_tab[i][k]][34]; /// fix this hack in get next token
					grp_cnt_amb = schd_tab[s_tab[i][k]][35];
					p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
					grp_cnt_wc = schd_tab[s_tab[i][k]][36];
					p_grp_cnt_wc = (int)to_number(grp_cnt_wc);
					p_trip_type = schd_tab[s_tab[i][k]][8];
					p_spl_other_desc = schd_tab[s_tab[i][k]][9];
					last_dep_time = prom_time;
					last_arr_time = prom_time;
					p_name = schd_tab[s_tab[i][k]][14];
					p_return_trip = schd_tab[s_tab[i][k]][18];
					p_stop_type = schd_tab[s_tab[i][k]][7];

					disttrav = (int)to_number(schd_tab[s_tab[i][k]][6]);
					dist = schd_tab[s_tab[i][k]][6];
					//////////////////////////////////move distance to after loop when finished converting binary tree function as
					////////////// because it stores
					p_esc = (int)to_number(schd_tab[s_tab[i][k]][13]);
					p_td_segmentid = schd_tab[s_tab[i][k]][0];

					////  if(DEBUG == 1) gse << "The segment is for recalc " << p_td_segmentid << " " <<  schd_tab[s_tab[i][k]][0] << endl;

					p_stop_num = (int)to_number(schd_tab[s_tab[i][k]][2]);
					p_citytown = schd_tab[s_tab[i][k]][11];

					p_eta = eta1;
					p_etd = etd1;

				}



				//temp = schd_tab[s_tab[i][k]][4];
				promisedtime1 = schd_tab[s_tab[i][k]][4];
				prom_time =(int)to_number(promisedtime1);

				p_promised_time = itms_minutes_to_ampm(prom_time);
				est_traveltime1 = schd_tab[s_tab[i][k]][22];
				arrivetime1 =schd_tab[s_tab[i][k]][23];
				arrivetime1 = padStr( arrivetime1);
				departtime1 =schd_tab[s_tab[i][k]][24];
				departtime1 = padStr(departtime1);
				perftime1 = schd_tab[s_tab[i][k]][25];
				//perftime1 = padStr(perftime1);
				p_perf_time = (int)to_number(perftime1);
				starttime1 = schd_tab[s_tab[i][k]][26];
				starttime1  = padStr(starttime1 );
				endtime1 = schd_tab[s_tab[i][k]][27];
				endtime1 = padStr(endtime1);
				s_trip_appt_time = (int)to_number(endtime1);
				timetonextstop1 = schd_tab[s_tab[i][k]][28];
				eta1 = schd_tab[s_tab[i][k]][29];
				eta = (int)to_number(eta1);
				eta1 = itms_minutes_to_ampm(eta);

				etd1 = schd_tab[s_tab[i][k]][30]; /// fix this hack in get next token
				etd = (int)to_number(etd1);
				etd1 = itms_minutes_to_ampm(etd);
				//temp = schd_tab[s_tab[i][k]][10];
				lat1 =  schd_tab[s_tab[i][k]][10];
				lon1 =  schd_tab[s_tab[i][k]][37];
				lat2 =  schd_tab[s_tab[i][k]][38];

				lon2 = schd_tab[s_tab[i][k]][39]; /// fix this hack in get next token
				// temp = schd_tab[s_tab[i][k]][12];
				amb_occ1 =  schd_tab[s_tab[i][k]][31];
				wc_occ1 =  schd_tab[s_tab[i][k]][32];
				p_cs_occ = to_number(schd_tab[s_tab[i][k]][CS_OCC]);
				p_bs_occ =to_number(schd_tab[s_tab[i][k]][BS_OCC]);
				amb_cap1 =  schd_tab[s_tab[i][k]][33];
				//temp = temp+",";
				wc_cap1 =  schd_tab[s_tab[i][k]][34]; /// fix this hack in get next token
				grp_cnt_amb = schd_tab[s_tab[i][k]][35];
				p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
				grp_cnt_wc = schd_tab[s_tab[i][k]][36];
				p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

				p_disability = schd_tab[s_tab[i][k]][12];
				//p_amb_occ = to_number(amb_occ1);
				//p_wc_occ = to_number(wc_occ1);
				p_trip_type = schd_tab[s_tab[i][k]][8];
				p_spl_other_desc = schd_tab[s_tab[i][k]][9];
				//last_dep_time = prom_time;
				//last_arr_time = prom_time;
				p_name = schd_tab[s_tab[i][k]][14];
				p_return_trip = schd_tab[s_tab[i][k]][18];
				p_stop_type = schd_tab[s_tab[i][k]][7];
				p_esc = (int)to_number(schd_tab[s_tab[i][k]][13]);
				p_td_segmentid = schd_tab[s_tab[i][k]][0];


				if (p_stop_num == 1){
					last_dep_time = prom_time;
					last_arr_time = prom_time;
				}
				if(p_stop_num != 1){
					prev_distance = to_number( schd_tab[s_tab[i][k-1]][6]);
					timetonextstop2= to_number( schd_tab[s_tab[i][k-1]][28]);
				}

				disttrav = to_number( schd_tab[s_tab[i][k]][6]);


				p_citytown = schd_tab[s_tab[i][k]][11];

				p_eta = eta1;
				p_etd = etd1;



				//// //  if(DEBUG == 1) gse << "STOP TYPE  " <<  p_stop_type << endl;
				int p_WHEELLOAD1;
				int p_AMBLOAD1;
				int p_MAXEARLYDROPOFFFACTOR1;
				int p_DIALRIDEEARLYPICKFACTOR1;
				int p_DIALRIDELATEPICKFACTOR1;
				int p_OTHEREARLYPICKFACTOR1;
				int p_OTHERLATEPICKFACTOR1;
				string IGNOREPUTIMES1;
				int p_SHORTBREAK1;
				int p_LUNCHBREAK1;
				int p_PROXIMITYFACTOR1;
				int a_mediumshortdistance1;
				int a_mediumlongdistance1;
				int a_shorttriptime1;
				int a_longtriptime1;
				int a_mediumtriptime1;
				int a_extra_loadtime1;
				string ZONE_DESCR1;
				string IGNORE_DEPOTS_CUTOFF1;


				int grouppickupcnt = 0;

				string groupmark = schd_tab[s_tab[i][k]][GRPIDX];
				if(groupmark != ""){
					int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
					grouppickupcnt = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
					//  if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
				}

				string pReturn_trip = schd_tab[s_tab[i][k]][18];
				string  pDisability = schd_tab[s_tab[i][k]][12];
				string p_trip_type1 = schd_tab[s_tab[i][k]][8];
				set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
						p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
						a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);
				double estdisttrip = to_number(schd_tab[s_tab[i][k]][21]);

				int aAllowedTT;



				if(estdisttrip < a_mediumshortdistance1)
					aAllowedTT = a_shorttriptime1 + grouppickupcnt;
				else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
					aAllowedTT = a_mediumtriptime1 + grouppickupcnt;
				else
					aAllowedTT = a_longtriptime1 + grouppickupcnt;

				if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
					aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
				}



				int p_perf_time;
				string pDisposition = schd_tab[s_tab[i][k]][DISPOSITION];
				set_p_perf_time(pDisposition,pDisability, p_perf_time, p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1 );

				int est_time;
				string tripid = schd_tab[s_tab[i][k]][3];
				tripid = tripid.substr(0,1);
				string endtime2;
				if(tripid == "S"){
					endtime2 =to_string( (int)itms_to_minutes(ampm2fullhrs(p_promised_time)));
				}

				if(p_stop_type == "P"){
					if((int)to_number(starttime1)!= 0)
						est_time = (int)to_number(starttime1);
					else{
						est_time =  (int)to_number(endtime2) - (int)to_number(est_traveltime1);
					}
				}
				else{
					if((int)to_number(endtime2)!= 0)
						est_time = (int)to_number(endtime2);
					else{

						est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
					}
				}

				string timezonetime = itms_minutes_to_ampm(est_time);
				//p_eta = eta1;
				if(p_stop_num ==1){
					p_eta = p_promised_time;
					p_etd = etd1;
				}
				else{
					p_eta = eta1;
					p_etd = etd1;
				}
				string route = schd_tab[s_tab[i][k]][0];
				if( (route == "" || timeZones(p_eta, timezonetime) != timeZones(timezonetime,p_eta))  && !secondpassinsertedtrip){time_zone = timeZones(p_eta, timezonetime); secondpassinsertedtrip = true;}
				else{  if(F_GET_TRAVEL_TIME (1.0 , timeZones(p_eta, timezonetime), "*") > F_GET_TRAVEL_TIME (1.0 , timeZones(timezonetime,p_eta), "*")){
					time_zone = timeZones(p_eta, timezonetime);secondpassinsertedtrip = false;
				}
				else{
					time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
				}
				//time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
				}
				//time_zone = timeZones(p_eta, timezonetime);
				string timezone2;
				if (p_stop_num != 1) {
					if (!isSameLocation(s_tab[i][k],s_tab[i][k - 1]))
						timezone2 = "#"; // not the same lat/long
					else
						timezone2 = "*";
				}








				varHolder = itms_calcroute( arrivetime1, departtime1,timetonextstop2,  rteStr ,   p_citytown ,     p_street_by_street ,     p_eta  ,    p_promised_time ,     p_perf_time ,   p_early_morning_factor ,  p_stop_num ,
						p_td_segmentid,  p_wc_occ   , p_amb_occ,   p_esc  ,  p_disability  , p_stop_type  ,  p_WHEELLOAD[0] ,  p_AMBLOAD[0] ,
						p_customer ,   p_return_trip  ,  p_DIALRIDEEARLYPICKFACTOR[0]  ,  p_DIALRIDELATEPICKFACTOR[0] ,  p_PROXIMITYFACTOR[0],  p_SHORTBREAK[0]  ,
						p_LUNCHBREAK[0]   ,   p_MAXEARLYDROPOFFFACTOR[0]  , p_OTHEREARLYPICKFACTOR[0]  ,  p_OTHERLATEPICKFACTOR[0] ,   p_name    ,
						p_timetonextstop , p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
						OffLoaded   , p_trip_type ,    p_prev_perf_time ,   p_prev_stop_num , p_latency   ,  s_trip_appt_time ,  p_grp_cnt_amb ,
						p_grp_cnt_wc,  ignorepu[0],  IGNORE_DEPOTS_CUTOFF[0], time_zone, timezone2, starttime1, p_cs_occ,p_bs_occ,last_cs_occ,last_bs_occ,pDisposition);






				p_eta = std::get<0>(varHolder);
				p_wc_occ=std::get<1>(varHolder);
				p_amb_occ=std::get<2>(varHolder);
				p_esc=std::get<3>(varHolder);
				p_timetonextstop=std::get<4>(varHolder);
				p_disttonextstop=std::get<5>(varHolder);
				p_earlystoptime=std::get<6>(varHolder);
				p_latestoptime=std::get<7>(varHolder);
				tot_miles=std::get<8>(varHolder);
				tot_driv_time=std::get<9>(varHolder);
				p_etd=std::get<10>(varHolder);
				OffLoaded=std::get<11>(varHolder);
				p_perf_time = std::get<12>(varHolder);
				p_cs_occ = std::get<13>(varHolder);
				p_bs_occ = std::get<14>(varHolder);
				if(!secondpassinsertedtrip){
					p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs(p_etd)) - p_perf_time);

					if (p_stop_num != 1 && p_stop_num != (int)to_number(MAXSTOPNUM[0])) {
						if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0)

							AGRPCOUNTER = AGRPCOUNTER + 1;
						else{
							if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0)
							{
								APRVGRPCOUNTER = AGRPCOUNTER + 1;
							}
							AGRPCOUNTER = 0;
						}


						if(p_disability.find("WC",0) == string::npos && p_disability.find("SC",0) == string::npos && p_disability.find("XLT",0) == string::npos){


							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0){

								//  if(DEBUG == 1) gse << "petd changing " << p_etd << endl;

								p_perf_time = p_perf_time / AGRPCOUNTER;
							}


							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0) {

								p_perf_time = p_perf_time / APRVGRPCOUNTER;
								APRVGRPCOUNTER = 0;
							}
						}
						else{

							if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


								if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0) {

									p_perf_time = p_perf_time / AGRPCOUNTER;
								}

								if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0) {

									p_perf_time = p_perf_time / APRVGRPCOUNTER;
									APRVGRPCOUNTER = 0;
								}
							}
						}

					}
					p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) + p_perf_time);
					//  if(DEBUG == 1) gse << "petd changing after " << p_etd << endl;
				}

				if(p_stop_type  == "P"){
					string tripidforwait = schd_tab[s_tab[i][k]][3];
					int DW = getDWByStop (tripidforwait, p_stop_type ,itms_to_minutes(ampm2fullhrs (p_eta)) , itms_to_minutes (ampm2fullhrs(p_etd)),(int)to_number(starttime1),p_perf_time);
					int PW = getPWByStop (tripidforwait,  p_stop_type  ,itms_to_minutes(ampm2fullhrs (p_eta))    , (int)to_number(starttime1));
					strcpy(schd_tab[s_tab[i][k]][DWWAIT], to_string(DW).c_str());
					strcpy(schd_tab[s_tab[i][k]][PWWAIT], to_string(PW).c_str());
				}
				else{
					int eta = itms_to_minutes (ampm2fullhrs (p_eta));
					int etd = (int)to_number(schd_tab[s_tab[i][k-1]][30]);
					int TT = (int)to_number(schd_tab[s_tab[i][k-1]][CALCULATEDTIME]);
					string tripidforwait = schd_tab[s_tab[i][k]][3];
					int DW = eta - etd + TT;
					int PW = getPWByStop (tripidforwait,  schd_tab[s_tab[i][k]][7],eta, (int)to_number(endtime1));
					strcpy(schd_tab[s_tab[i][k]][DWWAIT],to_string(DW).c_str());
					strcpy(schd_tab[s_tab[i][k]][PWWAIT],to_string(PW).c_str());
				}



				//capacity  = to_string(p_amb_occ)+ ","+ to_string(p_wc_occ)+","+ amb_cap1+","+ wc_cap1+ "," +to_string(p_grp_cnt_amb) +","+ to_string(p_grp_cnt_wc)+","+ p_disability;
				//times  =  to_string(itms_to_minutes (ampm2fullhrs ( p_promised_time))) +","+est_traveltime1 +","+arrivetime1 +","+ departtime1 +","+to_string(p_perf_time) +","+starttime1 +","+endtime1 +","+to_string(p_timetonextstop) +","+to_string(itms_to_minutes (ampm2fullhrs (p_eta))) +","+to_string(itms_to_minutes (ampm2fullhrs (p_etd)));


				strcpy((schd_tab[s_tab[i][k]][4]) , to_string(itms_to_minutes (ampm2fullhrs (p_promised_time))).c_str());

				strcpy((schd_tab[s_tab[i][k]][22]) , est_traveltime1.c_str());

				strcpy((schd_tab[s_tab[i][k]][23]) , arrivetime1.c_str());

				strcpy((schd_tab[s_tab[i][k]][24]) , departtime1.c_str());

				strcpy((schd_tab[s_tab[i][k]][25]) , to_string(p_perf_time).c_str());

				strcpy((schd_tab[s_tab[i][k]][26]) , starttime1.c_str());

				strcpy((schd_tab[s_tab[i][k]][27]) , endtime1.c_str() );
				if(k > 1){
					strcpy((schd_tab[s_tab[i][k-1]][28]) , to_string(timetonextstop2).c_str());
					strcpy((schd_tab[s_tab[i][k-1]][CALCULATEDTIME]) , to_string(p_timetonextstop).c_str());

				}

				strcpy((schd_tab[s_tab[i][k]][29]) , to_string(itms_to_minutes (ampm2fullhrs (p_eta))).c_str());

				strcpy((schd_tab[s_tab[i][k]][30]) ,to_string(itms_to_minutes (ampm2fullhrs (p_etd))).c_str());

				strcpy((schd_tab[s_tab[i][k]][31]) , to_string(p_amb_occ).c_str());

				strcpy((schd_tab[s_tab[i][k]][32]) , to_string(p_wc_occ).c_str());
				strcpy((schd_tab[s_tab[i][k]][CS_OCC]), to_string(p_cs_occ).c_str());
				strcpy((schd_tab[s_tab[i][k]][BS_OCC]), to_string(p_bs_occ).c_str());
				//strcpy((schd_tab[s_tab[i][k]][DIRTYBIT]) , ("Y"));

				strcpy( schd_tab[s_tab[i][k]][38], schd_tab[s_tab[i][k+1]][10]);
				strcpy( schd_tab[s_tab[i][k]][39], schd_tab[s_tab[i][k+1]][37]);

				//strcpy((schd_tab[s_tab[i][k]][6]) ,to_string(disttrav).c_str());

				//slack_calc(s_tab[i][k], schd_tab);

				//  if(DEBUG == 1) gse << "Slack " << schd_tab[s_tab[i][k]-1][40] << endl;


				//// //  if(DEBUG == 1) gse << schd_tab[s_tab[i][k]][31] << endl;

				prev_eta1 = schd_tab[s_tab[i][k]][29];
				prev_eta = (int)to_number(prev_eta1);
				prev_eta1 = itms_minutes_to_ampm(prev_eta);

				if(secondpassinsertedtrip){  if(DEBUG == 1) gse << "REDOING" << endl; k--;continue;}

				//if(p_stop_num != 999)
				cnt++;




				prev_perftime1 = schd_tab[s_tab[i][k]][25];
				prev_p_perf_time = (int)to_number(prev_perftime1);



				prev_etd1 = schd_tab[s_tab[i][k]][30]; /// fix this hack in get next token
				prev_etd = (int)to_number(prev_etd1);
				prev_etd1 = itms_minutes_to_ampm(prev_etd);
				//temp = schd_tab[s_tab[i][k]][12];
				prev_amb_occ1 =  schd_tab[s_tab[i][k]][31];
				prev_wc_occ1 =  schd_tab[s_tab[i][k]][32];
				last_dep_time=prev_etd;
				last_arr_time=prev_eta;
				string prev_cs_occ = schd_tab[s_tab[i][k]][CS_OCC];
				string prev_bs_occ = schd_tab[s_tab[i][k]][BS_OCC];
				last_cs_occ=to_number(prev_cs_occ);
				last_bs_occ=to_number(prev_bs_occ);
				last_amb_occ=(int)to_number(prev_amb_occ1);
				last_wc_occ=(int)to_number(prev_wc_occ1);
				p_prev_perf_time = prev_p_perf_time;
				p_prev_stop_num = (int)to_number(schd_tab[s_tab[i][k]][2]);
				p_prev_promised_time = p_promised_time;

				//   if(DEBUG == 1) gse << p_stop_num << " \t " << p_promised_time << " \t " << p_eta << " \t " << p_etd << " \t "  << setprecision(2) << prev_distance <<  "  \t" << p_timetonextstop << " \t " << p_stop_type << "\t " << p_wc_occ << " \t" << p_amb_occ << "\t" << p_cs_occ << "\t" << p_bs_occ << "\t" << p_esc << " " << arrivetime1 << " " << departtime1 << endl;





			}
			//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
		}

		break;
	}




	double duration = 1000.0 *( std::clock() - start2 ) / (double) CLOCKS_PER_SEC;
	// //  if(DEBUG == 1) gse <<"updating shared memory: "<< duration <<'\n';

	std::clock_t start = std::clock();

	// if(DEBUG == 1) gse << cnt << endl;

	//if(updatedb){ updateDatabase(cnt, indexstart  , env, conn, schd_tab,s_tab,table_itms_segments, table_itms_trips);}

	duration = 1000.0 *( std::clock() - start ) / (double) CLOCKS_PER_SEC;
	////  if(DEBUG == 1) gse <<"Updating Database: "<< duration <<'\n';

	double duration2 = 1000.0 *( std::clock() - start2 ) / (double) CLOCKS_PER_SEC;
	//  if(DEBUG == 1) gse <<"calculating for one: "<< duration2 <<'\n';






}


bool insertandcalcrouteREOPTIMIZE(int counter, double * distances, double * time,  int * local_s_tab){

	////  if(DEBUG == 1) gse << "checking late and early factors " <<  p_DIALRIDEEARLYPICKFACTOR[0] << " " <<p_DIALRIDELATEPICKFACTOR[0] << endl;
	//  if(DEBUG == 1) gse << " insert and calc route " << endl;

	int p_WHEELLOAD1;
	int p_AMBLOAD1;
	int p_MAXEARLYDROPOFFFACTOR1;
	int p_DIALRIDEEARLYPICKFACTOR1;
	int p_DIALRIDELATEPICKFACTOR1;
	int p_OTHEREARLYPICKFACTOR1;
	int p_OTHERLATEPICKFACTOR1;
	string IGNOREPUTIMES1;
	int p_SHORTBREAK1;
	int p_LUNCHBREAK1;
	int p_PROXIMITYFACTOR1;
	int a_mediumshortdistance1;
	int a_mediumlongdistance1;
	int a_shorttriptime1;
	int a_longtriptime1;
	int a_mediumtriptime1;
	int a_extra_loadtime1;
	string ZONE_DESCR1;
	string IGNORE_DEPOTS_CUTOFF1;



	// //  if(DEBUG == 1) gse << "made it2 " << endl;




	int SEGSTART  = 0;

	bool routeFound = false;
	string a_route;

	////  if(DEBUG == 1) gse << "made it2 " << endl;


	int s_tab_idx;

	if(counter > 0){
		//// //  if(DEBUG == 1) gse << "COUNTER " << counter << endl;
		if(DEBUG == 1) gse <<"Stop  prom time    eta   etd     dist ttime stoptype    wc    amb \t esc"<< endl;
	}
	std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>  varHolder;
	string p_customer;
	bool notFound;
	int f1 = 0;
	int f2 = 0;


	std::string  promisedtime1;
	int prom_time;
	std::string est_traveltime1;
	std::string arrivetime1;
	std::string departtime1 ;
	std::string perftime1 ;
	int p_perf_time;
	std::string starttime1 ;
	std::string endtime1;
	std::string timetonextstop1 ;
	std::string eta1 ;
	int eta;
	std::string etd1; /// fix this hack in get next token
	int etd;
	std::string  lat1  ;
	std::string lon1   ;
	std::string lat2 ;
	std::string lon2;
	/// fix this  p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
	///OffLoaded   , p_trip_type ,    p_hack in get next token
	std::string  amb_occ1 ;
	std::string wc_occ1 ;
	int cs_cap = 0;
	int bs_cap = 0;
	std::string amb_cap1 ;
	std::string wc_cap1 ; /// fix this hack in get next token
	int p_amb_occ;
	int p_wc_occ;
	int p_cs_occ;
	int p_bs_occ;
	int p_grp_cnt_wc;
	int p_grp_cnt_amb;
	int s_trip_appt_time = 0;
	int p_latency = 0;
	int p_prev_stop_num;
	int p_prev_perf_time;
	int OffLoaded;
	string p_trip_type ;
	string p_spl_other_desc ;
	int last_wc_occ = 0, last_cs_occ = 0, last_bs_occ = 0;
	int last_amb_occ = 0;
	int last_dep_time ;
	int last_arr_time ;
	int tot_driv_time = 0;
	double tot_miles = 0;
	string p_latestoptime ="";
	string p_earlystoptime= "";
	double p_disttonextstop = 0.0;
	int p_timetonextstop = 0;
	string p_name ;
	string p_return_trip ;
	string p_stop_type ;
	string p_disability = "" ;
	int p_esc;
	string p_td_segmentid = "";
	int stopnum1;
	int p_stop_num;
	int p_early_morning_factor = 0;
	string p_street_by_street = "T";
	string p_citytown;
	string time_zone2 = "*";
	string time_zone;// = "*";
	int petaint;
	string rteStr;
	double disttrav;
	string grp_cnt_amb;
	string grp_cnt_wc;
	string dist;
	string p_promised_time;
	string p_eta;
	string p_etd;
	string capacity;
	string times;
	string prev_perftime1,prev_eta1,prev_etd1, prev_amb_occ1, prev_wc_occ1;
	int prev_eta,prev_etd,prev_p_perf_time;
	//int index;
	bool ontime = true;
	//int cnt = 0;
	double disttrav2;
	double prev_distance = 0;
	int AGRPCOUNTER = 0;
	int APRVGRPCOUNTER = 0;
	//bool recalc = false;



	string indafter1;string indafter2;


	string pueta;
	string doeta;
	string disttravpu;
	string disttravdo;
	string pustp;
	string dostp;
	string puetd;
	string doetd;
	string latlon1;
	string latlon2;
	string latlon3;
	string latlon4;
	string oResult;
	int actualTT = 0;
	string distholder[counter];
	string timeholder[counter];
	string origdistholder[MAXSTOPS];
	string origtimeholder[MAXSTOPS];
	bool finished = false;
	string route = schd_tab[local_s_tab[0]][0];
	int routeint = (int)to_number(route.substr(1,route.length()));
	int aStp = 0;//first stop to be inserted.
	string p_prev_promised_time = "0000A";
	int timetrav;



	////  if(DEBUG == 1) gse << "Counter " << counter << endl;



	//  if(DEBUG == 1) gse << "original distances " << endl;
	for(int i = 0; i < MAXSEGMENTS; i++){ ///save original distances
		if(s_tab[i][0]==routeint){
			s_tab_idx = i;
			//  if(DEBUG == 1) gse << "orginial distances route " << s_tab[i][0] << endl;
			for(int k = 1;k < MAXSTOPS; k++){
				if(s_tab[i][k]==0){break;}
				origdistholder[k] = schd_tab[s_tab[i][k]][6];
				origtimeholder[k] = schd_tab[s_tab[i][k]][28];
				//  if(DEBUG == 1) gse << schd_tab[s_tab[i][k]][2] << " " << schd_tab[s_tab[i][k]][3] << " " << schd_tab[s_tab[i][k]][6] << endl;
			}
		}
	}

	//  if(DEBUG == 1) gse << "The passed distances are " << endl;
	for(int i = 0; i < counter; i++){
		//  if(DEBUG == 1) gse << distances[local_s_tab[i]] << " " << local_s_tab[i] << " "   << endl;
	}


	//  if(DEBUG == 1) gse << "Tripids : " << endl;

	for(int i = 0; i < counter; i++){ ///copy new distances into array in correct stop order
		//if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || (strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 && strcmp(schd_tab[local_s_tab[i]][2], "999")!=0) ) {
		// //  if(DEBUG == 1) gse << " Using distance " << distances[f2] << endl;
		timetrav = time[local_s_tab[i]];
		disttrav = distances[local_s_tab[i]];
		timeholder[i] = to_string(timetrav);
		distholder[i] = to_string(disttrav);
		f2++;
		//  if(DEBUG == 1) gse << schd_tab[local_s_tab[i]][3] << " " << distances[local_s_tab[i]] << endl;
		//}
		//else{
		//distholder[i] = schd_tab[local_s_tab[i]][6];
		//}
	}
	for(int k = 0; k < counter; k++){ //overwrite distances in trips table
		strcpy( schd_tab[local_s_tab[k]][28] , timeholder[k].c_str());
		strcpy( schd_tab[local_s_tab[k]][6] , distholder[k].c_str());
	}


	//  if(DEBUG == 1) gse << "Distances and stopnumber and trip id " << endl;
	for(int i = 0; i < counter; i++){
		//  if(DEBUG == 1) gse << schd_tab[local_s_tab[i]][2] << " " << schd_tab[local_s_tab[i]][3] << " " << schd_tab[local_s_tab[i]][6] << endl;
	}

	create_group(local_s_tab,counter);

	int grouptraveltimeallowance[MAXTRIPIDX];


	for(int y = 0; y < MAXTRIPIDX; y++){
		grouptraveltimeallowance[y] = 0;
	}
	int extratraveltime = 0;
	int groupid = 1;

	string origetaholder[counter];
	string origetdholder[counter];
	string origCalculatedTime[counter];


	for(int y = 0; y < counter;y++){

		if(strcmp(schd_tab[local_s_tab[y]][0],"")!=0){
			origetaholder[y] = schd_tab[local_s_tab[y]][29];
			origetdholder[y] = schd_tab[local_s_tab[y]][30];
			origCalculatedTime[y] = schd_tab[local_s_tab[y]][CALCULATEDTIME];
		}
	}

	for(int y = 0; y < counter;y++){

		string groupmark = schd_tab[local_s_tab[y]][GRPIDX];


		if(strcmp(schd_tab[local_s_tab[y]][2],MAXSTOPNUM[0])!=0){
			if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"D")==0  && groupmark!= "" ){
				//strcpy(schd_tab[local_s_tab[y]][GRPIDX],to_string(groupid).c_str());
				//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[y]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
				int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
				grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
			}
			if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"P")==0  && groupmark!= ""){
				groupid++;
			}
		}

	}
	aStp = 1; //check from the beginning of  the segment

	bool secondpassinsertedtrip = false;

	int timetraveled = 0;


	////  if(DEBUG == 1) gse << "using all 1 " << 0 << " " <<  a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;


	//bool isVol = isVolSegment(schd_tab[local_s_tab[0]][0], schd_tab[local_s_tab[0]][1],schd_tab[local_s_tab[0]][14]);
	getCS_CY_cap(cs_cap, bs_cap, schd_tab[local_s_tab[0]][SEGMENTTYPE]);

	for(int i = 0; i < counter; i++)
	{


		//  if(DEBUG == 1) gse << "i is " << i <<   " " << local_s_tab[i] << endl;

		promisedtime1 = schd_tab[local_s_tab[i]][4];
		prom_time =(int)to_number(promisedtime1);
		//// //  if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
		p_promised_time = itms_minutes_to_ampm(prom_time);
		est_traveltime1 = schd_tab[local_s_tab[i]][22];
		arrivetime1 =schd_tab[local_s_tab[i]][23];
		arrivetime1 = padStr( arrivetime1);
		departtime1 =schd_tab[local_s_tab[i]][24];
		departtime1 = padStr(departtime1);
		perftime1 = schd_tab[local_s_tab[i]][25];
		//perftime1 = padStr(perftime1);
		p_perf_time = (int)to_number(perftime1);
		starttime1 = schd_tab[local_s_tab[i]][26];
		starttime1  = padStr(starttime1 );
		endtime1 = schd_tab[local_s_tab[i]][27];
		endtime1 = padStr(endtime1);
		s_trip_appt_time = (int)to_number(endtime1);
		timetonextstop1 = schd_tab[local_s_tab[i]][28];
		eta1 = schd_tab[local_s_tab[i]][29];
		// //  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
		eta = (int)to_number(eta1);
		// //  if(DEBUG == 1) gse << "eat and int " << eta << endl;
		eta1 = itms_minutes_to_ampm(eta);
		////  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
		etd1 = schd_tab[local_s_tab[i]][30]; /// fix this hack in get next token
		etd = (int)to_number(etd1);
		etd1 = itms_minutes_to_ampm(etd);
		//temp = schd_tab[local_s_tab[i]][10];
		lat1 =  schd_tab[local_s_tab[i]][10];
		lon1 =  schd_tab[local_s_tab[i]][37];
		lat2 =  schd_tab[local_s_tab[i]][38];

		lon2 = schd_tab[local_s_tab[i]][39]; /// fix this hack in get next token
		// temp = schd_tab[local_s_tab[i]][12];
		amb_occ1 =  schd_tab[local_s_tab[i]][31];
		wc_occ1 =  schd_tab[local_s_tab[i]][32];
		p_cs_occ = to_number(schd_tab[local_s_tab[i]][CS_OCC]);
		p_bs_occ =to_number(schd_tab[local_s_tab[i]][BS_OCC]);
		amb_cap1 =  schd_tab[local_s_tab[SEGSTART]][33];
		//temp = temp+",";
		wc_cap1 =  schd_tab[local_s_tab[SEGSTART]][34]; /// fix this hack in get next token
		grp_cnt_amb = schd_tab[local_s_tab[i]][35];
		p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
		grp_cnt_wc = schd_tab[local_s_tab[i]][36];
		p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

		p_disability = schd_tab[local_s_tab[i]][12];
		//p_amb_occ = to_number(amb_occ1);
		//p_wc_occ = to_number(wc_occ1);
		p_trip_type = schd_tab[local_s_tab[i]][8];
		p_spl_other_desc = schd_tab[local_s_tab[i]][9];
		//last_dep_time = prom_time;
		//last_arr_time = prom_time;
		p_name = schd_tab[local_s_tab[i]][14];
		p_return_trip = schd_tab[local_s_tab[i]][18];
		p_stop_type = schd_tab[local_s_tab[i]][7];
		p_esc = (int)to_number(schd_tab[local_s_tab[i]][13]);
		p_stop_num = (int)to_number(schd_tab[local_s_tab[i]][2]);
		p_td_segmentid = schd_tab[local_s_tab[SEGSTART]][0];
		//  //  if(DEBUG == 1) gse << "The segment is  " << p_td_segmentid << " " <<  schd_tab[local_s_tab[SEGSTART]][0] << endl;
		////  if(DEBUG == 1) gse << "STop num " << p_stop_num<< endl;
		prev_distance = 0;
		if (p_stop_num == 1){
			last_dep_time = prom_time;
			last_arr_time = prom_time;

		}
		if(p_stop_num != 1){
			prev_distance = to_number( schd_tab[local_s_tab[i-1]][6]);
			disttrav = prev_distance;
			timetraveled = to_number( schd_tab[local_s_tab[i-1]][28]);
		}



		if(p_disability.find("OT",0)!= string::npos){
			for(int z = 0; z < MAXZONES; z++){
				if(strcmp("OT", ZONE_DESCR[z])==0){
					p_WHEELLOAD1 =p_WHEELLOAD[z] ;
					p_AMBLOAD1 =p_AMBLOAD[z];
					p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
					p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
					p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
					p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
					p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
					IGNOREPUTIMES1 = ignorepu[z] ;
					p_SHORTBREAK1 = p_SHORTBREAK[z] ;
					p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
					p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
					a_mediumshortdistance1 = a_mediumshortdistance[z] ;
					a_mediumlongdistance1 = a_mediumlongdistance[z] ;
					a_shorttriptime1 = a_shorttriptime[z] ;
					a_longtriptime1 = a_longtriptime[z] ;
					a_mediumtriptime1 =  a_mediumtriptime[z] ;
					a_extra_loadtime1 = a_extra_loadtime[z];
					ZONE_DESCR1 =   ZONE_DESCR[z] ;
					IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
					break;
				}
				if(z+1 == MAXZONES){
					for(int b = 0; b < MAXZONES; b++){

						if(strcmp("ALL", ZONE_DESCR[b])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[b] ;
							p_AMBLOAD1 = p_AMBLOAD[b];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
							IGNOREPUTIMES1 = ignorepu[b] ;
							p_SHORTBREAK1 = p_SHORTBREAK[b] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
							a_mediumshortdistance1 = a_mediumshortdistance[b] ;
							a_mediumlongdistance1 = a_mediumlongdistance[b] ;
							a_shorttriptime1 = a_shorttriptime[b] ;
							a_longtriptime1 = a_longtriptime[b] ;
							a_mediumtriptime1 =  a_mediumtriptime[b] ;
							a_extra_loadtime1 = a_extra_loadtime[b];
							ZONE_DESCR1 =   ZONE_DESCR[b] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
							break;
						}
					}

				}
			}


		}
		else if( p_disability.find("OT",0)== string::npos){
			for(int z = 0; z < MAXZONES; z++){
				if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
					p_WHEELLOAD1 =p_WHEELLOAD[z] ;
					p_AMBLOAD1 =p_AMBLOAD[z];
					p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
					p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
					p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
					p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
					p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
					IGNOREPUTIMES1 = ignorepu[z] ;
					p_SHORTBREAK1 = p_SHORTBREAK[z] ;
					p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
					p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
					a_mediumshortdistance1 = a_mediumshortdistance[z] ;
					a_mediumlongdistance1 = a_mediumlongdistance[z] ;
					a_shorttriptime1 = a_shorttriptime[z] ;
					a_longtriptime1 = a_longtriptime[z] ;
					a_mediumtriptime1 =  a_mediumtriptime[z] ;
					a_extra_loadtime1 = a_extra_loadtime[z];
					ZONE_DESCR1 =   ZONE_DESCR[z] ;
					IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
					break;
				}
				if(z+1 == MAXZONES){
					for(int b = 0; b < MAXZONES; b++){
						if(strcmp("ALL", ZONE_DESCR[b])==0){
							p_WHEELLOAD1 = p_WHEELLOAD[b] ;
							p_AMBLOAD1 = p_AMBLOAD[b];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
							IGNOREPUTIMES1 = ignorepu[b] ;
							p_SHORTBREAK1 = p_SHORTBREAK[b] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
							a_mediumshortdistance1 = a_mediumshortdistance[b] ;
							a_mediumlongdistance1 = a_mediumlongdistance[b] ;
							a_shorttriptime1 = a_shorttriptime[b] ;
							a_longtriptime1 = a_longtriptime[b] ;
							a_mediumtriptime1 =  a_mediumtriptime[b] ;
							a_extra_loadtime1 = a_extra_loadtime[b];
							ZONE_DESCR1 =   ZONE_DESCR[b] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];

							////  if(DEBUG == 1) gse << "using all " << b << " " <<  a_shorttriptime[b] << " " << a_mediumtriptime[b] << " " << a_longtriptime[b] << endl;
							break;
						}
					}

				}
			}
		}


		/*  if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ){//strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ){
                            prev_distance = distances[f1];
                            f1++;
                         //  if(DEBUG == 1) gse << "Prev distance inserted trip " << prev_distance << " " <<  schd_tab[local_s_tab[i]][3] << endl;
                            }
                            else{
                             prev_distance = to_number( schd_tab[local_s_tab[i-1]][6]);
                            // //  if(DEBUG == 1) gse << "Prev distance non inserted" << prev_distance << " " <<  schd_tab[local_s_tab[i]][3] << endl;
                            }
                        }
                       if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ) {
                          // //  if(DEBUG == 1) gse << " Using distance " << distances[f2] << endl;
                        disttrav = distances[f2];
                        distholder[i] = to_string(disttrav);
                        f2++;
                       }
                       else{
                           distholder[i] = schd_tab[local_s_tab[i]][6];
                       }*/

		//   //  if(DEBUG == 1) gse << "The distance is " << distholder[i] << " " << i <<  endl;

		////  if(DEBUG == 1) gse << "Disttrav " << prev_distance << endl;

		p_citytown =  schd_tab[local_s_tab[i]][11];


		//if (aStp == 0 && strcmp(schd_tab[local_s_tab[i]][0],"")==0)
		// aStp = (int)to_number(schd_tab[local_s_tab[i]][2]);


		int p_WHEELLOAD1;
		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;



		int grouppickupcnt = 0;

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];
		if(groupmark != ""){
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			grouppickupcnt = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
			//  if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
		}




		string pReturn_trip = schd_tab[local_s_tab[i]][18];
		string  pDisability = schd_tab[local_s_tab[i]][12];
		string p_trip_type1 = schd_tab[local_s_tab[i]][8];

		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

		int aAllowedTT;
		/*if(to_number(estdist[0]) < 3.0)
                            aAllowedTT = 50;
                        else if(to_number(estdist[0]) >= 3.0 &&  to_number(estdist[0]) < 6.0)
                            aAllowedTT = 65;
                        else if(to_number(estdist[0]) >= 6.0 &&  to_number(estdist[0])< 9.0)
                            aAllowedTT = 95;
                        else if(to_number(estdist[0]) >= 9.0 &&  to_number(estdist[0]) < 12.0)
                            aAllowedTT = 115;
                        else if(to_number(estdist[0])>= 12.0 && to_number(estdist[0]) < 14.0)
                            aAllowedTT = 135;
                        else if(to_number(estdist[0]) > 14.0)
                            aAllowedTT = 155;*/





		double estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);
		int allowedDW;
		double esttime = to_number(schd_tab[local_s_tab[i]][22]);

		if(estdisttrip < a_mediumshortdistance1){
			aAllowedTT = a_shorttriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
		}
		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
			aAllowedTT = a_mediumtriptime1 + extratraveltime;
		}
		else{
			aAllowedTT = a_longtriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
		}

		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
		}

		int p_perf_time;
		string pDisposition = schd_tab[local_s_tab[i]][DISPOSITION];
		set_p_perf_time(pDisposition,pDisability, p_perf_time, p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1 );

		int est_time;
		string tripid = schd_tab[local_s_tab[i]][3];
		tripid = tripid.substr(0,1);
		string endtime2;
		if(tripid == "S"){
			endtime2 =to_string( (int)itms_to_minutes(ampm2fullhrs(p_promised_time)));
		}

		if(p_stop_type == "P"){
			if((int)to_number(starttime1)!= 0)
				est_time = (int)to_number(starttime1);
			else{
				est_time =  (int)to_number(endtime2) - (int)to_number(est_traveltime1);
			}
		}
		else{
			if((int)to_number(endtime2)!= 0)
				est_time = (int)to_number(endtime2);
			else{

				est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
			}
		}

		string timezonetime = itms_minutes_to_ampm(est_time);
		//p_eta = eta1;
		if(p_stop_num ==1){
			p_eta = p_promised_time;
			p_etd = etd1;
		}
		else{
			p_eta = eta1;
			p_etd = etd1;
		}
		string route = schd_tab[local_s_tab[i]][0];
		if( (route == "" || timeZones(p_eta, timezonetime) != timeZones(timezonetime,p_eta))  && !secondpassinsertedtrip){time_zone = timeZones(p_eta, timezonetime); secondpassinsertedtrip = true;}
		else{  if(F_GET_TRAVEL_TIME (1.0 , timeZones(p_eta, timezonetime), "*") > F_GET_TRAVEL_TIME (1.0 , timeZones(timezonetime,p_eta), "*")){
			time_zone = timeZones(p_eta, timezonetime);secondpassinsertedtrip = false;
		}
		else{
			time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(p_eta, timezonetime);
		string timezone2;
		if (p_stop_num != 1) {
			if (!isSameLocation(local_s_tab[i],local_s_tab[i-1]))
				timezone2 = "#"; // not the same lat/long
			else
				timezone2 = "*";
		}







		////  if(DEBUG == 1) gse << "Est distance " << estdisttrip << " for trip " << schd_tab[local_s_tab[i]][3] << " allowed time " << aAllowedTT << endl;




		//

		//  if(DEBUG == 1) gse << "ETa 1" << p_eta << " " << p_etd << endl;
		////  if(DEBUG == 1) gse << "1. I am here " << prev_distance << endl;

		//  if(DEBUG == 1) gse << "before recalc " << endl;

		varHolder = itms_calcroute( arrivetime1, departtime1,timetraveled,  rteStr ,   p_citytown ,     p_street_by_street ,     p_eta  ,    p_promised_time ,     p_perf_time ,   p_early_morning_factor ,  p_stop_num ,
				p_td_segmentid,  p_wc_occ   , p_amb_occ,   p_esc  ,  p_disability  , p_stop_type  ,  p_WHEELLOAD[0] ,  p_AMBLOAD[0] ,
				p_customer ,   p_return_trip  ,  p_DIALRIDEEARLYPICKFACTOR[0]  ,  p_DIALRIDELATEPICKFACTOR[0] ,  p_PROXIMITYFACTOR[0],  p_SHORTBREAK[0]  ,
				p_LUNCHBREAK[0]   ,   p_MAXEARLYDROPOFFFACTOR[0]  , p_OTHEREARLYPICKFACTOR[0]  ,  p_OTHERLATEPICKFACTOR[0] ,   p_name    ,
				p_timetonextstop , p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
				OffLoaded   , p_trip_type ,    p_prev_perf_time ,   p_prev_stop_num , p_latency   ,  s_trip_appt_time ,  p_grp_cnt_amb ,
				p_grp_cnt_wc,  ignorepu[0],  IGNORE_DEPOTS_CUTOFF[0], time_zone, timezone2,starttime1,p_cs_occ,p_bs_occ,last_cs_occ,last_bs_occ,pDisposition);

		//  if(DEBUG == 1) gse << "after recalc " << endl;

		//  //  if(DEBUG == 1) gse << "2. I am here " << std::get<4>(varHolder) << endl;

		p_eta = std::get<0>(varHolder);
		p_wc_occ=std::get<1>(varHolder);
		p_amb_occ=std::get<2>(varHolder);
		p_esc=std::get<3>(varHolder);
		p_timetonextstop=std::get<4>(varHolder);
		p_disttonextstop=std::get<5>(varHolder);
		p_earlystoptime=std::get<6>(varHolder);
		p_latestoptime=std::get<7>(varHolder);
		tot_miles=std::get<8>(varHolder);
		tot_driv_time=std::get<9>(varHolder);
		p_etd=std::get<10>(varHolder);
		OffLoaded=std::get<11>(varHolder);
		p_perf_time = std::get<12>(varHolder);
		p_cs_occ = std::get<13>(varHolder);
		p_bs_occ = std::get<14>(varHolder);

		if(!secondpassinsertedtrip){
			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) - p_perf_time);



			if (p_stop_num != 1 && p_stop_num != (int)to_number(MAXSTOPNUM[0])) {
				if (timetraveled == 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)

					AGRPCOUNTER = AGRPCOUNTER + 1;
				else{
					if (AGRPCOUNTER > 0  && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)
					{
						APRVGRPCOUNTER = AGRPCOUNTER + 1;
					}
					AGRPCOUNTER = 0;
				}


				if(p_disability.find("WC",0) == string::npos && p_disability.find("SC",0) == string::npos && p_disability.find("XLT",0) == string::npos){


					if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0){
						//  if(DEBUG == 1) gse << "We are editing perf time " <<endl;
						p_perf_time = p_perf_time / AGRPCOUNTER;
					}


					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

						p_perf_time = p_perf_time / APRVGRPCOUNTER;
						APRVGRPCOUNTER = 0;
					}
				}
				else{

					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


						if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / AGRPCOUNTER;
						}

						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / APRVGRPCOUNTER;
							APRVGRPCOUNTER = 0;
						}
					}
				}

			}


			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) + p_perf_time);
		}

		bool changedeta = true;

		if(itms_to_minutes (ampm2fullhrs (p_eta)) != eta)
			changedeta = true;




		if(p_stop_type  == "P"){
			string tripidforwait = schd_tab[local_s_tab[i]][3];
			int DW = getDWByStop (tripidforwait, p_stop_type ,itms_to_minutes (ampm2fullhrs (p_eta)) , itms_to_minutes (ampm2fullhrs (p_etd))  ,(int)to_number(starttime1), p_perf_time);
			int PW = getPWByStop (tripidforwait,  p_stop_type  ,itms_to_minutes (ampm2fullhrs (p_eta))    , (int)to_number(starttime1));
			strcpy(schd_tab[local_s_tab[i]][DWWAIT], to_string(DW).c_str());
			strcpy(schd_tab[local_s_tab[i]][PWWAIT], to_string(PW).c_str());
		}
		else{

			int eta = itms_to_minutes (ampm2fullhrs (p_eta));
			int etd = (int)to_number(schd_tab[local_s_tab[i-1]][30]);
			int TT = (int)to_number(schd_tab[local_s_tab[i-1]][CALCULATEDTIME]);
			string tripidforwait = schd_tab[local_s_tab[i]][3];
			int DW = eta - etd + TT;
			int PW = getPWByStop (tripidforwait,  schd_tab[local_s_tab[i]][7],eta, (int)to_number(endtime1));
			strcpy(schd_tab[local_s_tab[i]][DWWAIT],to_string(DW).c_str());
			strcpy(schd_tab[local_s_tab[i]][PWWAIT],to_string(PW).c_str());
		}

		////  if(DEBUG == 1) gse << "copying " << endl;
		//   if(DEBUG == 1) gse << "ETa 2" << p_eta << " " << p_etd << endl;

		////  if(DEBUG == 1) gse << "2. I am here " << schd_tab[local_s_tab[0]][0] << endl;

		strcpy(schd_tab[local_s_tab[i]][4], to_string(itms_to_minutes (ampm2fullhrs ( p_promised_time))).c_str());
		strcpy( schd_tab[local_s_tab[i]][22] ,est_traveltime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][23],arrivetime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][24] ,departtime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][25] ,to_string(p_perf_time).c_str());
		strcpy( schd_tab[local_s_tab[i]][26] ,starttime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][27] ,endtime1.c_str()) ;
		if(i > 0){
			strcpy(  schd_tab[local_s_tab[i-1]][28] ,to_string(timetraveled).c_str()) ;
			strcpy(  schd_tab[local_s_tab[i-1]][CALCULATEDTIME] ,to_string(p_timetonextstop).c_str()) ;
		}


		strcpy(  schd_tab[local_s_tab[i]][29] ,to_string(itms_to_minutes (ampm2fullhrs (p_eta))).c_str());
		strcpy(  schd_tab[local_s_tab[i]][30] ,to_string(itms_to_minutes (ampm2fullhrs (p_etd))).c_str());
		//strcpy(  schd_tab[local_s_tab[i]][DIRTYBIT] ,("Y")) ;
		//temproute[i][6] = to_string(disttrav);
		strcpy( schd_tab[local_s_tab[i]][31] ,  to_string(p_amb_occ).c_str());
		strcpy( schd_tab[local_s_tab[i]][32] ,to_string(p_wc_occ).c_str());
		strcpy((schd_tab[local_s_tab[i]][CS_OCC]), to_string(p_cs_occ).c_str());
		strcpy((schd_tab[local_s_tab[i]][BS_OCC]), to_string(p_bs_occ).c_str());

		if(i+1!=counter){
			strcpy( schd_tab[local_s_tab[i]][38], schd_tab[local_s_tab[i+1]][10]);
			strcpy( schd_tab[local_s_tab[i]][39], schd_tab[local_s_tab[i+1]][37]);
		}
		else{
			strcpy( schd_tab[local_s_tab[i]][38], schd_tab[local_s_tab[i]][10]);
			strcpy( schd_tab[local_s_tab[i]][39], schd_tab[local_s_tab[i]][37]);
		}

		prev_eta1 = schd_tab[local_s_tab[i]][29];
		prev_eta = (int)to_number(prev_eta1);
		prev_eta1 = itms_minutes_to_ampm(prev_eta);

		int t = i;
		string timezone3;
		if (p_stop_num != 1) {
			if (!isSameLocation(local_s_tab[t],local_s_tab[t-1]))
				timezone3 = "#"; // not the same lat/long
				else
					timezone3 = "*";


			tripid = schd_tab[local_s_tab[t-1]][3];
			if(timezone3 == "*" && strcmp(schd_tab[local_s_tab[t-1]][7], schd_tab[local_s_tab[t]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[local_s_tab[t-1]][41], schd_tab[local_s_tab[t]][41])==0){
				strcpy(  schd_tab[local_s_tab[t]][29] ,schd_tab[local_s_tab[t-1]][29]);
				int l = t;
				tripid = schd_tab[local_s_tab[l]][3];
				while(isSameLocation(local_s_tab[l],local_s_tab[l-1]) && strcmp(schd_tab[local_s_tab[l-1]][7], schd_tab[local_s_tab[l]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[local_s_tab[l-1]][41], schd_tab[local_s_tab[l]][41])==0){
					strcpy(  schd_tab[local_s_tab[l-1]][30] , schd_tab[local_s_tab[l]][30]);
					l--;
					tripid = schd_tab[local_s_tab[l]][3];
					if(l == 0)
						break;
				}
			}
		}

		if(secondpassinsertedtrip){  if(DEBUG == 1) gse << "REDOING" << endl; i--;continue;}

		prev_perftime1 = schd_tab[local_s_tab[i]][25];
		prev_p_perf_time = (int)to_number(prev_perftime1);


		prev_etd1 = schd_tab[local_s_tab[i]][30];
		prev_etd = (int)to_number(prev_etd1);
		prev_etd1 = itms_minutes_to_ampm(prev_etd);
		//temp = temproute[i][12];
		prev_amb_occ1 =  schd_tab[local_s_tab[i]][31];
		prev_wc_occ1 =  schd_tab[local_s_tab[i]][32];
		//amb_cap1 = getNextToken(&(temp), ",");
		//wc_cap1 =getNextToken(&(temp), ",");
		last_dep_time=prev_etd;
		last_arr_time=prev_eta;
		string prev_cs_occ = schd_tab[local_s_tab[i]][CS_OCC];
		string prev_bs_occ = schd_tab[local_s_tab[i]][BS_OCC];
		last_cs_occ=to_number(prev_cs_occ);
		last_bs_occ=to_number(prev_bs_occ);
		last_amb_occ=(int)to_number(prev_amb_occ1);
		last_wc_occ=(int)to_number(prev_wc_occ1);
		p_prev_perf_time = prev_p_perf_time;
		p_prev_stop_num = (int)to_number(schd_tab[local_s_tab[i]][2]);
		p_prev_promised_time = p_promised_time;










		////  if(DEBUG == 1) gse << " local " << schd_tab[local_s_tab[SEGSTART]][0] << " " << local_s_tab[SEGSTART] << endl;
		//  strcpy( schd_tab[local_s_tab[i]][0] ,schd_tab[local_s_tab[SEGSTART]][0]);



		////  if(DEBUG == 1) gse << "3. I am here " << schd_tab[local_s_tab[0]][0] << endl;


		// temp = temproute[i][4];


		/*if(temproute[i][20] == "0" && temproute[i-1][20] != "0"){
                            // //  if(DEBUG == 1) gse << "Stop Num " << temproute[i-1][2] << endl;
                        temp = temproute[i-1][12];
                        getNextToken(&(temp), ",");
                        getNextToken(&(temp), ",");
                        amb_cap1 = getNextToken(&(temp), ",");
                        wc_cap1 =getNextToken(&(temp), ",");
                        }*/

		//// //  if(DEBUG == 1) gse << last_dep_time << endl;


		////  if(DEBUG == 1) gse << "4. I am here " << schd_tab[local_s_tab[0]][0] << endl;

		/*  if(local_s_tab[i] == puid && p_stop_num == aStp){
        indafter1 = schd_tab[local_s_tab[i-1]][20];
        pueta = p_eta;
         puetd = p_etd;
        disttravpu = to_string(disttrav);
        pustp = to_string(p_stop_num);
        latlon1 = schd_tab[local_s_tab[i-1]][10];
         latlon1= latlon1 +","+ schd_tab[local_s_tab[i-1]][37];
        latlon2 = schd_tab[local_s_tab[i+1]][10];
         latlon2= latlon2+ ","+ schd_tab[local_s_tab[i+1]][37];
        //indicies = temproute[i][20];
       // // //  if(DEBUG == 1) gse << indicies << endl;
    }





    if(local_s_tab[i] == puid && p_stop_num > aStp){
       doeta = p_eta;
       disttravdo = to_string(disttrav);
       dostp = to_string(p_stop_num);
       doetd = p_etd;
       if(p_stop_num == aStp +1)
        indafter2 = indafter1;
      else
        indafter2 = schd_tab[local_s_tab[i-1]][20];
         latlon3 = schd_tab[local_s_tab[i-1]][10];
         latlon3= latlon3 +","+ schd_tab[local_s_tab[i-1]][37];
         latlon4 = schd_tab[local_s_tab[i+1]][10];
         latlon4= latlon4+ ","+ schd_tab[local_s_tab[i+1]][37];


         actualTT = (itms_to_minutes (ampm2fullhrs (doeta)) - itms_to_minutes (ampm2fullhrs (puetd))); //flipped eta/etd
         // //  if(DEBUG == 1) gse << "Actual travel time " << actualTT << endl;
    }
		 */


		//actual travel time

		////  if(DEBUG == 1) gse << "travel time" << endl;

		string tripid2 = schd_tab[local_s_tab[i]][3];
		string p_trip_type2 = schd_tab[local_s_tab[i]][8];

		if(strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && (tripid2.substr(0,1) == "T" || tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN"){

			int pickupid = (int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX]);
			int doeta1 = (int)to_number(schd_tab[local_s_tab[i]][30])-(int)to_number(schd_tab[local_s_tab[i]][25]);
			int puetd1 = (int)to_number(schd_tab[pickupid][30]);
			int stopafter;

			for(int t = 0; t < counter; t++){
				if(local_s_tab[t] == pickupid){
					stopafter = local_s_tab[t+1];
					break;
				}
			}

			string pReturn_trip1 = schd_tab[pickupid][18];
			string pDisability1 = schd_tab[pickupid][12];
			string p_trip_type11 = schd_tab[pickupid][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type11);
			int aLatepickup;

			if (pReturn_trip1 == "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}


			if((int)to_number(schd_tab[stopafter][30]) - (int)to_number(schd_tab[stopafter][25])  >= (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]) + (int)to_number(schd_tab[pickupid][CALCULATEDTIME])){

				puetd1 = (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]);

				if(DEBUG == 1) gse << "Changing puetd to " << puetd1 << " " << (int)to_number(schd_tab[stopafter][30]) << "  " <<  (int)to_number(schd_tab[stopafter][25]) <<  endl;
			}


			actualTT = doeta1 - puetd1; //flipped eta/etd
			// //  if(DEBUG == 1) gse << "Actual travel time of " << schd_tab[local_s_tab[i]][3] << " " << actualTT << " out of " << aAllowedTT << endl;
		}

		else
			actualTT = 0;



		////  if(DEBUG == 1) gse << "violations " << endl;


		if(DEBUG == 1) gse << p_stop_num << " \t " << p_promised_time << " \t " << p_eta << " \t " << p_etd << " \t "  << setprecision(2) << prev_distance <<  "  \t" << p_timetonextstop << " \t " << p_stop_type << "\t wc occ" << p_wc_occ << " \t amb occ" << p_amb_occ << "\t" << p_cs_occ << "\t" << p_bs_occ << "\t" << p_esc << " " << arrivetime1 << " " << departtime1 << " " << p_trip_type << " " << schd_tab[local_s_tab[i]][20] << " " << " " <<schd_tab[local_s_tab[i]][42]<< " " << schd_tab[local_s_tab[i]][41] << " " << local_s_tab[i] << " end time: " << endtime1 << " trip id " <<schd_tab[local_s_tab[i]][3] << " " << schd_tab[local_s_tab[i]][10] << " " << schd_tab[local_s_tab[i]][37]  <<  endl;
		p_eta = itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][29]));
		p_etd = itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][30]));




		int aLatepickup;

		if (p_return_trip == "Y"){
			aLatepickup = p_OTHERLATEPICKFACTOR1;
		}
		else{
			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
		}

		if(p_stop_num == (int)to_number(MAXSTOPNUM[0])){
			endtime1 = to_string((int)itms_to_minutes(ampm2fullhrs(p_promised_time))); // to make sure segments do not go beyond the end'
			////  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
		}

		bool preassigntripchange = true;
		if(strcmp(schd_tab[local_s_tab[i]][LATEDEVIATION],"")!=0 || strcmp(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION],"")!=0){
			preassigntripchange = false;
			if ((p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {
				if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup)//p_DIALRIDELATEPICKFACTOR )
				{
					int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(starttime1) + aLatepickup);
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}

				}
			}


			if ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000")
			{
				if((((itms_to_minutes(ampm2fullhrs(p_eta))) >  (int)to_number(endtime1)) && prom_time != 0))
				{

					int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(endtime1));
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}


				}
			}

			if((actualTT > aAllowedTT  && actualTT > 0)){
				if((actualTT - aAllowedTT) > (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION])){
					preassigntripchange = true;
				}
			}
		}


		if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
			//  if(DEBUG == 1) gse << "Travel time violation " <<  p_stop_num << " >= " <<  aStp << " " << actualTT << " > " << aAllowedTT<< endl;
			if(!preassigntripchange)
			{
				//  if(DEBUG == 1) gse << "Preassigntripchange not true"  << schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION] << " " <<  endl;
			}

		}
		////  if(DEBUG == 1) gse << "starting " << endl;

		string disabilitydb = schd_tab[local_s_tab[i]][12];

		if(/*strcmp(USEREVERSECALC[0],"Y")!=0*/true){
			/*** 1. Check for WC violations ***/
			if (schd_tab[local_s_tab[i]][0] == "" && disabilitydb.find("WC") != string::npos && p_stop_num >= aStp) {
				if (to_number(wc_cap1) == 0) {
					if(!finished){
						oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
						//strcpy( schd_tab[local_s_tab[i]][0] ,"");

						a_route = schd_tab[local_s_tab[SEGSTART]][0];
						//  //  if(DEBUG == 1) gse << "1 " << a_route << endl;


						for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
							if(s_tab[s_tab_idx][m]==0){break;}
							strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
							strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
						}
						//  if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid<< endl;
						for(int k = 1;k < MAXSTOPS; k++){
							if(s_tab[s_tab_idx][k]==0){break;}
							//  if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << endl;
						}
						for(int d = 0; d < counter; d++){
							strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
							strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
							strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());
							if(strcmp(schd_tab[local_s_tab[d]][0],"")==0)//if it's an unassigned trip, reset eta.
								strcpy(schd_tab[local_s_tab[d]][29],"");


						}
						for(int d = 0; d < counter; d++){
							strcpy(schd_tab[local_s_tab[d]][GRPIDX],"");

						}



						//  if(DEBUG == 1) gse <<  oResult << "\n\n";

						recalcons_tabREOPTIMIZE(a_route);
						break;
					}
					finished = true;


				}
			} //general

			/*** 2. Check for Capacity Violation ***/
			if ((p_wc_occ> (int)to_number(wc_cap1) && p_stop_num >= aStp) || (p_amb_occ > (int)to_number(amb_cap1) && p_stop_num >= aStp)
					|| (p_cs_occ > cs_cap  &&  p_stop_num >=aStp) || (p_bs_occ > bs_cap  &&  p_stop_num >=aStp)) {
				//// //  if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;
				if(!finished){
					// string route = schd_tab[local_s_tab[1]][0];
					oResult = "NOK Capacity Violation when assigning Trip on Segment " + p_td_segmentid + " with capacities wc, amb " + wc_cap1 + " " + amb_cap1;
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");

					a_route = schd_tab[local_s_tab[SEGSTART]][0];
					////  if(DEBUG == 1) gse << "2 " << a_route << endl;

					for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
						if(s_tab[s_tab_idx][m]==0){break;}
						strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
						strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
					}
					//  if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
					for(int k = 1;k < MAXSTOPS; k++){
						if(s_tab[s_tab_idx][k]==0){break;}

						//  if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << endl;
					}
					for(int d = 0; d < counter; d++){
						strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
						strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
						strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());
						if(strcmp(schd_tab[local_s_tab[d]][0],"")==0)//if it's an unassigned trip, reset eta.
							strcpy(schd_tab[local_s_tab[d]][29],"");


					}

					for(int d = 0; d < counter; d++){
						strcpy(schd_tab[local_s_tab[d]][GRPIDX],"");

					}
					//  if(DEBUG == 1) gse <<  oResult <<"\n\n";
					recalcons_tabREOPTIMIZE(a_route);
					break;
				}
				finished = true;


			} //per stop number



			if(changedeta){

				/***3. Pickup Window violation *****/
				if ( preassigntripchange && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" && (p_stop_num >= aStp )) {

					if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup+ floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
					{
						//// //  if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
						// oDropETA = " Dropoff ETA:  ;" ;
						if(!finished){
							string tripid = schd_tab[local_s_tab[i]][3];
							oResult = "Impact: " + tripid +" Pickup is outside the window with start time: " + itms_minutes_to_ampm((int)to_number(starttime1)); //oResult
							//  strcpy( schd_tab[local_s_tab[i]][0] ,"");

							a_route = schd_tab[local_s_tab[SEGSTART]][0];
							// //  if(DEBUG == 1) gse << "3 " << a_route << endl;

							if(strcmp(USEREVERSECALC[0],"Y")!=0){
								for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
									if(s_tab[s_tab_idx][m]==0){break;}
									strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
								}
								for(int d = 0; d < counter; d++){
									strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
									strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
									strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());
									if(strcmp(schd_tab[local_s_tab[d]][0],"")==0)//if it's an unassigned trip, reset eta.
										strcpy(schd_tab[local_s_tab[d]][29],"");


								}

								for(int d = 0; d < counter; d++){
									strcpy(schd_tab[local_s_tab[d]][GRPIDX],"");

								}
								//  if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
								for(int k = 1;k < MAXSTOPS; k++){
									if(s_tab[s_tab_idx][k]==0){break;}
									//  if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << endl;
								}

								//  if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
								recalcons_tabREOPTIMIZE(a_route);
								break;
							}
							else{
								ontime = false;
							}
						}
						finished = true;

					}

				}



				/*** 4. Check if someone is late for Appointment ***/
				/** Added condition if the appt. time is not null and return_trip = Y **/
				if ( preassigntripchange && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"&& (p_stop_num >= aStp)))
				{



					if((((itms_to_minutes(ampm2fullhrs(p_eta))) > /*12 +*/ (int)to_number(endtime1)+ floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0))
					{
						// //  if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;
						if(!finished){
							string tripid = schd_tab[local_s_tab[i]][3];
							oResult = "Impact: " +  tripid + " will be late: " + to_string((int)itms_to_minutes(ampm2fullhrs(p_eta)) - (int)to_number(endtime1) ) +
									" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
							// strcpy( schd_tab[local_s_tab[i]][0] ,"");
							//  if(DEBUG == 1) gse <<   oResult <<"\n\n";

							a_route = schd_tab[local_s_tab[SEGSTART]][0];
							////  if(DEBUG == 1) gse << "4 " << a_route << endl;
							if(strcmp(USEREVERSECALC[0],"Y")!=0){
								for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
									if(s_tab[s_tab_idx][m]==0){break;}
									strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
								}
								for(int d = 0; d < counter; d++){
									strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
									strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
									strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());
									if(strcmp(schd_tab[local_s_tab[d]][0],"")==0)//if it's an unassigned trip, reset eta.
										strcpy(schd_tab[local_s_tab[d]][29],"");


								}

								for(int d = 0; d < counter; d++){
									strcpy(schd_tab[local_s_tab[d]][GRPIDX],"");

								}
								//  if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
								for(int k = 1;k < MAXSTOPS; k++){
									if(s_tab[s_tab_idx][k]==0){break;}
									//  if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << endl;
								}

								//  if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
								recalcons_tabREOPTIMIZE(a_route);
								break;
							}
							else{
								ontime = false;
							}
						}
						finished = true;
					}
				}


				/**** 5. Check if it exceeds the Travel Time ****/
				if((preassigntripchange && actualTT > aAllowedTT+ floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && actualTT > 0) && p_stop_num >= aStp){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {
					if(!finished){
						string tripid = schd_tab[local_s_tab[i]][3];
						oResult = "Impact: Travel Time Violation on Trip: " + tripid  + " TT: " + to_string(actualTT) + " Allowed: " + to_string(aAllowedTT) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
						// strcpy( schd_tab[local_s_tab[i]][0] ,"");

						//  if(DEBUG == 1) gse << oResult;

						a_route = schd_tab[local_s_tab[SEGSTART]][0];
						if(strcmp(USEREVERSECALC[0],"Y")!=0){
							for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
								if(s_tab[s_tab_idx][m]==0){break;}
								strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
								strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
							}
							for(int d = 0; d < counter; d++){
								strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
								strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
								strcpy(schd_tab[local_s_tab[d]][CALCULATEDTIME],origCalculatedTime[d].c_str());
								if(strcmp(schd_tab[local_s_tab[d]][0],"")==0)//if it's an unassigned trip, reset eta.
									strcpy(schd_tab[local_s_tab[d]][29],"");


							}

							for(int d = 0; d < counter; d++){
								strcpy(schd_tab[local_s_tab[d]][GRPIDX],"");

							}
							//  if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
							for(int k = 1;k < MAXSTOPS; k++){
								if(s_tab[s_tab_idx][k]==0){break;}
								//  if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << endl;
							}

							//  if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
							recalcons_tabREOPTIMIZE(a_route);
							break;
						}
						else{
							ontime = false;
						}



					}
					finished = true;

				}

			}

		}


		if(p_stop_num==(int)to_number(MAXSTOPNUM[0])){




			bool usereversefail = true;
			if(strcmp(USEREVERSECALC[0],"Y")==0){
				usereversefail = reversecalclocal(counter, local_s_tab, ontime);
			}
			if(!usereversefail){
				if(DEBUG == 1) gse << "There was a violation so reverse calcing!" << endl;
				//UPDATE_REVERSE_CALCULATE_BATCH(counter, local_s_tab);
				for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
					if(s_tab[s_tab_idx][m]==0){break;}
					strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
					strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
				}
				//  if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid<< endl;
				for(int k = 1;k < MAXSTOPS; k++){
					if(s_tab[s_tab_idx][k]==0){break;}
					//  if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << endl;
				}
				for(int d = 0; d < counter; d++){
					strcpy(schd_tab[local_s_tab[d]][29],origetaholder[d].c_str());
					strcpy(schd_tab[local_s_tab[d]][30],origetdholder[d].c_str());
					if(strcmp(schd_tab[local_s_tab[d]][0],"")==0)//if it's an unassigned trip, reset eta.
						strcpy(schd_tab[local_s_tab[d]][29],"");


				}
				for(int d = 0; d < counter; d++){
					strcpy(schd_tab[local_s_tab[d]][GRPIDX],"");

				}

				//  if(DEBUG == 1) gse <<  oResult << "\n\n";

				a_route = schd_tab[local_s_tab[SEGSTART]][0];

				UPDATE_REVERSE_CALCULATE_BATCH(counter,local_s_tab,a_route);

				return false;
			}




			if(oResult == "") //  if(DEBUG == 1) gse << "The indicies are inserted after " << indafter1 << " and " << indafter2   <<endl;
				for(int k = 0; k < counter; k++){
					strcpy( schd_tab[local_s_tab[k]][0] ,schd_tab[local_s_tab[0]][0]);
					//strcpy( schd_tab[local_s_tab[k]][6] , distholder[k].c_str());
				}

			for(int d = 0; d < counter; d++){
				strcpy(schd_tab[local_s_tab[d]][GRPIDX],"");

			}

			if(oResult == ""){
				oResult = "Impact: On time";
				routeFound = true;
			}




		}


	}


	return routeFound;
}




void optimizeRoutes(){


	int groupcnt = 0;

	int grpmarker = 0;

	/*for (int i = 0; i < MAXTRIPIDX; i++)
    { //find the largest group marker currently in the trip table
        if (strcmp(schd_tab[i][GRPIDX], "") != 0)
        {
            string tempstring = schd_tab[i][GRPIDX];
            int tempgrpmarker = (int)to_number(getNextToken(&tempstring, "^"));
            if (grpmarker <= tempgrpmarker)
            {
                grpmarker = tempgrpmarker;
            }
        }
    }
    grpmarker++;
      if(DEBUG == 1) gse << "The beginning grp " << grpmarker << endl;*/


	double distances[MAXSTOPS];
	double pickupdistance = 0.0;
	int local_s_tab[MAXSTOPS];
	int reordered_local_s_tab[MAXSTOPS];
	int grouptriparrtot[MAXSTOPS];

	int fullRoute[MAXSTOPS];
	int fullRoutecnt = 0;
	int pickupindicies[MAXSTOPS];
	int pickupindex = 0;
	int dropoffindicies[MAXSTOPS];
	int dropoffindex = 0;
	bool notsameclustertime = false;
	bool interruptedgroup = false;
	bool grpfound = false;
	bool finalgrpfound = false;
	int tempfullroute[MAXSTOPS];
	int pickupafter;
	int dropoffbefore;
	int tempfullroutecnt = 0;

	for(int m = 0; m < MAXSEGMENTS; m++){
		fullRoutecnt = 0;
		grpfound = false;
		finalgrpfound = false;

		//  if(DEBUG == 1) gse << "Starting with 1 " << s_tab[m][0] << endl;

		//  if(DEBUG == 1) gse << "optimizing S" << s_tab[m][0] << endl;
		if(s_tab[m][0]==0){
			break;
		}

		//  if(DEBUG == 1) gse << "Starting with 2 " << s_tab[m][0] << endl;
		tempfullroutecnt = 0;
		for(int k = 1; k < MAXSTOPS; k++){
			tempfullroute[k-1] = 0;
		}

		for(int k = 1; k < MAXSTOPS; k++){
			if(s_tab[m][k]==0){
				break;
			}
			tempfullroute[k-1] = s_tab[m][k];
			tempfullroutecnt++;
		}

		for(int k = 1; k < MAXSTOPS; k++){






			if(s_tab[m][k]==0){
				break;
			}

			//  if(DEBUG == 1) gse << "The route " << schd_tab[s_tab[m][k]][0] << " " << k << " "  << fullRoutecnt <<endl;

			if((strcmp(schd_tab[s_tab[m][k]][7],"D") == 0 && strcmp(schd_tab[s_tab[m][k+1]][7],"D") == 0 // if the after is the same Dropoff
					&& strcmp(schd_tab[s_tab[m][k+1]][2],MAXSTOPNUM[0]) != 0) || //or
					(strcmp(schd_tab[s_tab[m][k]][7],"D") == 0 && strcmp(schd_tab[s_tab[m][k-1]][7],"D") == 0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0]) != 0)){ // the stop before is the same Dropoff

				notsameclustertime = false;
				interruptedgroup = false;
				for(int o = 0; o < groupcnt;o++){
					pickupindicies[o] = 0;
					dropoffindicies[o] = 0;
				}
				groupcnt = 0;

				if(DEBUG == 1) gse << "Found possible group " << endl;






				while(strcmp(schd_tab[s_tab[m][k]][7],"D") == 0 && strcmp(schd_tab[s_tab[m][k]][2],MAXSTOPNUM[0]) != 0){ //&& strcmp(schd_tab[s_tab[m][k+1]][7],"D") == 0)
					//|| (strcmp(schd_tab[s_tab[m][k]][7],"D") == 0 && strcmp(schd_tab[s_tab[m][k-1]][7],"D") == 0)){

					//   if(DEBUG == 1) gse << "k is " << k << " " <<  endl;
					/*
                                            if(strcmp(schd_tab[s_tab[m][k+1]][7],"D") == 0  && //if there's another trip in the group
                                                strcmp(schd_tab[(int)to_number(schd_tab[s_tab[m][k+1]][PICKUPIDX])][7],"P")==0
                                                != (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k+1]][PICKUPIDX])][2]) - 5){
                                                groupcnt = 0;
                                                interruptedgroup = true;
                                                  if(DEBUG == 1) gse << schd_tab[s_tab[m][k]][2] << " " << schd_tab[s_tab[m][k+1]][2] << endl;
                                                  if(DEBUG == 1) gse << " interuppted " << (int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX])][2]) << " = " <<(int)to_number(schd_tab[(int)to_number(schd_tab[s_tab[m][k+1]][PICKUPIDX])][2]) << " | " << endl;
                                                break;
                                            }*/
					//else{

					//   if(DEBUG == 1) gse << "Examining " << schd_tab[s_tab[m][k]][3] << endl;

					pickupindicies[groupcnt] = (int)to_number(schd_tab[s_tab[m][k]][PICKUPIDX]);
					dropoffindicies[groupcnt] = s_tab[m][k];
					fullRoute[fullRoutecnt] = dropoffindicies[groupcnt];
					groupcnt++;
					fullRoutecnt++;

					k++;



				}


				bool fini = false;
				for(int i = 0; i < MAXSTOPS; i++){

					int index3 = s_tab[m][i];

					for(int o = 0; o < groupcnt;o++){

						if (pickupindicies[o] == index3){
							pickupafter = s_tab[m][i-1];
							fini = true;
							break;
						}
					}
					if(fini)
						break;
				}
				dropoffbefore = s_tab[m][k];



				if(groupcnt > 0){k--;}





				double stopnum[MAXSTOPS];


				for(int o = 0; o < groupcnt-1;o++){


					if(strcmp(schd_tab[pickupindicies[o]][42] , schd_tab[pickupindicies[o+1]][42])!=0
							|| strcmp(schd_tab[pickupindicies[o]][41] , schd_tab[pickupindicies[o+1]][41])!=0
							|| strcmp(schd_tab[dropoffindicies[o]][42] , schd_tab[dropoffindicies[o+1]][42])!=0
							|| strcmp(schd_tab[dropoffindicies[o]][41] , schd_tab[dropoffindicies[o+1]][41])!=0
							|| strcmp(schd_tab[pickupindicies[o]][42] , schd_tab[dropoffindicies[o]][42])!=0
							||strcmp(schd_tab[pickupindicies[o]][41] , schd_tab[dropoffindicies[o]][41])!=0  ){

						notsameclustertime = true;

					}
				}




				for(int o = 0; o < groupcnt;o++){
					stopnum[o] = to_number(schd_tab[pickupindicies[o]][2]);

				}


				bubbleSort_twoarray(stopnum,pickupindicies,groupcnt);

				for(int o = 0; o < groupcnt;o++){

					local_s_tab[o]  = pickupindicies[o];
				}

				for(int o = 0; o < groupcnt;o++){
					stopnum[o] = to_number(schd_tab[dropoffindicies[o]][2]);
				}
				bubbleSort_twoarray(stopnum,dropoffindicies,groupcnt);

				for(int o = 0; o < groupcnt;o++){

					local_s_tab[groupcnt+o]  = dropoffindicies[o];
				}

				int largestpromtime = 0;
				int smalleststarttime = 1440;
				bool isreturntripsmallest = false;
				bool isreturntriplargest = false;
				int aLatepickup;
				int aEarlypickup;
				int largestidx = 0;
				int smallestidx = 0;

				int stoptoinsertafter;
				int index3;

				for(int q = 0; q < MAXSTOPS; q++){
					index3 = s_tab[m][q];
					if(index3 == pickupindicies[0]){
						index3 = s_tab[m][q-1];
						stoptoinsertafter = index3;
						break;
					}
				}



				for(int o = 0; o < groupcnt;o++){

					if (largestpromtime < (int)to_number(schd_tab[pickupindicies[o]][4])){
						largestpromtime = (int)to_number(schd_tab[pickupindicies[o]][4]);
						if(strcmp(schd_tab[pickupindicies[o]][18],"Y")==0){
							isreturntriplargest = true;
							largestidx = pickupindicies[o];
						}
						else{
							isreturntriplargest = false;
							largestidx = pickupindicies[o];
						}
					}

					if (smalleststarttime > (int)to_number(schd_tab[pickupindicies[o]][26]) && (int)to_number(schd_tab[pickupindicies[o]][26]) != 0 ){
						smalleststarttime = (int)to_number(schd_tab[pickupindicies[o]][26]);
						if(strcmp(schd_tab[pickupindicies[o]][18],"Y")==0){
							isreturntripsmallest = true;
							smallestidx = pickupindicies[o];
						}
						else{
							isreturntripsmallest = false;
							smallestidx = pickupindicies[o];
						}
					}

				}

				int p_WHEELLOAD1;
				int p_AMBLOAD1;
				int p_MAXEARLYDROPOFFFACTOR1;
				int p_DIALRIDEEARLYPICKFACTOR1;
				int p_DIALRIDELATEPICKFACTOR1;
				int p_OTHEREARLYPICKFACTOR1;
				int p_OTHERLATEPICKFACTOR1;
				string IGNOREPUTIMES1;
				int p_SHORTBREAK1;
				int p_LUNCHBREAK1;
				int p_PROXIMITYFACTOR1;
				int a_mediumshortdistance1;
				int a_mediumlongdistance1;
				int a_shorttriptime1;
				int a_longtriptime1;
				int a_mediumtriptime1;
				int a_extra_loadtime1;
				string ZONE_DESCR1;
				string IGNORE_DEPOTS_CUTOFF1;



				string p_disability = schd_tab[largestidx][12];
				string p_trip_type = schd_tab[largestidx][8];

				if(p_disability.find("OT",0)!= string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp("OT", ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}


				}
				else if( p_disability.find("OT",0)== string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}
				}
				if (isreturntriplargest){
					aEarlypickup = p_OTHEREARLYPICKFACTOR1;             /* C[006] */
				}
				else{
					aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */

				}

				p_disability = schd_tab[smallestidx][12];
				p_trip_type = schd_tab[smallestidx][8];

				if(p_disability.find("OT",0)!= string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp("OT", ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}


				}
				else if( p_disability.find("OT",0)== string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}
				}

				if (isreturntripsmallest){
					aLatepickup = p_OTHERLATEPICKFACTOR1;
				}
				else{
					aLatepickup = p_DIALRIDELATEPICKFACTOR1;
				}

				bool leavePickupAlone = false;

				if(largestpromtime - aEarlypickup >= smalleststarttime + aLatepickup){
					if(DEBUG == 1) gse << "Reoptimizing the group might cause late trips pick up " << largestpromtime << " - " << aEarlypickup << " >= " << smalleststarttime << " + " << aLatepickup << endl;
					leavePickupAlone = true;
				}









				int smallestendtime = 1440;

				for(int o = 0; o < groupcnt;o++){

					if (largestpromtime < (int)to_number(schd_tab[dropoffindicies[o]][4])){
						largestpromtime = (int)to_number(schd_tab[dropoffindicies[o]][4]);
						if(strcmp(schd_tab[dropoffindicies[o]][18],"Y")==0){
							isreturntriplargest = true;
							largestidx = dropoffindicies[o];
						}
						else{
							isreturntriplargest = false;
							largestidx = dropoffindicies[o];
						}
					}

					if (smallestendtime > (int)to_number(schd_tab[dropoffindicies[o]][27]) && (int)to_number(schd_tab[dropoffindicies[o]][27]) != 0 ){
						smallestendtime = (int)to_number(schd_tab[dropoffindicies[o]][27]);
						if(strcmp(schd_tab[dropoffindicies[o]][18],"Y")==0){
							isreturntripsmallest = true;
							smallestidx = dropoffindicies[o];
						}
						else{
							isreturntripsmallest = false;
							smallestidx = dropoffindicies[o];
						}
					}

				}




				p_disability = schd_tab[largestidx][12];
				p_trip_type = schd_tab[largestidx][8];

				if(p_disability.find("OT",0)!= string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp("OT", ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}


				}
				else if( p_disability.find("OT",0)== string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}
				}

				int aEarlydropoff;
				if (isreturntriplargest){
					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
				}
				else{

					aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

				}

				p_disability = schd_tab[smallestidx][12];
				p_trip_type = schd_tab[smallestidx][8];

				if(p_disability.find("OT",0)!= string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp("OT", ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}


				}
				else if( p_disability.find("OT",0)== string::npos){
					for(int z = 0; z < MAXZONES; z++){
						if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
							p_WHEELLOAD1 =p_WHEELLOAD[z] ;
							p_AMBLOAD1 =p_AMBLOAD[z];
							p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
							p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
							p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
							p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
							p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
							IGNOREPUTIMES1 = ignorepu[z] ;
							p_SHORTBREAK1 = p_SHORTBREAK[z] ;
							p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
							p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
							a_mediumshortdistance1 = a_mediumshortdistance[z] ;
							a_mediumlongdistance1 = a_mediumlongdistance[z] ;
							a_shorttriptime1 = a_shorttriptime[z] ;
							a_longtriptime1 = a_longtriptime[z] ;
							a_mediumtriptime1 =  a_mediumtriptime[z] ;
							a_extra_loadtime1 = a_extra_loadtime[z];
							ZONE_DESCR1 =   ZONE_DESCR[z] ;
							IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
							break;
						}
						if(z+1 == MAXZONES){
							for(int b = 0; b < MAXZONES; b++){

								if(strcmp("ALL", ZONE_DESCR[b])==0){
									p_WHEELLOAD1 =p_WHEELLOAD[b] ;
									p_AMBLOAD1 = p_AMBLOAD[b];
									p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
									p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
									p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
									p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
									p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
									IGNOREPUTIMES1 = ignorepu[b] ;
									p_SHORTBREAK1 = p_SHORTBREAK[b] ;
									p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
									p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
									a_mediumshortdistance1 = a_mediumshortdistance[b] ;
									a_mediumlongdistance1 = a_mediumlongdistance[b] ;
									a_shorttriptime1 = a_shorttriptime[b] ;
									a_longtriptime1 = a_longtriptime[b] ;
									a_mediumtriptime1 =  a_mediumtriptime[b] ;
									a_extra_loadtime1 = a_extra_loadtime[b];
									ZONE_DESCR1 =   ZONE_DESCR[b] ;
									IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
									break;
								}
							}

						}
					}
				}

				bool leaveDropoffAlone = false;

				if(largestpromtime - aEarlydropoff >= smallestendtime){
					if(DEBUG == 1) gse << "Reoptimizing the group might cause late trips dropoff " << largestpromtime << " - " << aEarlydropoff << " >= " << smallestendtime  << endl;
					leaveDropoffAlone = true;
				}

				if(leaveDropoffAlone && leavePickupAlone){
					if(DEBUG == 1) gse << "Reoptimizing the group might cause late trips so we're skipping completely " << largestpromtime << " - " << aEarlydropoff << " >= " << smallestendtime  << endl;
					interruptedgroup = true;
				}





				for(int q = 0; q < groupcnt-1;q++){

					//  if(DEBUG == 1) gse << schd_tab[pickupindicies[q]][2] << endl;

					if((int)to_number(schd_tab[pickupindicies[q]][2]) + 5 != (int)to_number(schd_tab[pickupindicies[q+1]][2])){
						interruptedgroup = true;
						groupcnt = 0;
						if(DEBUG == 1) gse << "The pickups are not consecutive " << endl;
						break;
					}


				}


				if(!interruptedgroup){

					for(int q = 0; q < groupcnt-1;q++){

						//   if(DEBUG == 1) gse << schd_tab[dropoffindicies[q]][2] << endl;

						if((int)to_number(schd_tab[dropoffindicies[q]][2]) + 5 != (int)to_number(schd_tab[dropoffindicies[q+1]][2])){
							interruptedgroup = true;
							groupcnt = 0;
							if(DEBUG == 1) gse << "The dropoffs are not consecutive " << endl;
							break;
						}
					}

				}

				if(!interruptedgroup){
					if((int)to_number(schd_tab[pickupindicies[groupcnt-1]][2]) + 5 != (int)to_number(schd_tab[dropoffindicies[0]][2])){
						interruptedgroup = true;
						groupcnt = 0;
						if(DEBUG == 1) gse << "There is a trip in between pick ups and drop offs " << endl;
					}

				}

				if(!interruptedgroup){
					for(int q = 0; q < groupcnt;q++){
						string routetypebefore = schd_tab[pickupindicies[q]][8];
						if(routetypebefore == "BRK" || routetypebefore == "ADMIN" || routetypebefore == "LUNCH"){
							if(DEBUG == 1) gse << "There is a break/admin/lunch in the group so skipping reop" << endl;
							interruptedgroup = true;
							groupcnt = 0;
							break;

						}
					}
				}
				if(!interruptedgroup){
					for(int q = 0; q < groupcnt;q++){
						string routetypebefore = schd_tab[dropoffindicies[q]][8];
						if(routetypebefore == "BRK" || routetypebefore == "ADMIN" || routetypebefore == "LUNCH"){
							if(DEBUG == 1) gse << "There is a break/admin/lunch in the group so skipping reop" << endl;
							interruptedgroup = true;
							groupcnt = 0;
							break;

						}
					}
				}









				if(!interruptedgroup && groupcnt > 0){

					if(DEBUG == 1) gse << "The group cnt is " << groupcnt << " " << fullRoutecnt <<  endl;

					for(int o = 0; o < groupcnt;o++){
						for(int h = 0; h < fullRoutecnt; h++){
							if(fullRoute[h] == pickupindicies[o] ||fullRoute[h] == dropoffindicies[o] ){
								fullRoute[h] = 0;
								o = -1;
								break;
							}
						}

					}



					/*    if(DEBUG == 1) gse << "Before optimizing " << endl;

                        for(int d = 1; d < MAXSTOPS; d++){

                                        if(s_tab[m][d]==0){
                                            break;
                                        }

                              if(DEBUG == 1) gse << schd_tab[s_tab[m][d]][3] << endl;
                        }

					 */

					grpfound = true;




					int grouptriparrdo[MAXSTOPS];
					int grouptriparrpu[MAXSTOPS];

					int grouptriparrtotSameCluster[MAXSTOPS];
					int grouptriparr[MAXSTOPS];


					for(int j = 0; j < MAXSTOPS; j++){
						grouptriparrtot[j] = 0;
					}


					int stoptoinsertafter1;

					/*for(int j = 1; j < MAXSTOPS; j++){
                        if(to_number(schd_tab[s_tab[m][j+1]][2])==stopnum[0]){
                            stoptoinsertafter1 = s_tab[m][j];
                            break;
                        }
                    }*/

					stoptoinsertafter1 = pickupafter;


					groupcnt = groupcnt - 1;
					int r = 0;



					if(!notsameclustertime){

						if(DEBUG == 1) gse << "Same cluster " << endl;


						//  if(DEBUG == 1) gse << "The group cnt is 0 " << groupcnt << " " << fullRoutecnt <<  endl;
						int temp = 0;

						if((!leavePickupAlone && leaveDropoffAlone) || (!leavePickupAlone && !leaveDropoffAlone)){


							grouptriparrtotSameCluster[0] = pickupindicies[0];
							temp++;

							for(int o = 1; o < groupcnt+1;o++){ ////create one large tripidx of p and d for group trips
								grouptriparrtotSameCluster[o] = pickupindicies[o];
								temp++;
							}
							grouptriparrtotSameCluster[temp] = dropoffindicies[0];
							temp++;
							for(int o = temp; o < groupcnt*2+2;o++){ ////create one large tripidx of p and d for group trips
								grouptriparrtotSameCluster[o] = dropoffindicies[o-temp+1];
							}


							double distancebegin = 0.0;

							for(int i = 0; i < groupcnt+1; i++){

								if (strcmp(schd_tab[grouptriparrtotSameCluster[i]][7], "P") == 0)
									//{

									if (isSameLocation(grouptriparrtotSameCluster[i],stoptoinsertafter)){
										grouptriparrtot[r] = grouptriparrtotSameCluster[i];
										break;
									}
									else{

										if(distancebegin == 0.0){
											grouptriparrtot[r] = grouptriparrtotSameCluster[i];
											distancebegin = getCost(grouptriparrtotSameCluster[i], stoptoinsertafter);

										}
										else if(getCost(grouptriparrtotSameCluster[i], stoptoinsertafter) < distancebegin){
											grouptriparrtot[r] = grouptriparrtotSameCluster[i];
											distancebegin = getCost(grouptriparrtotSameCluster[i], stoptoinsertafter);

										}

									}
								//}
							}


							if(DEBUG == 1) gse << "The group cnt is 2 " << groupcnt << " " << fullRoutecnt <<  endl;
							r++;

						}
						else if(leavePickupAlone && !leaveDropoffAlone){

							grouptriparrtot[0] = pickupindicies[0];
							grouptriparrtotSameCluster[0]= pickupindicies[0];
							temp++;
							r++;
							for(int o = 1; o < groupcnt+1;o++){ ////create one large tripidx of p and d for group trips
								grouptriparrtot[r] = pickupindicies[o];
							grouptriparrtotSameCluster[r]= pickupindicies[o];
							r++;
							}
							int z = r;
							grouptriparrtotSameCluster[z] = dropoffindicies[0];
							z++;
							temp++;
							for(int o = 1; o < groupcnt+1;o++){ ////create one large tripidx of p and d for group trips
								grouptriparrtotSameCluster[z] = dropoffindicies[o];
								z++;
							}

						}










						if(DEBUG == 1) gse << "The group cnt is 1 " << groupcnt << " " << fullRoutecnt <<  endl;





						double distance = 0;
						int nextStop;
						int samelatlongcounter = 0;
						bool insertedsamedrop = false;

						while(r <= (groupcnt*2)+2){
							for(int i = 0; i < groupcnt*2+2; i++){
								for(int h = 0; h < r; h++){
									if(grouptriparrtot[h] == grouptriparrtotSameCluster[i]){//already in final order skip
										//  if(DEBUG == 1) gse << "Breaking already in cluster array " << schd_tab[grouptriparrtotSameCluster[i]][3] << " " << grouptriparrtotSameCluster[i]  << endl;
										break;
									}
									else if (h+1 == r){

										//   if(DEBUG == 1) gse << "in here 1" << endl;

										if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][7],"D")==0 && !leaveDropoffAlone){

											if(DEBUG == 1) gse << "Found D " << i << endl;


											for(int j = 0; j < r; j++){

												//    if(DEBUG == 1) gse << "j is " << j << endl;
												if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][3],schd_tab[grouptriparrtot[j]][3])==0  && strcmp(schd_tab[grouptriparrtot[j]][7], "P")==0){
													//pick up is already in order so we can continue

													//    if(DEBUG == 1) gse << "Found p" << endl;

													if (isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[r-1])){
														distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
														nextStop = grouptriparrtotSameCluster[i];
														insertedsamedrop = true;
														//  if(DEBUG == 1) gse << "Dropoff 1 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
													}


													else if(distance == 0 && !insertedsamedrop){
														nextStop = grouptriparrtotSameCluster[i];
														distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);

													}
													else if(distance >= getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1] ) && !insertedsamedrop){
														nextStop = grouptriparrtotSameCluster[i];
														distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
													}
												}



												if(isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[r-1])
														&& j+1 == r){

													if(DEBUG == 1) gse << "in here 1 " << r << endl;

													int f = r;
													int tempindexarray[MAXSTOPS];
													int tempindexarraycnt = 0;

													if(DEBUG == 1) gse << "in here 2 " << r << endl;

													while(f > 0 && isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[f-1])){
														tempindexarray[tempindexarraycnt] = grouptriparrtot[f-1];
														f--;
														tempindexarraycnt++;
													}


													if(DEBUG == 1) gse << "in here 3 " << r << endl;
													for(int y = 0; y < r; y++){
														if(strcmp(schd_tab[grouptriparrtotSameCluster[y]][3],schd_tab[grouptriparrtotSameCluster[i]][3])==0  && strcmp(schd_tab[grouptriparrtotSameCluster[y]][7], "P")==0 && !insertedsamedrop){
															grouptriparrtot[f] = grouptriparrtotSameCluster[y];
															f++;
															for(int d = tempindexarraycnt-1; d >= 0; d--){
																grouptriparrtot[f] = tempindexarray[d];
																f++;
																//r++;
															}
															r++;
															nextStop = grouptriparrtotSameCluster[i];
															distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
															//   if(DEBUG == 1) gse << " Had to reorder because we had a same drop lat long before a pickup. " << schd_tab[grouptriparrtotSameCluster[i]][3] << endl;
															insertedsamedrop = true;
															break;
														}
													}
												}
											}
										}
										else if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][7],"D")==0 && leaveDropoffAlone){
											if(DEBUG == 1) gse << "We're leaving the drop off in the same order " << endl;
											nextStop = grouptriparrtotSameCluster[i];
											break;
										}
										if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][7],"P")==0){ //it is a pick up so we can continue

											//   if(DEBUG == 1) gse << "in here 2 P" << endl;

											if(isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[r-1]) && !insertedsamedrop){
												distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
												nextStop = grouptriparrtotSameCluster[i];
												insertedsamedrop = true;
												//  if(DEBUG == 1) gse << "Dropoff 1 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
											}

											else if(distance == 0 && !insertedsamedrop){
												nextStop = grouptriparrtotSameCluster[i];
												distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);

											}
											else if(distance >= getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1] ) && !insertedsamedrop){
												nextStop = grouptriparrtotSameCluster[i];
												distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
											}

										}
									}
								}
							}
							grouptriparrtot[r] = nextStop;
							distance = 0;
							r++;
							insertedsamedrop = false;
						}

						//  if(DEBUG == 1) gse << "The group cnt is 3 " << groupcnt << " " << fullRoutecnt <<  endl;

					}

					else{

						if(DEBUG == 1) gse << "Centroid "  <<  endl;

						int temp[MAXSTOPS];

						double distpu = 0;
						double distdo = 0;
						std::vector<my_point> ring;
						my_point p;
						my_point p1;

						point_type centroid;
						polygon_type poly;


						if((!leavePickupAlone && leaveDropoffAlone) || (!leavePickupAlone && !leaveDropoffAlone)){

							temp[0] = pickupindicies[0];
							if(DEBUG == 1) gse << "Temp is " << schd_tab[pickupindicies[0]][3]<< endl;
							for(int i = 1; i < groupcnt+1;i++){
								temp[i] = pickupindicies[i];
								if(DEBUG == 1) gse << "Temp is " << schd_tab[pickupindicies[i]][3]<< endl;
							}
							grouptriparrdo[0]  = dropoffindicies[0];
							if(DEBUG == 1) gse << "do is " << schd_tab[dropoffindicies[0]][3]<< endl;
							for(int o = 1; o < groupcnt+1;o++){
								grouptriparrdo[o] = dropoffindicies[o];
								if(DEBUG == 1) gse << "do is " << schd_tab[ dropoffindicies[o]][3]<< endl;
							}



							for(int o = 0; o < groupcnt+1;o++){ ///get centroid of p and d area of group trips
								double lat = to_number(schd_tab[grouptriparrdo[o]][10]);
								double lon = to_number(schd_tab[grouptriparrdo[o]][37]);
								bg::assign_values(p, lon, lat);
								ring.push_back(p);
							}
							boost::geometry::correct(ring);

							boost::geometry::convert(ring, poly);
							boost::geometry::centroid(poly, centroid);


							for(int i = 0; i < groupcnt+1;i++){ //get inital pickup farthest from centroid of dropoff

								double lat = to_number(schd_tab[temp[i]][10]);
								double lon = to_number(schd_tab[temp[i]][37]);
								bg::assign_values(p, lon, lat);
								point_type p2;
								boost::geometry::convert(p, p2);
								//  if(DEBUG == 1) gse << "Distance " << schd_tab[temp[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
								if(distpu == 0 ){
									//  if(DEBUG == 1) gse << "Distance " << schd_tab[temp[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
									distpu = bg::distance(p2, centroid);
									grouptriparrtot[r] = temp[i];
								}
								if (isSameLocation(temp[i], stoptoinsertafter1)){
									distpu = bg::distance(p2, centroid);
									grouptriparrtot[r] = temp[i];
									break;
								}
								else if(distpu < bg::distance(p2, centroid)){
									//  if(DEBUG == 1) gse << "Distance " << schd_tab[temp[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
									distpu = bg::distance(p2, centroid);
									grouptriparrtot[r] = temp[i];
								}
							}

							if(DEBUG == 1) gse << "The initial pick up is " << schd_tab[grouptriparrtot[r]][3] << endl;

							r++;


						}
						else if(leavePickupAlone && !leaveDropoffAlone){
							if(DEBUG == 1) gse << "Leave pick up alone " << endl;
							grouptriparrtot[0] = pickupindicies[0];
							r++;
							for(int i = 1; i < groupcnt+1;i++){
								grouptriparrtot[r] = pickupindicies[i];
								r++;
							}

							grouptriparrdo[0]  = dropoffindicies[0];
							for(int o = 1; o < groupcnt+1;o++){
								grouptriparrdo[o] = dropoffindicies[o];
							}

						}




						//   if(DEBUG == 1) gse << "initial " << schd_tab[grouptriparrtot[r]][3] << endl;



						double ratio = 0;
						int pickup;

						bool insertedsamedrop = false;
						//bool newinsert = false;



						if(!leavePickupAlone){
							while(r < groupcnt+1){
								for(int i = 0; i < groupcnt+1;i++){
									//get pickup order
									//newinsert = false;

									for(int h = 0; h < r; h++){

										if(temp[i] == grouptriparrtot[h]){
											//newinsert = false;
											break;
										}
										else if(h+1 == r){
											//newinsert = true;
											double lat = to_number(schd_tab[temp[i]][10]);
											double lon = to_number(schd_tab[temp[i]][37]);
											bg::assign_values(p, lon, lat);
											double lat1 = to_number(schd_tab[grouptriparrtot[r-1]][10]);
											double lon1 = to_number(schd_tab[grouptriparrtot[r-1]][37]);
											bg::assign_values(p1, lon1, lat1);
											point_type p2;
											point_type p3;
											boost::geometry::convert(p, p2);
											boost::geometry::convert(p1, p3);

											//   if(DEBUG == 1) gse << "Pickup 1 " << schd_tab[grouptriparrtot[r-1]][3] << " " << schd_tab[temp[i]][3] << " " << bg::distance(p2, centroid)/ bg::distance(p2, p3) <<   endl;

											if(isSameLocation(temp[i],grouptriparrtot[r-1])){
												ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
												pickup = temp[i];
												insertedsamedrop = true;
												//   if(DEBUG == 1) gse << "Pickup 1 " << schd_tab[pickup][3] << " " << schd_tab[pickup][10] <<  " " << schd_tab[pickup][37] << " " << bg::distance(p2, centroid) << " " << bg::distance(p2, p3) <<  endl;
											}
											else if(ratio == 0 && !insertedsamedrop){
												ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
												pickup = temp[i];
												//   if(DEBUG == 1) gse << "Pickup 0 " << schd_tab[grouptriparrtot[r]][3] << " " << grouptriparrtot[r] <<  endl;

											}

											else if(ratio <= bg::distance(p2, centroid)/ bg::distance(p2, p3) && !insertedsamedrop ){
												ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
												pickup = temp[i];
												//   if(DEBUG == 1) gse << "Pickup 1 " << schd_tab[grouptriparrtot[r]][3] << " " << grouptriparrtot[r] <<  endl;
											}
										}
									}
								}
								ratio = 0;
								//if(newinsert){
								grouptriparrtot[r] = pickup;
								//  if(DEBUG == 1) gse << "pickup " << schd_tab[pickup][3] << endl;
								//   if(DEBUG == 1) gse << "R is : " <<  schd_tab[grouptriparrtot[r]][3] << " " << grouptriparrtot[r] <<  endl;
								r++;
								insertedsamedrop = false;
								//}
							}


						}

						ratio = 0;
						int dropoff;
						int f = r;
						int dropoffcentroid;
						distpu = 0;


						double lat = to_number(schd_tab[grouptriparrtot[f-1]][10]); //last pickup in array
						double lon = to_number(schd_tab[grouptriparrtot[f-1]][37]);
						bg::assign_values(centroid, lon, lat); //make that the centroid




						if(leaveDropoffAlone){

							if(DEBUG == 1) gse << "We're leaving the drop off alone" << endl;

							for(int o = 0; o < groupcnt+1;o++){
								grouptriparrtot[f] = grouptriparrdo[o];
								f++;
							}

						}
						else{
							for(int i = 0; i < groupcnt+1;i++){ //get inital dropoff closest to last pickup in group
								double lat = to_number(schd_tab[grouptriparrdo[i]][10]);
								double lon = to_number(schd_tab[grouptriparrdo[i]][37]);
								bg::assign_values(p, lon, lat);
								point_type p2;
								boost::geometry::convert(p, p2);
								//  if(DEBUG == 1) gse << "Tripids " << schd_tab[grouptriparrdo[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
								if(distpu == 0 ){
									distpu = bg::distance(p2, centroid);
									grouptriparrtot[f] = grouptriparrdo[i];
								}
								else if(isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i])){
									grouptriparrtot[f] = grouptriparrdo[i];
									break;
								}
								else if(distpu > bg::distance(p2, centroid)){
									distpu = bg::distance(p2, centroid);
									grouptriparrtot[f] = grouptriparrdo[i];
								}
							}

							distpu = 0;
							dropoffcentroid = 0;

							for(int i = 0; i < groupcnt+1;i++){ //get dropoff farthest to last pickup in group
								double lat = to_number(schd_tab[grouptriparrdo[i]][10]);
								double lon = to_number(schd_tab[grouptriparrdo[i]][37]);
								bg::assign_values(p, lon, lat);
								point_type p2;
								boost::geometry::convert(p, p2);
								//   if(DEBUG == 1) gse << "Tripids dropoff " << schd_tab[grouptriparrdo[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
								if(distpu == 0 && !isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i])){
									distpu = bg::distance(p2, centroid);
									dropoffcentroid = grouptriparrdo[i];
								}
								else if(distpu < bg::distance(p2, centroid) && !isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i])){
									distpu = bg::distance(p2, centroid);
									dropoffcentroid = grouptriparrdo[i];
								}
							}

							if(dropoffcentroid == 0){
								for(int i = 0; i < groupcnt+1;i++){
									if(isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i]) && grouptriparrtot[f-1] != grouptriparrdo[i]){
										dropoffcentroid = grouptriparrdo[i];
										break;
									}
								}
							}

							lat = to_number(schd_tab[dropoffcentroid][10]); //last pickup in array
							lon = to_number(schd_tab[dropoffcentroid][37]);
							bg::assign_values(centroid, lon, lat); //make that the centroid

							//  if(DEBUG == 1) gse << " Drop off centroid " << schd_tab[dropoffcentroid][3] << endl;

							//   if(DEBUG == 1) gse << "initial dropoff " << schd_tab[grouptriparrtot[f]][3] << endl;
							f++;

							//      if(DEBUG == 1) gse << "The group cnt is 3 " << groupcnt << " " << fullRoutecnt <<  endl;

							while(f < (groupcnt*2) + 2){
								for(int i = 0; i < groupcnt+1;i++){ //get dropoff order
									//newinsert = false;

									for(int h = r; h < f; h++){

										if(grouptriparrdo[i] == grouptriparrtot[h]){
											//newinsert =  false;
											break;
										}
										else if(h+1 == f){
											//newinsert = true;
											double lat = to_number(schd_tab[grouptriparrdo[i]][10]);
											double lon = to_number(schd_tab[grouptriparrdo[i]][37]);
											bg::assign_values(p, lon, lat);
											double lat1 = to_number(schd_tab[grouptriparrtot[f-1]][10]);
											double lon1 = to_number(schd_tab[grouptriparrtot[f-1]][37]);
											bg::assign_values(p1, lon1, lat1);
											point_type p2;
											point_type p3;
											boost::geometry::convert(p, p2);
											boost::geometry::convert(p1, p3);

											//   if(DEBUG == 1) gse << "ratio " << schd_tab[grouptriparrdo[i]][3] << " "  << bg::distance(p2, centroid)/ bg::distance(p2, p3) << endl;

											if(isSameLocation(grouptriparrdo[i],grouptriparrtot[f-1])){
												ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
												dropoff = grouptriparrdo[i];
												insertedsamedrop = true;
												//  if(DEBUG == 1) gse << "Dropoff 1 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
											}
											else if(ratio == 0 && !insertedsamedrop){
												ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
												dropoff = grouptriparrdo[i];
												//   if(DEBUG == 1) gse << "Dropoff 0 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;

											}

											else if(ratio <= bg::distance(p2, centroid)/ bg::distance(p2, p3) && !insertedsamedrop){
												ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
												dropoff = grouptriparrdo[i];
											}




										}
									}

								}
								ratio = 0;
								//if(newinsert){
								grouptriparrtot[f] = dropoff;
								//   if(DEBUG == 1) gse << "drop off " <<  schd_tab[dropoff][3] << endl;
								//  if(DEBUG == 1) gse << "F is : " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
								f++;
								insertedsamedrop = false;
								//}
							}

						}



					}

					if(DEBUG == 1) gse << " The layout for the group trip now is: " << groupcnt <<  endl; //new order layout

					for(int i = 0; i < (groupcnt*2)+2;i++){
						if(DEBUG == 1) gse << schd_tab[grouptriparrtot[i]][3] << " " << schd_tab[grouptriparrtot[i]][7] << endl;
					}


					//   if(DEBUG == 1) gse << "Checking the route " << endl;
					/*
                    for(int i = 0; i < fullRoutecnt; i++){
                       //   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
                        if (fullRoute[i] == 0){
                            for(int h = 0; h < (groupcnt*2)+2; h++){
                                //strcpy(schd_tab[grouptriparrtot[h]][GRPIDX], (to_string(grpmarker) + "^" + to_string(h)).c_str());
                                fullRoute[i] = grouptriparrtot[h];
                              //   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
                                i++;
                        }



                    }
                   //    if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
            }
					 */

					if(grpfound){

						if(DEBUG == 1) gse << "Seeing if we can swap anything around by timeslot" << endl;

						for (int i = 0; i < (groupcnt * 2) + 2; i++){

							if(i < 0)
								i = 0;

							if(i+1 != (groupcnt * 2) + 2 && strcmp(schd_tab[grouptriparrtot[i]][42],schd_tab[grouptriparrtot[i+1]][42])==0 &&
									(int)to_number(schd_tab[grouptriparrtot[i]][4]) >  (int)to_number(schd_tab[grouptriparrtot[i+1]][4])){
								if(DEBUG == 1) gse << "We should swap these trips based off timeslot and cluster " << schd_tab[grouptriparrtot[i]][3]  << " " << schd_tab[grouptriparrtot[i+1]][3] << endl;
								int temp = grouptriparrtot[i];
								grouptriparrtot[i] = grouptriparrtot[i+1];
								grouptriparrtot[i+1] = temp;
								i = -1;
							}


						}


						for (int i = 0; i < (groupcnt * 2) + 2; i++){
							distances[i] = 0;
						}
						for (int i = 0; i < (groupcnt * 2) + 2; i++)
						{
							if (i + 1 < (groupcnt * 2) + 2)
							{ /////////if lat/long different add .75 otherwise keep 0 -- SJ
								if (isSameLocation(local_s_tab[i], local_s_tab[i + 1]))
								{
									distances[i + 1] = 0;
									if(DEBUG == 1) gse << "SAME " <<  schd_tab[local_s_tab[i]][3] << " " << distances[i + 1] << endl;
								}
								else
								{
									distances[i + 1] = getTime(local_s_tab[i], local_s_tab[i + 1]);
									if(DEBUG == 1) gse << schd_tab[local_s_tab[i]][3] << " " << distances[i + 1] << endl;
								}
							}
							else
								distances[i + 1] = 0;
						}

						int templocaltab[MAXSTOPS];

						templocaltab[0] = pickupafter;

						if (isSameLocation(pickupafter, local_s_tab[0]))
						{
							distances[0] = 0;
						}
						else
						{
							distances[0] = getTime(local_s_tab[0], pickupafter);
						}


						for (int i = 0; i < (groupcnt * 2) + 2; i++)
						{
							templocaltab[i + 1] = local_s_tab[i];
						}



						if (isSameLocation(dropoffbefore, local_s_tab[(groupcnt * 2) + 1]))
						{
							distances[(groupcnt * 2) + 2] = 0;
						}
						else
						{
							distances[(groupcnt * 2) + 2] = getTime(local_s_tab[(groupcnt * 2) + 1], dropoffbefore);
						}

						templocaltab[(groupcnt * 2) + 3] = dropoffbefore;

						if(DEBUG == 1) gse << "First grouping " << endl;
						bool grpokay = checkgrp((groupcnt*2)+4, distances, templocaltab);
						if(grpokay){

							for (int i = 0; i < (groupcnt * 2) + 2; i++){
								distances[i] = 0;
							}
							for (int i = 0; i < (groupcnt * 2) + 2; i++)
							{
								if (i + 1 < (groupcnt * 2) + 2)
								{
									if (isSameLocation(grouptriparrtot[i], grouptriparrtot[i + 1]))
									{
										distances[i + 1] = 0;
										if(DEBUG == 1) gse << "SAME " <<  schd_tab[grouptriparrtot[i]][3] << " " << distances[i + 1] << endl;
									}
									else
									{

										distances[i + 1] = getTime(grouptriparrtot[i], grouptriparrtot[i + 1]);
										if(DEBUG == 1) gse << schd_tab[grouptriparrtot[i]][3] << " " << distances[i + 1] << endl;
									}
								}
								else
									distances[i + 1] = 0;
							}

							templocaltab[0] = pickupafter;

							if (isSameLocation(pickupafter, grouptriparrtot[0]))
							{
								distances[0] = 0;
							}
							else
							{
								distances[0] = getTime(grouptriparrtot[0], pickupafter);
							}

							if (isSameLocation(dropoffbefore, grouptriparrtot[(groupcnt * 2) + 1]))
							{
								distances[(groupcnt * 2) + 2] = 0;
							}
							else
							{
								distances[(groupcnt * 2) + 2] = getTime(grouptriparrtot[(groupcnt * 2) + 1], dropoffbefore);
							}


							for (int i = 0; i < (groupcnt * 2) + 2; i++)
							{
								templocaltab[i + 1] = grouptriparrtot[i];
							}

							templocaltab[(groupcnt * 2) + 3] = dropoffbefore;

							if(DEBUG == 1) gse << "second grouping " << endl;
							grpokay = checkgrp((groupcnt*2)+4, distances, templocaltab);
							if(grpokay){

								for(int i = 0; i < fullRoutecnt; i++){
									//   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
									if (fullRoute[i] == 0){
										for(int h = 0; h < (groupcnt*2)+2; h++){
											//strcpy(schd_tab[grouptriparrtot[h]][GRPIDX], (to_string(grpmarker) + "^" + to_string(h)).c_str());
											fullRoute[i] = grouptriparrtot[h];
											//   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
											i++;
										}



									}

								}
								finalgrpfound = true;
							}
							else{

								for(int i = 0; i < fullRoutecnt; i++){
									//   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
									if (fullRoute[i] == 0){
										for(int h = 0; h < (groupcnt*2)+2; h++){
											//strcpy(schd_tab[grouptriparrtot[h]][GRPIDX], (to_string(grpmarker) + "^" + to_string(h)).c_str());
											fullRoute[i] = local_s_tab[h];
											//   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
											i++;
										}



									}

								}
								//grpfound = false;
							}
						}
						else{
							for(int i = 0; i < fullRoutecnt; i++){
								//   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
								if (fullRoute[i] == 0){
									for(int h = 0; h < (groupcnt*2)+2; h++){
										//strcpy(schd_tab[grouptriparrtot[h]][GRPIDX], (to_string(grpmarker) + "^" + to_string(h)).c_str());
										fullRoute[i] = grouptriparrtot[h];
										//   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
										i++;
									}

								}

							}
							finalgrpfound = true;
						}

					}


					/*   if(DEBUG == 1) gse << "After optimizing " << endl;

                        for(int i = 0; i < fullRoutecnt; i++){

                      if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
                        }*/

					//grpmarker++;
					//  if(DEBUG == 1) gse << "The grpmarker is " << grpmarker << endl;

					//    if(DEBUG == 1) gse << "full route " << endl;
					/*for(int i = 0; i < fullRoutecnt; i++){
                   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;

            }*/

				}




			}

			else{
				if(DEBUG == 1) gse << "Pick up or not group " << schd_tab[s_tab[m][k]][7] << " " << schd_tab[s_tab[m][k]][3] << " " << endl;
				fullRoute[fullRoutecnt]= s_tab[m][k];
				fullRoutecnt++;
			}


		}


		bool checkedforvio = false;


		if(finalgrpfound){

			double distances1[MAXTRIPIDX];
			double times1[MAXTRIPIDX];


			string clientdate = "INREOPTIMIZEFORCLIENT";

			strcpy(shared_process_tab[WRITINGFB][0], "REOPTIMIZEROUTES");
			int q = 0;
			int waitingforosrm = 0;


			for (int g = 0; g < fullRoutecnt; g++)
			{
				string lat1;
				string lon1;
				string lat2;
				string lon2;

				if(strcmp(schd_tab[fullRoute[g]][2],MAXSTOPNUM[0])!=0){
					lat1 = schd_tab[fullRoute[g]][10];
					lon1 = schd_tab[fullRoute[g]][37];
					lat2 = schd_tab[fullRoute[g + 1]][10];
					lon2 = schd_tab[fullRoute[g + 1]][37];
				}
				else{
					lat1 = schd_tab[fullRoute[g]][10];
					lon1 = schd_tab[fullRoute[g]][37];
					lat2 = schd_tab[fullRoute[g]][10];
					lon2 = schd_tab[fullRoute[g]][37];
				}
				string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;
				for (int d = 0; d < MAXREQUESTS; d++)
				{

					if (requestIsEmpty(d))
					{
						usleep(10);
						if (requestIsEmpty(d))
						{
							q = d;
							break;
						}
					}
					if (d + 1 == MAXREQUESTS)
						d = -1;
				}
				//  if(DEBUG == 1) gse << "q is " << q << endl;

				string function = "SlackDist";

				time_t t = time(NULL);
				struct tm tm = *localtime(&t);
				char timebuffer[100];
				sprintf(timebuffer, "%s", asctime(&tm));
				string localtimestr = timebuffer;
				localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());
				//  if(DEBUG == 1) gse << "Writing to arrays " << endl;
				updateRequest(q, clientdate, "NUM");
				updateRequest(q, function, "FUNC");
				updateRequest(q, localtimestr, "TIMESTAMP");
				updateRequest(q, to_string(g), "ID");
				updateRequest(q, osrm, "LATLONG");
				updateRequest(q, to_string(fullRoute[g]), "TRIPIDX");
				//  if(DEBUG == 1) gse << "Done " << endl;
				waitingforosrm++;
				//}
			}
			strcpy(shared_process_tab[WRITINGFB][0], "READY");

			//  if(DEBUG == 1) gse << "waiting for osrm " << endl;
			int g = 0;
			int datafromosrm = 0;
			int f = 0;
			while (true)
			{

				for (int q = 0; q < MAXREQUESTS; q++)
				{
					if (fetchRequest(q, "DISTANCE") != "" &&  fetchRequest(q, "TIME") != "" &&fetchRequest(q, "ID") == to_string(g) && fetchRequest(q, "NUM") == clientdate && fetchRequest(q, "FUNC") == "SlackDist")
					{
						string dist = fetchRequest(q, "DISTANCE");
						string time1 = fetchRequest(q, "TIME");
						distances1[(int)to_number(fetchRequest(q, "TRIPIDX"))] = to_number(dist);
						times1[(int)to_number(fetchRequest(q, "TRIPIDX"))] = to_number(time1);
						//  if(DEBUG == 1) gse << fetchRequest(q, "ID") << " " << schd_tab[(int)to_number(fetchRequest(q, "TRIPIDX"))][3] << " " << dist << " " << (int)to_number(fetchRequest(q, "ID")) << endl;
						clearRequest(q);
						while(!requestIsEmpty(q)){
						}
						f++;
						g++;
						datafromosrm++;
						//  if(DEBUG == 1) gse << "checking " << q << " " << fetchRequest(q, "TRIPIDX") << endl;
					}
				}

				if (datafromosrm == waitingforosrm)
					break;
			}



			//  if(DEBUG == 1) gse << "going to recalc on the reoptimized route " << endl;
			grpfound = insertandcalcrouteREOPTIMIZE(fullRoutecnt, distances1, times1, fullRoute);
			//  if(DEBUG == 1) gse << "Finished recalcing" << endl;
			checkedforvio = true;


		}











		if(!grpfound && checkedforvio){
			if(DEBUG == 1) gse << "There was a violation so we are putting back the original route " << schd_tab[fullRoute[0]][0] <<  " " << tempfullroutecnt << endl;
			for(int i = 0; i < tempfullroutecnt; i++){
				fullRoute[i] = tempfullroute[i];
			}

			fullRoutecnt = tempfullroutecnt;

			grpfound = true;




			for(int i = 0; i < fullRoutecnt; i++){
				int stopnum;
				int stopnum2;


				if(fullRoute[i]==0)
					break;
				//int o = i+1;

				string tripid = schd_tab[fullRoute[i]][3];

				if (strcmp(schd_tab[fullRoute[i]][2], "1") == 0)
				{
					//    if(DEBUG == 1) gse << "Setting stop nums " << endl;
					stopnum = 1;
					stopnum2 = 5;
				}
				else if ( tripid.substr(0,1)== "S" and i > 0)
				{
					stopnum = (int)to_number(MAXSTOPNUM[0]);
					stopnum2 = (int)to_number(MAXSTOPNUM[0]);
				}
				else
				{
					stopnum = stopnum + 5;
					stopnum2 = stopnum + 5;
				}

				string route = schd_tab[fullRoute[i]][0];
				int g = (int)to_number(schd_tab[fullRoute[i]][20]);

				strcpy(schd_tab[g][2], to_string(stopnum).c_str());
				strcpy(schd_tab[g][19], to_string(stopnum2).c_str());

				// if(DEBUG == 1) gse << schd_tab[g][2] << " " <<  schd_tab[g][0] << " " << schd_tab[g][3] << endl;

				if (stopnum == 1)
				{
					stopnum = 0;
					//stopnum2 = 5;
				}
			}










		}







		/*
               if(DEBUG == 1) gse << "Pre optimize " << endl;

                    for(int k = 1; k < MAXSTOPS; k++){
                        if(s_tab[m][k] == 0)
                            break;
                                      if(DEBUG == 1) gse << schd_tab[s_tab[m][k]][3] << " " << schd_tab[s_tab[m][k]][2] << " " << schd_tab[s_tab[m][k]][7] <<  endl;
                            }

              if(DEBUG == 1) gse << "Post optimize " << endl;

             for(int k = 0; k < fullRoutecnt; k++){
                                      if(DEBUG == 1) gse << schd_tab[fullRoute[k]][3] << " " << schd_tab[fullRoute[k]][2] << " " << schd_tab[fullRoute[k]][7] << endl;
                            }


		 */
		if(finalgrpfound){

			for(int k = 1; k < MAXSTOPS; k++){
				if(s_tab[m][k]== 0){break;}
				s_tab[m][k]=0;
			}


			if(DEBUG == 1) gse << "optimized " << schd_tab[fullRoute[0]][0] << endl;

			int d = 1;
			int stopnum;
			int stopnum2;

			strcpy(process_tab[LOADDB][0],("RUNNING"));
			strcpy(process_tab[ACCESS][0],("RUNNING"));



			for(int i = 0; i < fullRoutecnt; i++){


				if(strcmp(schd_tab[fullRoute[i]][2],"1") ==0) {
					stopnum = 1;
					stopnum2 = 5;
				}
				else if(strcmp(schd_tab[fullRoute[i]][2],MAXSTOPNUM[0]) ==0){
					stopnum = (int)to_number(MAXSTOPNUM[0]);
					stopnum2 = (int)to_number(MAXSTOPNUM[0]);
				}
				else  {
					stopnum  = stopnum+5;
					stopnum2  = stopnum+5;
				}


				strcpy((schd_tab_unprocess)[d][0] ,schd_tab[fullRoute[i]][0]);
				strcpy((schd_tab_unprocess[d][1]) , schd_tab[fullRoute[i]][1]);
				strcpy((schd_tab_unprocess[d][2]) , to_string(stopnum).c_str());
				strcpy((schd_tab_unprocess[d][3]) , schd_tab[fullRoute[i]][3]);
				strcpy((schd_tab_unprocess[d][4]) , schd_tab[fullRoute[i]][4]);
				strcpy((schd_tab_unprocess[d][5]) , schd_tab[fullRoute[i]][5]);
				strcpy((schd_tab_unprocess[d][6]) , schd_tab[fullRoute[i]][6]);
				strcpy((schd_tab_unprocess[d][7]) , schd_tab[fullRoute[i]][7]);
				strcpy((schd_tab_unprocess[d][8]) , schd_tab[fullRoute[i]][8]);
				strcpy((schd_tab_unprocess[d][9]) , schd_tab[fullRoute[i]][9]);
				strcpy((schd_tab_unprocess[d][10]) , schd_tab[fullRoute[i]][10]);
				strcpy((schd_tab_unprocess[d][11]) , schd_tab[fullRoute[i]][11]);
				strcpy((schd_tab_unprocess[d][12]) , schd_tab[fullRoute[i]][12]);
				strcpy((schd_tab_unprocess[d][13]) , schd_tab[fullRoute[i]][13]);
				strcpy((schd_tab_unprocess[d][14]) , schd_tab[fullRoute[i]][14]);
				strcpy((schd_tab_unprocess[d][15]) , schd_tab[fullRoute[i]][15]);
				strcpy((schd_tab_unprocess[d][16]) , schd_tab[fullRoute[i]][16]);
				strcpy((schd_tab_unprocess[d][17]) , schd_tab[fullRoute[i]][17]);
				strcpy((schd_tab_unprocess[d][18]) , schd_tab[fullRoute[i]][18]);
				strcpy((schd_tab_unprocess[d][19]) ,  to_string(stopnum2).c_str());
				strcpy((schd_tab_unprocess[d][20]) , schd_tab[fullRoute[i]][20]);
				strcpy((schd_tab_unprocess[d][21]) , schd_tab[fullRoute[i]][21]);
				strcpy((schd_tab_unprocess[d][22]) , schd_tab[fullRoute[i]][22]);
				strcpy((schd_tab_unprocess[d][23]) , schd_tab[fullRoute[i]][23]);
				strcpy((schd_tab_unprocess[d][24]) , schd_tab[fullRoute[i]][24]);
				strcpy((schd_tab_unprocess[d][25]) , schd_tab[fullRoute[i]][25]);
				strcpy((schd_tab_unprocess[d][26]) , schd_tab[fullRoute[i]][26]);
				strcpy((schd_tab_unprocess[d][27]) , schd_tab[fullRoute[i]][27]);
				strcpy((schd_tab_unprocess[d][28]) , schd_tab[fullRoute[i]][28]);
				strcpy((schd_tab_unprocess[d][29]) , schd_tab[fullRoute[i]][29]);
				strcpy((schd_tab_unprocess[d][30]) , schd_tab[fullRoute[i]][30]);
				strcpy((schd_tab_unprocess[d][31]) , schd_tab[fullRoute[i]][31]);
				strcpy((schd_tab_unprocess[d][32]) , schd_tab[fullRoute[i]][32]);
				strcpy((schd_tab_unprocess[d][33]) , schd_tab[fullRoute[i]][33]);
				strcpy((schd_tab_unprocess[d][34]) , schd_tab[fullRoute[i]][34]);
				strcpy((schd_tab_unprocess[d][35]) , schd_tab[fullRoute[i]][35]);
				strcpy((schd_tab_unprocess[d][36]) , schd_tab[fullRoute[i]][36]);
				strcpy((schd_tab_unprocess[d][37]) , schd_tab[fullRoute[i]][37]);
				if(stopnum != (int)to_number(MAXSTOPNUM[0])){
					strcpy((schd_tab_unprocess[d][38]) , schd_tab[fullRoute[i+1]][10]);
					strcpy((schd_tab_unprocess[d][39]) , schd_tab[fullRoute[i+1]][37]);
				}
				else{
					strcpy((schd_tab_unprocess[d][38]) , "");
					strcpy((schd_tab_unprocess[d][39]) , "");
				}
				strcpy((schd_tab_unprocess[d][41]) , schd_tab[fullRoute[i]][41]);
				strcpy((schd_tab_unprocess[d][42]) , schd_tab[fullRoute[i]][42]);
				strcpy((schd_tab_unprocess[d][43]) , "Y"); //get distances from osrm
				strcpy((schd_tab_unprocess[d][44]) ,"N"); //Don't want to build the tree, only want to build the cluster table
				strcpy((schd_tab_unprocess[d][DIRTYBIT]) , ("N"));
				strcpy((schd_tab_unprocess[d][SUGG_RES_NUM]) , schd_tab[fullRoute[i]][SUGG_RES_NUM]);
				strcpy((schd_tab_unprocess[d][OPER_ID]) , schd_tab[fullRoute[i]][OPER_ID]);
				strcpy((schd_tab_unprocess[d][EARLIEST_ARR]) , schd_tab[fullRoute[i]][EARLIEST_ARR]);
				strcpy((schd_tab_unprocess[d][LATEST_DEP]) , schd_tab[fullRoute[i]][LATEST_DEP]);
				strcpy((schd_tab_unprocess[d][ORIG_PROMTIME]) , schd_tab[fullRoute[i]][ORIG_PROMTIME]);
				strcpy((schd_tab_unprocess[d][SITE]) , schd_tab[fullRoute[i]][SITE]);
				strcpy((schd_tab_unprocess[d][NEIGHBORS]) , schd_tab[fullRoute[i]][NEIGHBORS]);
				//strcpy((schd_tab_unprocess[d][INCLUDESEG]) , schd_tab[fullRoute[i]][INCLUDESEG]);
				//strcpy((schd_tab_unprocess[d][EXCLUDESEG]) , schd_tab[fullRoute[i]][EXCLUDESEG]);
				strcpy((schd_tab_unprocess[d][SKIPTS]) , schd_tab[fullRoute[i]][SKIPTS]);
				strcpy((schd_tab_unprocess[d][GRPIDX]) , schd_tab[fullRoute[i]][GRPIDX]);
				strcpy((schd_tab_unprocess[d][PICKUPIDX]) , schd_tab[fullRoute[i]][PICKUPIDX]);
				strcpy((schd_tab_unprocess[d][DWWAIT]) , schd_tab[fullRoute[i]][DWWAIT]);
				strcpy((schd_tab_unprocess[d][PWWAIT]) , schd_tab[fullRoute[i]][PWWAIT]);
				strcpy((schd_tab_unprocess[d][CS_OCC]) , schd_tab[fullRoute[i]][CS_OCC]);
				strcpy((schd_tab_unprocess[d][BS_OCC]) , schd_tab[fullRoute[i]][BS_OCC]);
				strcpy((schd_tab_unprocess[d][DISPOSITION]) , schd_tab[fullRoute[i]][DISPOSITION]);
				strcpy((schd_tab_unprocess[d][LATEDEVIATION]) , schd_tab[fullRoute[i]][LATEDEVIATION]);
				strcpy((schd_tab_unprocess[d][TRVLTIMEDEVIATION]) , schd_tab[fullRoute[i]][TRVLTIMEDEVIATION]);
				strcpy((schd_tab_unprocess[d][SEGMENTTYPE]), schd_tab[fullRoute[i]][SEGMENTTYPE]);
				d++;

				if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] <<  " " <<  stopnum << " " << schd_tab[fullRoute[i]][7] <<  endl;
				if(stopnum == 1) {
					stopnum = 0;
				}
			}

			//   if(DEBUG == 1) gse << "optimized 0" << endl;
			strcpy(process_tab[LOADDB][0],("DONE"));
			//strcpy(process_tab[DBWRITE][0],("RUNNING"));//comment after

			if(d == 1){
				strcpy(process_tab[ACCESS][0],("READY"));
			}
			while(true){
				if( strcmp(process_tab[ACCESS][0],("READY"))==0 /*&&  strcmp(process_tab[DBWRITE][0],("DONE"))==0*/) //comment
					break;
			}


			//  if(DEBUG == 1) gse << "optimized 1" << endl;
			for(int z = 0; z < fullRoutecnt; z++){
				fullRoute[z] = 0;
			}

			//  if(DEBUG == 1) gse << "optimized 2" << endl;

			fullRoutecnt = 0;
			grpfound = false;

		}

		//  if(DEBUG == 1) gse << "optimized 3" << endl;

	}

	//  if(DEBUG == 1) gse << "done optimize" << endl;

}



bool optimizeRoutesSingleSLACK(int (*local_s_tab)[MAXSTOPS]){


	int groupcnt = 0;


	int grpmarker = 0;

	double pickupdistance = 0.0;
	int unordered_s_tab[MAXSTOPS];
	double distances[MAXSTOPS];

	int fullRoute[MAXSTOPS];
	int fullRoutecnt = 0;
	int pickupindicies[MAXSTOPS];
	int pickupindex = 0;
	int dropoffindicies[MAXSTOPS];
	int dropoffindex = 0;
	bool notsameclustertime = false;
	bool interruptedgroup = false;
	bool grpfound = false;
	int index;
	int index2;
	int fullrouteholder = 0;
	int grouptriparrtot[MAXSTOPS];
	int pickupafter;
	int dropoffbefore;


	for(int k = 0; k < MAXSTOPS; k++){

		if((*local_s_tab)[k] == 0 )
			break;

		index = (*local_s_tab)[k];



		index2 = (*local_s_tab)[k+1];



		if(grpfound){
			if(DEBUG == 1) gse << "grpfound " << endl;
		}

		if(DEBUG == 1) gse << "The stop " << schd_tab[index][3] << " " << schd_tab[index][7] << " " << schd_tab[index][2] << " " <<  schd_tab[index2][3] << " " << schd_tab[index2][7] << " " << schd_tab[index2][2] <<  endl;

		if(index==0){
			break;
		}

		//  if(DEBUG == 1) gse << "The route " << schd_tab[index][0] << " " << k << " "  << fullRoutecnt <<endl;

		if( !grpfound &&  ((strcmp(schd_tab[index][7],"D") == 0 && strcmp(schd_tab[index2][7],"D") == 0 // if the after is the same Dropoff
				&& strcmp(schd_tab[index2][2],MAXSTOPNUM[0]) != 0) || //or
				(strcmp(schd_tab[index][7],"D") == 0 && strcmp(schd_tab[(*local_s_tab)[k-1]][7],"D") == 0 && strcmp(schd_tab[index][2],MAXSTOPNUM[0]) != 0))){ // the stop before is the same Dropoff

			notsameclustertime = false;
			interruptedgroup = false;
			for(int o = 0; o < groupcnt;o++){
				pickupindicies[o] = 0;
				dropoffindicies[o] = 0;
			}
			groupcnt = 0;
			fullrouteholder = k;

			if(DEBUG == 1) gse << "Found possible group " << schd_tab[index][3] << " " << schd_tab[index2][3] << endl;









			while(strcmp(schd_tab[index][7],"D") == 0 && strcmp(schd_tab[index][2],MAXSTOPNUM[0]) != 0){ //&& strcmp(schd_tab[index2][7],"D") == 0)
				//|| (strcmp(schd_tab[index][7],"D") == 0 && strcmp(schd_tab[(*local_s_tab)[k-1]][7],"D") == 0)){

				//   if(DEBUG == 1) gse << "k is " << k << " " <<  endl;
				/*
                                            if(strcmp(schd_tab[index2][7],"D") == 0  && //if there's another trip in the group
                                                strcmp(schd_tab[(int)to_number(schd_tab[index2][PICKUPIDX])][7],"P")==0
                                                != (int)to_number(schd_tab[(int)to_number(schd_tab[index2][PICKUPIDX])][2]) - 5){
                                                groupcnt = 0;
                                                interruptedgroup = true;
                                                  if(DEBUG == 1) gse << schd_tab[index][2] << " " << schd_tab[index2][2] << endl;
                                                  if(DEBUG == 1) gse << " interuppted " << (int)to_number(schd_tab[(int)to_number(schd_tab[index][PICKUPIDX])][2]) << " = " <<(int)to_number(schd_tab[(int)to_number(schd_tab[index2][PICKUPIDX])][2]) << " | " << endl;
                                                break;
                                            }*/
				//else{

				if(strcmp(schd_tab[index][0],"") == 0){
					grpfound = true;
				}

				pickupindicies[groupcnt] = (int)to_number(schd_tab[index][PICKUPIDX]);
				dropoffindicies[groupcnt] = index;

				fullRoute[fullRoutecnt] = dropoffindicies[groupcnt];
				groupcnt++;
				fullRoutecnt++;

				//   if(DEBUG == 1) gse << "In reoptimize index " << index << " pick up " << (int)to_number(schd_tab[index][PICKUPIDX]) << " testing " << groupcnt << " with group cnt " <<   schd_tab[pickupindicies[groupcnt-1]][3] << " " << schd_tab[pickupindicies[groupcnt-1]][2] <<endl;



				k++;
				index = (*local_s_tab)[k];
				if(strcmp(schd_tab[index][2],MAXSTOPNUM[0])==0){
					if(DEBUG == 1) gse << " Adding to the end " << schd_tab[(*local_s_tab)[k]][3] << endl;
					fullRoute[fullRoutecnt]= (*local_s_tab)[k];
					fullRoutecnt++;
				}
				index2 = (*local_s_tab)[k+1];



			}


			bool fini = false;
			for(int i = 0; i < MAXSTOPS; i++){

				int index3 = (*local_s_tab)[i];

				for(int o = 0; o < groupcnt;o++){

					if (pickupindicies[o] == index3){
						pickupafter = (*local_s_tab)[i-1];
						fini = true;
						break;
					}
				}
				if(fini)
					break;
			}





			dropoffbefore = (*local_s_tab)[k];




			if(groupcnt > 0){k--;}




			for(int o = 0; o < groupcnt;o++){
				if (strcmp(schd_tab[pickupindicies[o]][GRPIDX], "") != 0){
					string  tempstring = schd_tab[pickupindicies[o]][GRPIDX];
					if(DEBUG == 1) gse << "Reassigned grpmarker is " << tempstring << endl;
					grpmarker = (int)to_number(getNextToken(&tempstring, "^"));
					if(DEBUG == 1) gse << "Reassigned grpmarker is " << grpmarker << endl;
					break;

				}
			}

			if(grpmarker == 0){
				for (int i = 0; i < MAXTRIPIDX; i++)
				{ //find the largest group marker currently in the trip table
					if (strcmp(schd_tab[i][GRPIDX], "") != 0)
					{
						string tempstring = schd_tab[i][GRPIDX];
						int tempgrpmarker = (int)to_number(getNextToken(&tempstring, "^"));
						if (grpmarker <= tempgrpmarker)
						{
							grpmarker = tempgrpmarker;
						}
					}
				}
				grpmarker++;
				if(DEBUG == 1) gse << "New grpmarker is " << grpmarker << endl;
			}




			double stopnum[MAXSTOPS];

			for(int o = 0; o < groupcnt-1;o++){


				if(strcmp(schd_tab[pickupindicies[o]][42] , schd_tab[pickupindicies[o+1]][42])!=0
						|| strcmp(schd_tab[pickupindicies[o]][41] , schd_tab[pickupindicies[o+1]][41])!=0
						|| strcmp(schd_tab[dropoffindicies[o]][42] , schd_tab[dropoffindicies[o+1]][42])!=0
						|| strcmp(schd_tab[dropoffindicies[o]][41] , schd_tab[dropoffindicies[o+1]][41])!=0
						|| strcmp(schd_tab[pickupindicies[o]][42] , schd_tab[dropoffindicies[o]][42])!=0
						||strcmp(schd_tab[pickupindicies[o]][41] , schd_tab[dropoffindicies[o]][41])!=0  ){

					notsameclustertime = true;

				}
			}

			for(int o = 0; o < groupcnt;o++){
				stopnum[o] = to_number(schd_tab[pickupindicies[o]][2]);

			}


			bubbleSort_twoarray(stopnum,pickupindicies,groupcnt);
			for(int o = 0; o < groupcnt;o++){

				unordered_s_tab[o] = pickupindicies[o];
			}

			for(int o = 0; o < groupcnt;o++){
				stopnum[o] = to_number(schd_tab[dropoffindicies[o]][2]);

			}
			bubbleSort_twoarray(stopnum,dropoffindicies,groupcnt);

			for(int o = 0; o < groupcnt;o++){

				unordered_s_tab[groupcnt+o]  = dropoffindicies[o];
			}

			if(DEBUG == 1) gse << " The unordered Array is " << endl;
			for(int o = 0; o < (groupcnt*2);o++){
				if(DEBUG == 1) gse << o << " " <<  (groupcnt*2) << " " <<  unordered_s_tab[o] << " " <<  schd_tab[unordered_s_tab[o]][2] << " "<< schd_tab[unordered_s_tab[o]][3] << endl;
			}
			if(DEBUG == 1) gse << "Done" <<endl;


			int largestpromtime = 0;
			int smalleststarttime = 1440;
			bool isreturntripsmallest = false;
			bool isreturntriplargest = false;
			int aLatepickup;
			int aEarlypickup;
			int largestidx = 0;
			int smallestidx = 0;

			int stoptoinsertafter1 =  pickupafter;
			int index3;


			/*for(int q = 0; q < MAXSTOPS; q++){
                            index3 = (*local_s_tab)[q];
                            if(index3 == pickupindicies[0]){
                                index3 = (*local_s_tab)[q-1];
                                stoptoinsertafter1 = index3;
                                break;
                            }
                     }*/



			for(int o = 0; o < groupcnt;o++){

				if (largestpromtime < (int)to_number(schd_tab[pickupindicies[o]][4])){
					largestpromtime = (int)to_number(schd_tab[pickupindicies[o]][4]);
					if(strcmp(schd_tab[pickupindicies[o]][18],"Y")==0){
						isreturntriplargest = true;
						largestidx = pickupindicies[o];
					}
					else{
						isreturntriplargest = false;
						largestidx = pickupindicies[o];
					}
				}

				if (smalleststarttime > (int)to_number(schd_tab[pickupindicies[o]][26]) && (int)to_number(schd_tab[pickupindicies[o]][26]) != 0 ){
					smalleststarttime = (int)to_number(schd_tab[pickupindicies[o]][26]);
					if(strcmp(schd_tab[pickupindicies[o]][18],"Y")==0){
						isreturntripsmallest = true;
						smallestidx = pickupindicies[o];
					}
					else{
						isreturntripsmallest = false;
						smallestidx = pickupindicies[o];
					}
				}

			}

			int p_WHEELLOAD1;
			int p_AMBLOAD1;
			int p_MAXEARLYDROPOFFFACTOR1;
			int p_DIALRIDEEARLYPICKFACTOR1;
			int p_DIALRIDELATEPICKFACTOR1;
			int p_OTHEREARLYPICKFACTOR1;
			int p_OTHERLATEPICKFACTOR1;
			string IGNOREPUTIMES1;
			int p_SHORTBREAK1;
			int p_LUNCHBREAK1;
			int p_PROXIMITYFACTOR1;
			int a_mediumshortdistance1;
			int a_mediumlongdistance1;
			int a_shorttriptime1;
			int a_longtriptime1;
			int a_mediumtriptime1;
			int a_extra_loadtime1;
			string ZONE_DESCR1;
			string IGNORE_DEPOTS_CUTOFF1;



			string p_disability = schd_tab[largestidx][12];
			string p_trip_type = schd_tab[largestidx][8];

			if(p_disability.find("OT",0)!= string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp("OT", ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}


			}
			else if( p_disability.find("OT",0)== string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}
			}
			if (isreturntriplargest){
				aEarlypickup = p_OTHEREARLYPICKFACTOR1;             /* C[006] */
			}
			else{
				aEarlypickup = p_DIALRIDEEARLYPICKFACTOR1;          /* C[006] */

			}

			p_disability = schd_tab[smallestidx][12];
			p_trip_type = schd_tab[smallestidx][8];

			if(p_disability.find("OT",0)!= string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp("OT", ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}


			}
			else if( p_disability.find("OT",0)== string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}
			}

			if (isreturntripsmallest){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}

			bool leavePickupAlone = false;

			if(largestpromtime - aEarlypickup >= smalleststarttime + aLatepickup){
				if(DEBUG == 1) gse << "Reoptimizing the group might cause late trips pick up" << largestpromtime << " - " << aEarlypickup << " >= " << smalleststarttime << " + " << aLatepickup << endl;
				leavePickupAlone = true;
			}









			int smallestendtime = 1440;

			for(int o = 0; o < groupcnt;o++){

				if (largestpromtime < (int)to_number(schd_tab[dropoffindicies[o]][4])){
					largestpromtime = (int)to_number(schd_tab[dropoffindicies[o]][4]);
					if(strcmp(schd_tab[dropoffindicies[o]][18],"Y")==0){
						isreturntriplargest = true;
						largestidx = dropoffindicies[o];
					}
					else{
						isreturntriplargest = false;
						largestidx = dropoffindicies[o];
					}
				}

				if (smallestendtime > (int)to_number(schd_tab[dropoffindicies[o]][27]) && (int)to_number(schd_tab[dropoffindicies[o]][27]) != 0 ){
					smallestendtime = (int)to_number(schd_tab[dropoffindicies[o]][27]);
					if(strcmp(schd_tab[dropoffindicies[o]][18],"Y")==0){
						isreturntripsmallest = true;
						smallestidx = dropoffindicies[o];
					}
					else{
						isreturntripsmallest = false;
						smallestidx = dropoffindicies[o];
					}
				}

			}





			p_disability = schd_tab[largestidx][12];
			p_trip_type = schd_tab[largestidx][8];

			if(p_disability.find("OT",0)!= string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp("OT", ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}


			}
			else if( p_disability.find("OT",0)== string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}
			}

			int aEarlydropoff;
			if (isreturntriplargest){
				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;
			}
			else{

				aEarlydropoff = p_MAXEARLYDROPOFFFACTOR1;

			}

			p_disability = schd_tab[smallestidx][12];
			p_trip_type = schd_tab[smallestidx][8];

			if(p_disability.find("OT",0)!= string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp("OT", ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}


			}
			else if( p_disability.find("OT",0)== string::npos){
				for(int z = 0; z < MAXZONES; z++){
					if(strcmp(p_trip_type.c_str(), ZONE_DESCR[z])==0){
						p_WHEELLOAD1 =p_WHEELLOAD[z] ;
						p_AMBLOAD1 =p_AMBLOAD[z];
						p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[z] ;
						p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[z] ;
						p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[z];
						p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[z] ;
						p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[z] ;
						IGNOREPUTIMES1 = ignorepu[z] ;
						p_SHORTBREAK1 = p_SHORTBREAK[z] ;
						p_LUNCHBREAK1 = p_LUNCHBREAK[z] ;
						p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[z] ;
						a_mediumshortdistance1 = a_mediumshortdistance[z] ;
						a_mediumlongdistance1 = a_mediumlongdistance[z] ;
						a_shorttriptime1 = a_shorttriptime[z] ;
						a_longtriptime1 = a_longtriptime[z] ;
						a_mediumtriptime1 =  a_mediumtriptime[z] ;
						a_extra_loadtime1 = a_extra_loadtime[z];
						ZONE_DESCR1 =   ZONE_DESCR[z] ;
						IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[z];
						break;
					}
					if(z+1 == MAXZONES){
						for(int b = 0; b < MAXZONES; b++){

							if(strcmp("ALL", ZONE_DESCR[b])==0){
								p_WHEELLOAD1 =p_WHEELLOAD[b] ;
								p_AMBLOAD1 = p_AMBLOAD[b];
								p_MAXEARLYDROPOFFFACTOR1 = p_MAXEARLYDROPOFFFACTOR[b] ;
								p_DIALRIDEEARLYPICKFACTOR1 = p_DIALRIDEEARLYPICKFACTOR[b] ;
								p_DIALRIDELATEPICKFACTOR1 = p_DIALRIDELATEPICKFACTOR[b];
								p_OTHEREARLYPICKFACTOR1 = p_OTHEREARLYPICKFACTOR[b] ;
								p_OTHERLATEPICKFACTOR1 = p_OTHERLATEPICKFACTOR[b] ;
								IGNOREPUTIMES1 = ignorepu[b] ;
								p_SHORTBREAK1 = p_SHORTBREAK[b] ;
								p_LUNCHBREAK1 = p_LUNCHBREAK[b] ;
								p_PROXIMITYFACTOR1 = p_PROXIMITYFACTOR[b] ;
								a_mediumshortdistance1 = a_mediumshortdistance[b] ;
								a_mediumlongdistance1 = a_mediumlongdistance[b] ;
								a_shorttriptime1 = a_shorttriptime[b] ;
								a_longtriptime1 = a_longtriptime[b] ;
								a_mediumtriptime1 =  a_mediumtriptime[b] ;
								a_extra_loadtime1 = a_extra_loadtime[b];
								ZONE_DESCR1 =   ZONE_DESCR[b] ;
								IGNORE_DEPOTS_CUTOFF1 = IGNORE_DEPOTS_CUTOFF[b];
								break;
							}
						}

					}
				}
			}

			bool leaveDropoffAlone = false;

			if(largestpromtime - aEarlydropoff >= smallestendtime){
				if(DEBUG == 1) gse << "Reoptimizing the group might cause late trips dropoff " << largestpromtime << " - " << aEarlydropoff << " >= " << smallestendtime  << endl;
				leaveDropoffAlone = true;
			}



			/////if both
			if(leaveDropoffAlone && leavePickupAlone){
				if(DEBUG == 1) gse << "Reoptimizing the group might cause late trips so we're skipping completely " << largestpromtime << " - " << aEarlypickup << " >= " << smalleststarttime << " + " << aLatepickup << endl;
				interruptedgroup = true;
				grpfound = false;
			}

			if(DEBUG == 1) gse << "The groupcnt is " << groupcnt << endl;

			for(int q = 0; q < groupcnt-1;q++){


				if((int)to_number(schd_tab[pickupindicies[q]][2]) + 1 != (int)to_number(schd_tab[pickupindicies[q+1]][2])){
					if(DEBUG == 1) gse << "Stop number " << schd_tab[pickupindicies[q]][2] << " " << schd_tab[pickupindicies[q+1]][2] << endl;
					groupcnt = 0;
					interruptedgroup = true;
					grpfound = false;
					break;
				}


			}


			if(!interruptedgroup){

				for(int q = 0; q < groupcnt-1;q++){



					if((int)to_number(schd_tab[dropoffindicies[q]][2]) + 1 != (int)to_number(schd_tab[dropoffindicies[q+1]][2])){
						if(DEBUG == 1) gse << "Stop number1 " << schd_tab[dropoffindicies[q]][2] << " " << schd_tab[dropoffindicies[q+1]][2] << endl;
						interruptedgroup = true;
						grpfound = false;
						break;
					}
				}

			}

			if(!interruptedgroup){
				if((int)to_number(schd_tab[pickupindicies[groupcnt-1]][2]) + 1 != (int)to_number(schd_tab[dropoffindicies[0]][2])){
					if(DEBUG == 1) gse << "Stop number2 " << schd_tab[pickupindicies[groupcnt-1]][2] << " " << schd_tab[dropoffindicies[0]][2] << endl;
					interruptedgroup = true;
					grpfound = false;
				}

			}


			if(!interruptedgroup){
				for(int q = 0; q < groupcnt;q++){
					string routetypebefore = schd_tab[pickupindicies[q]][8];
					if(routetypebefore == "BRK" || routetypebefore == "ADMIN" || routetypebefore == "LUNCH"){
						if(DEBUG == 1) gse << "There is a break/admin/lunch in the group so skipping reop" << endl;
						interruptedgroup = true;
						grpfound = false;
						break;

					}
				}
			}
			if(!interruptedgroup){
				for(int q = 0; q < groupcnt;q++){
					string routetypebefore = schd_tab[dropoffindicies[q]][8];
					if(routetypebefore == "BRK" || routetypebefore == "ADMIN" || routetypebefore == "LUNCH"){
						if(DEBUG == 1) gse << "There is a break/admin/lunch in the group so skipping reop" << endl;
						interruptedgroup = true;
						grpfound = false;
						break;

					}
				}
			}


			if(groupcnt < 1){
				if(DEBUG == 1) gse << "Too small of a group to reoptimize, no point ( not a group ) " << endl;
				grpfound = false;
			}





			if(groupcnt >= 2 && grpfound && !interruptedgroup){
				groupcnt = groupcnt -1;
				double distances1[MAXSTOPS];

				for (int i = 0; i < (groupcnt * 2) + 2; i++){
					distances1[i] = 0;
				}
				for (int i = 0; i < (groupcnt * 2) + 2; i++)
				{
					if (i + 1 < (groupcnt * 2) + 2)
					{ /////////if lat/long different add .75 otherwise keep 0 -- SJ
						if (isSameLocation(unordered_s_tab[i], unordered_s_tab[i + 1]))
						{
							distances1[i + 1] = 0;
						}
						else
						{
							distances1[i + 1] = getTime(unordered_s_tab[i], unordered_s_tab[i + 1]);
						}
					}
					else
						distances1[i + 1] = 0;
				}

				int templocaltab2[MAXSTOPS];
				templocaltab2[0] = 0;

				for (int i = 0; i < (groupcnt * 2) + 2; i++)
				{
					templocaltab2[i + 1] = unordered_s_tab[i];
				}

				templocaltab2[(groupcnt * 2) + 3] = 0;

				bool grpokay = checkgrp((groupcnt*2)+4, distances1, templocaltab2);


				if(!grpokay){
					if(DEBUG == 1) gse << "There is a violation within the unoptimized group" << endl;

					for (int i = 0; i < (groupcnt * 2) + 2; i++)
					{
						strcpy(schd_tab[unordered_s_tab[i]][GRPIDX],"");

					}
					return false;
				}


			}







			if(!grpfound ){
				continue;
			}



			for(int o = 0; o < groupcnt+1;o++){
				for(int h = 0; h < fullRoutecnt; h++){
					if(fullRoute[h] == pickupindicies[o] || fullRoute[h] == dropoffindicies[o] ){
						if(DEBUG == 1) gse << "Erasing " << schd_tab[fullRoute[h]][3] << endl;
						fullRoute[h] = 0;
						o= -1;
						break;
					}
				}

			}




			//   if(DEBUG == 1) gse << "The group cnt is " << groupcnt << " " << fullRoutecnt <<  endl;




			if(grpfound && !interruptedgroup && groupcnt > 0){

				if(DEBUG == 1) gse << "Reordering group " << endl;
				grpfound = true;
				int grouptriparrdo[MAXSTOPS];
				int grouptriparrpu[MAXSTOPS];

				int grouptriparrtotSameCluster[MAXSTOPS];
				int grouptriparr[MAXSTOPS];

				int tempidx;

				for(int j = 0; j < MAXSTOPS; j++){
					grouptriparrtot[j]=0;
				}


				int stoptoinsertafter;

				for(int j = 0; j < MAXSTOPS; j++){

					tempidx = (*local_s_tab)[j+1];
					//  if(DEBUG == 1) gse << "stop num 2 " << (int)to_number(schd_tab[tempidx][2]) << endl;
					if((int)to_number(schd_tab[tempidx][2]) == stopnum[0]){
						stoptoinsertafter = (*local_s_tab)[j];
						break;
					}
				}

				//  if(DEBUG == 1) gse << "Stop to insert " << schd_tab[stoptoinsertafter][3]  << endl;






				if(DEBUG == 1) gse << "The group cnt is 1: " << groupcnt << " " << fullRoutecnt <<  endl;

				for(int o = 0; o < groupcnt;o++){
					for(int h = 0; h < fullRoutecnt; h++){
						if(fullRoute[h] == pickupindicies[o] ||fullRoute[h] == dropoffindicies[o] ){
							fullRoute[h] = 0;
							o = -1;
							break;
						}
					}

				}



				/*    if(DEBUG == 1) gse << "Before optimizing " << endl;

                        for(int d = 1; d < MAXSTOPS; d++){

                                        if(s_tab[m][d]==0){
                                            break;
                                        }

                              if(DEBUG == 1) gse << schd_tab[s_tab[m][d]][3] << endl;
                        }

				 */


				int r = 0;



				if(!notsameclustertime){

					if(DEBUG == 1) gse << "Same cluster " << endl;


					//  if(DEBUG == 1) gse << "The group cnt is 0 " << groupcnt << " " << fullRoutecnt <<  endl;
					int temp = 0;

					if((!leavePickupAlone && leaveDropoffAlone) || (!leavePickupAlone && !leaveDropoffAlone)){


						grouptriparrtotSameCluster[0] = pickupindicies[0];
						temp++;

						for(int o = 1; o < groupcnt+1;o++){ ////create one large tripidx of p and d for group trips
							grouptriparrtotSameCluster[o] = pickupindicies[o];
							temp++;
						}
						grouptriparrtotSameCluster[temp] = dropoffindicies[0];
						temp++;
						for(int o = temp; o < groupcnt*2+2;o++){ ////create one large tripidx of p and d for group trips
							grouptriparrtotSameCluster[o] = dropoffindicies[o-temp+1];
						}


						double distancebegin = 0.0;

						for(int i = 0; i < groupcnt+1; i++){

							if (strcmp(schd_tab[grouptriparrtotSameCluster[i]][7], "P") == 0)
								//{

								if (isSameLocation(grouptriparrtotSameCluster[i],stoptoinsertafter)){
									grouptriparrtot[r] = grouptriparrtotSameCluster[i];
									break;
								}
								else{

									if(distancebegin == 0.0){
										grouptriparrtot[r] = grouptriparrtotSameCluster[i];
										distancebegin = getCost(grouptriparrtotSameCluster[i], stoptoinsertafter);

									}
									else if(getCost(grouptriparrtotSameCluster[i], stoptoinsertafter) < distancebegin){
										grouptriparrtot[r] = grouptriparrtotSameCluster[i];
										distancebegin = getCost(grouptriparrtotSameCluster[i], stoptoinsertafter);

									}

								}
							//}
						}


						if(DEBUG == 1) gse << "The group cnt is v2 " << groupcnt << " " << fullRoutecnt <<  endl;
						r++;

					}
					else if(leavePickupAlone && !leaveDropoffAlone){

						grouptriparrtot[0] = pickupindicies[0];
						grouptriparrtotSameCluster[0]= pickupindicies[0];
						temp++;
						r++;
						for(int o = 1; o < groupcnt+1;o++){ ////create one large tripidx of p and d for group trips
							grouptriparrtot[r] = pickupindicies[o];
						grouptriparrtotSameCluster[r]= pickupindicies[o];
						r++;
						}
						int z = r;
						grouptriparrtotSameCluster[z] = dropoffindicies[0];
						z++;
						temp++;
						for(int o = 1; o < groupcnt+1;o++){ ////create one large tripidx of p and d for group trips
							grouptriparrtotSameCluster[z] = dropoffindicies[o];
							z++;
						}

					}










					///  if(DEBUG == 1) gse << "The group cnt is 1 " << groupcnt << " " << fullRoutecnt <<  endl;





					double distance = 0;
					int nextStop;
					int samelatlongcounter = 0;
					bool insertedsamedrop = false;

					while(r <= (groupcnt*2)+2){
						for(int i = 0; i < groupcnt*2+2; i++){
							for(int h = 0; h < r; h++){
								if(grouptriparrtot[h] == grouptriparrtotSameCluster[i]){//already in final order skip
									//  if(DEBUG == 1) gse << "Breaking already in cluster array " << schd_tab[grouptriparrtotSameCluster[i]][3] << " " << grouptriparrtotSameCluster[i]  << endl;
									break;
								}
								else if (h+1 == r){

									if(DEBUG == 1) gse << "in here 1" << endl;

									if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][7],"D")==0 && !leaveDropoffAlone){

										//   if(DEBUG == 1) gse << "Found D" << endl;


										for(int j = 0; j < r; j++){

											//    if(DEBUG == 1) gse << "j is " << j << endl;
											if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][3],schd_tab[grouptriparrtot[j]][3])==0  && strcmp(schd_tab[grouptriparrtot[j]][7], "P")==0){
												//pick up is already in order so we can continue

												//    if(DEBUG == 1) gse << "Found p" << endl;

												if (isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[r-1])){
													distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
													nextStop = grouptriparrtotSameCluster[i];
													insertedsamedrop = true;
													//  if(DEBUG == 1) gse << "Dropoff 1 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
												}


												else if(distance == 0 && !insertedsamedrop){
													nextStop = grouptriparrtotSameCluster[i];
													distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);

												}
												else if(distance >= getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1] ) && !insertedsamedrop){
													nextStop = grouptriparrtotSameCluster[i];
													distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
												}
											}



											if(isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[r-1])
													&& j+1 == r){

												if(DEBUG == 1) gse << "in here 1 " << r << endl;

												int f = r;
												int tempindexarray[MAXSTOPS];
												int tempindexarraycnt = 0;

												if(DEBUG == 1) gse << "in here 2 " << r << endl;

												while(f > 0 && isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[f-1])){
													tempindexarray[tempindexarraycnt] = grouptriparrtot[f-1];
													f--;
													tempindexarraycnt++;
												}


												if(DEBUG == 1) gse << "in here 3 " << r << endl;
												for(int y = 0; y < r; y++){
													if(strcmp(schd_tab[grouptriparrtotSameCluster[y]][3],schd_tab[grouptriparrtotSameCluster[i]][3])==0  && strcmp(schd_tab[grouptriparrtotSameCluster[y]][7], "P")==0 && !insertedsamedrop){
														grouptriparrtot[f] = grouptriparrtotSameCluster[y];
														f++;
														for(int d = tempindexarraycnt-1; d >= 0; d--){
															grouptriparrtot[f] = tempindexarray[d];
															f++;
															//r++;
														}
														r++;
														nextStop = grouptriparrtotSameCluster[i];
														distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
														//   if(DEBUG == 1) gse << " Had to reorder because we had a same drop lat long before a pickup. " << schd_tab[grouptriparrtotSameCluster[i]][3] << endl;
														insertedsamedrop = true;
														break;
													}
												}
											}
										}
									}
									else if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][7],"D")==0 && leaveDropoffAlone){
										if(DEBUG == 1) gse << "We're leaving the drop off in the same order " << endl;
										nextStop = grouptriparrtotSameCluster[i];
										break;
									}
									if(strcmp(schd_tab[grouptriparrtotSameCluster[i]][7],"P")==0){ //it is a pick up so we can continue

										//   if(DEBUG == 1) gse << "in here 2 P" << endl;

										if(isSameLocation(grouptriparrtotSameCluster[i],grouptriparrtot[r-1]) && !insertedsamedrop){
											distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
											nextStop = grouptriparrtotSameCluster[i];
											insertedsamedrop = true;
											//  if(DEBUG == 1) gse << "Dropoff 1 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
										}

										else if(distance == 0 && !insertedsamedrop){
											nextStop = grouptriparrtotSameCluster[i];
											distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);

										}
										else if(distance >= getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1] ) && !insertedsamedrop){
											nextStop = grouptriparrtotSameCluster[i];
											distance = getCost(grouptriparrtotSameCluster[i], grouptriparrtot[r-1]);
										}

									}
								}
							}
						}
						grouptriparrtot[r] = nextStop;
						if(DEBUG == 1) gse << "Inserted  " <<schd_tab[grouptriparrtot[r]][3] <<  endl;
						distance = 0;
						r++;
						insertedsamedrop = false;
					}

					//  if(DEBUG == 1) gse << "The group cnt is 3 " << groupcnt << " " << fullRoutecnt <<  endl;

				}

				else{

					if(DEBUG == 1) gse << "Centroid "  <<  endl;
					if(DEBUG == 1) gse << "The group cnt is 2: " << groupcnt << " " << fullRoutecnt <<  endl;

					int temp[MAXSTOPS];

					double distpu = 0;
					double distdo = 0;
					std::vector<my_point> ring;
					my_point p;
					my_point p1;
					point_type centroid;
					polygon_type poly;



					if((!leavePickupAlone && leaveDropoffAlone) || (!leavePickupAlone && !leaveDropoffAlone)){

						temp[0] = pickupindicies[0];
						for(int i = 1; i < groupcnt+1;i++){
							temp[i] = pickupindicies[i];
						}
						grouptriparrdo[0]  = dropoffindicies[0];
						for(int o = 1; o < groupcnt+1;o++){
							grouptriparrdo[o] = dropoffindicies[o];
						}



						for(int o = 0; o < groupcnt+1;o++){ ///get centroid of p and d area of group trips
							double lat = to_number(schd_tab[grouptriparrdo[o]][10]);
						double lon = to_number(schd_tab[grouptriparrdo[o]][37]);
						bg::assign_values(p, lon, lat);
						ring.push_back(p);
						}
						boost::geometry::correct(ring);

						boost::geometry::convert(ring, poly);
						boost::geometry::centroid(poly, centroid);

						for(int i = 0; i < groupcnt+1;i++){ //get inital pickup farthest from centroid of dropoff

							double lat = to_number(schd_tab[temp[i]][10]);
							double lon = to_number(schd_tab[temp[i]][37]);
							bg::assign_values(p, lon, lat);
							point_type p2;
							boost::geometry::convert(p, p2);
							//  if(DEBUG == 1) gse << "Distance " << schd_tab[temp[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
							if(distpu == 0 ){
								//  if(DEBUG == 1) gse << "Distance " << schd_tab[temp[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
								distpu = bg::distance(p2, centroid);
								grouptriparrtot[r] = temp[i];
							}
							if (isSameLocation(temp[i], stoptoinsertafter1)){
								distpu = bg::distance(p2, centroid);
								grouptriparrtot[r] = temp[i];
								break;
							}
							else if(distpu < bg::distance(p2, centroid)){
								//  if(DEBUG == 1) gse << "Distance " << schd_tab[temp[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
								distpu = bg::distance(p2, centroid);
								grouptriparrtot[r] = temp[i];
							}
						}

						r++;


					}
					else if(leavePickupAlone && !leaveDropoffAlone){
						grouptriparrtot[0] = pickupindicies[0];
						r++;
						for(int i = 1; i < groupcnt+1;i++){
							grouptriparrtot[r] = pickupindicies[i];
							r++;
						}

						grouptriparrdo[0]  = dropoffindicies[0];
						for(int o = 1; o < groupcnt+1;o++){
							grouptriparrdo[o] = dropoffindicies[o];
						}





					}


					//   if(DEBUG == 1) gse << "initial " << schd_tab[grouptriparrtot[r]][3] << endl;



					double ratio = 0;
					int pickup;

					bool insertedsamedrop = false;
					//bool newinsert = false;



					if(!leavePickupAlone){
						while(r < groupcnt+1){
							for(int i = 0; i < groupcnt+1;i++){
								//get pickup order
								//newinsert = false;

								for(int h = 0; h < r; h++){

									if(temp[i] == grouptriparrtot[h]){
										//newinsert = false;
										break;
									}
									else if(h+1 == r){
										//newinsert = true;
										double lat = to_number(schd_tab[temp[i]][10]);
										double lon = to_number(schd_tab[temp[i]][37]);
										bg::assign_values(p, lon, lat);
										double lat1 = to_number(schd_tab[grouptriparrtot[r-1]][10]);
										double lon1 = to_number(schd_tab[grouptriparrtot[r-1]][37]);
										bg::assign_values(p1, lon1, lat1);
										point_type p2;
										point_type p3;
										boost::geometry::convert(p, p2);
										boost::geometry::convert(p1, p3);

										//   if(DEBUG == 1) gse << "Pickup 1 " << schd_tab[grouptriparrtot[r-1]][3] << " " << schd_tab[temp[i]][3] << " " << bg::distance(p2, centroid)/ bg::distance(p2, p3) <<   endl;

										if(isSameLocation(temp[i],grouptriparrtot[r-1])){
											ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
											pickup = temp[i];
											insertedsamedrop = true;
											//   if(DEBUG == 1) gse << "Pickup 1 " << schd_tab[pickup][3] << " " << schd_tab[pickup][10] <<  " " << schd_tab[pickup][37] << " " << bg::distance(p2, centroid) << " " << bg::distance(p2, p3) <<  endl;
										}
										else if(ratio == 0 && !insertedsamedrop){
											ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
											pickup = temp[i];
											//   if(DEBUG == 1) gse << "Pickup 0 " << schd_tab[grouptriparrtot[r]][3] << " " << grouptriparrtot[r] <<  endl;

										}

										else if(ratio <= bg::distance(p2, centroid)/ bg::distance(p2, p3) && !insertedsamedrop ){
											ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
											pickup = temp[i];
											//   if(DEBUG == 1) gse << "Pickup 1 " << schd_tab[grouptriparrtot[r]][3] << " " << grouptriparrtot[r] <<  endl;
										}
									}
								}
							}
							ratio = 0;
							//if(newinsert){
							grouptriparrtot[r] = pickup;
							//  if(DEBUG == 1) gse << "pickup " << schd_tab[pickup][3] << endl;
							//   if(DEBUG == 1) gse << "R is : " <<  schd_tab[grouptriparrtot[r]][3] << " " << grouptriparrtot[r] <<  endl;
							r++;
							insertedsamedrop = false;
							//}
						}


					}

					ratio = 0;
					int dropoff;
					int f = r;
					int dropoffcentroid;
					distpu = 0;


					double lat = to_number(schd_tab[grouptriparrtot[f-1]][10]); //last pickup in array
					double lon = to_number(schd_tab[grouptriparrtot[f-1]][37]);
					bg::assign_values(centroid, lon, lat); //make that the centroid


					if(DEBUG == 1) gse << "The group cnt is 2.1: " << groupcnt << " " << fullRoutecnt <<  endl;

					if(leaveDropoffAlone){

						if(DEBUG == 1) gse << "We're leaving the drop off alone" << endl;

						for(int o = 0; o < groupcnt+1;o++){
							grouptriparrtot[f] = grouptriparrdo[o];
							f++;
						}

					}
					else{
						for(int i = 0; i < groupcnt+1;i++){ //get inital dropoff closest to last pickup in group
							double lat = to_number(schd_tab[grouptriparrdo[i]][10]);
							double lon = to_number(schd_tab[grouptriparrdo[i]][37]);
							bg::assign_values(p, lon, lat);
							point_type p2;
							boost::geometry::convert(p, p2);
							//  if(DEBUG == 1) gse << "Tripids " << schd_tab[grouptriparrdo[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
							if(distpu == 0 ){
								distpu = bg::distance(p2, centroid);
								grouptriparrtot[f] = grouptriparrdo[i];
							}
							else if(isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i])){
								grouptriparrtot[f] = grouptriparrdo[i];
								break;
							}
							else if(distpu > bg::distance(p2, centroid)){
								distpu = bg::distance(p2, centroid);
								grouptriparrtot[f] = grouptriparrdo[i];
							}
						}

						distpu = 0;
						dropoffcentroid = 0;

						for(int i = 0; i < groupcnt+1;i++){ //get dropoff farthest to last pickup in group
							double lat = to_number(schd_tab[grouptriparrdo[i]][10]);
							double lon = to_number(schd_tab[grouptriparrdo[i]][37]);
							bg::assign_values(p, lon, lat);
							point_type p2;
							boost::geometry::convert(p, p2);
							//   if(DEBUG == 1) gse << "Tripids dropoff " << schd_tab[grouptriparrdo[i]][3] <<  " " << bg::distance(p2, centroid) << endl;
							if(distpu == 0 && !isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i])){
								distpu = bg::distance(p2, centroid);
								dropoffcentroid = grouptriparrdo[i];
							}
							else if(distpu < bg::distance(p2, centroid) && !isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i])){
								distpu = bg::distance(p2, centroid);
								dropoffcentroid = grouptriparrdo[i];
							}
						}

						if(dropoffcentroid == 0){
							for(int i = 0; i < groupcnt+1;i++){
								if(isSameLocation(grouptriparrtot[f-1],grouptriparrdo[i]) && grouptriparrtot[f-1]!=grouptriparrdo[i]){
									dropoffcentroid = grouptriparrdo[i];
									break;
								}
							}
						}

						lat = to_number(schd_tab[dropoffcentroid][10]); //last pickup in array
						lon = to_number(schd_tab[dropoffcentroid][37]);
						bg::assign_values(centroid, lon, lat); //make that the centroid

						if(DEBUG == 1) gse << " Drop off centroid " << schd_tab[dropoffcentroid][3] << endl;

						//   if(DEBUG == 1) gse << "initial dropoff " << schd_tab[grouptriparrtot[f]][3] << endl;
						f++;

						//      if(DEBUG == 1) gse << "The group cnt is 3 " << groupcnt << " " << fullRoutecnt <<  endl;

						while(f < (groupcnt*2) + 2){
							for(int i = 0; i < groupcnt+1;i++){ //get dropoff order
								//newinsert = false;

								for(int h = r; h < f; h++){

									if(grouptriparrdo[i] == grouptriparrtot[h]){
										//newinsert =  false;
										break;
									}
									else if(h+1 == f){
										//newinsert = true;
										double lat = to_number(schd_tab[grouptriparrdo[i]][10]);
										double lon = to_number(schd_tab[grouptriparrdo[i]][37]);
										bg::assign_values(p, lon, lat);
										double lat1 = to_number(schd_tab[grouptriparrtot[f-1]][10]);
										double lon1 = to_number(schd_tab[grouptriparrtot[f-1]][37]);
										bg::assign_values(p1, lon1, lat1);
										point_type p2;
										point_type p3;
										boost::geometry::convert(p, p2);
										boost::geometry::convert(p1, p3);

										//   if(DEBUG == 1) gse << "ratio " << schd_tab[grouptriparrdo[i]][3] << " "  << bg::distance(p2, centroid)/ bg::distance(p2, p3) << endl;

										if(isSameLocation(grouptriparrdo[i],grouptriparrtot[f-1])){
											ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
											dropoff = grouptriparrdo[i];
											insertedsamedrop = true;
											//  if(DEBUG == 1) gse << "Dropoff 1 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
										}
										else if(ratio == 0 && !insertedsamedrop){
											ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
											dropoff = grouptriparrdo[i];
											//   if(DEBUG == 1) gse << "Dropoff 0 " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;

										}

										else if(ratio <= bg::distance(p2, centroid)/ bg::distance(p2, p3) && !insertedsamedrop){
											ratio = bg::distance(p2, centroid)/ bg::distance(p2, p3);
											dropoff = grouptriparrdo[i];
										}




									}
								}

							}
							ratio = 0;
							//if(newinsert){
							grouptriparrtot[f] = dropoff;
							//   if(DEBUG == 1) gse << "drop off " <<  schd_tab[dropoff][3] << endl;
							//  if(DEBUG == 1) gse << "F is : " << schd_tab[grouptriparrtot[f]][3] << " " << grouptriparrtot[f] << endl;
							f++;
							insertedsamedrop = false;
							//}
						}

					}

					if(DEBUG == 1) gse << "The group cnt is 3: " << groupcnt << " " << fullRoutecnt <<  endl;

				}

				//   if(DEBUG == 1) gse << " The layout for the group trip now is: " << groupcnt <<  endl; //new order layout
				/*
                     for(int i = 0; i < (groupcnt*2)+2;i++){
                          if(DEBUG == 1) gse << schd_tab[grouptriparrtot[i]][3] << " " << schd_tab[grouptriparrtot[i]][7] << endl;
                    }
				 */

				if(DEBUG == 1) gse << "The full group is : " << groupcnt << endl;

				for(int h = 0; h < (groupcnt*2)+2; h++){
					if(DEBUG == 1) gse << schd_tab[grouptriparrtot[h]][3] << " " << schd_tab[grouptriparrtot[h]][7] << endl;
				}
				if(DEBUG == 1) gse << "Full route cnt " << fullRoutecnt << endl;
				for(int i = 0; i < fullRoutecnt; i++){

					if(DEBUG == 1) gse << fullRoute[i] << " " << schd_tab[fullRoute[i]][3] << endl;

				}


				if(DEBUG == 1) gse << "The full group is 1 : " << groupcnt << endl;

				for(int i = 0; i < fullRoutecnt; i++){
					//   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
					if (fullRoute[i] == 0){
						for(int h = 0; h < (groupcnt*2)+2; h++){
							strcpy(schd_tab[grouptriparrtot[h]][GRPIDX], (to_string(grpmarker) + "^" + to_string(h)).c_str());
							fullRoute[i] = grouptriparrtot[h];

							if(DEBUG == 1) gse << "End of group " << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;
							i++;
						}
						//  if(DEBUG == 1) gse << "The grpmarker is " << grpmarker << endl;
					}
				}



				//    if(DEBUG == 1) gse << "full route " << endl;
				/*for(int i = 0; i < fullRoutecnt; i++){
                   if(DEBUG == 1) gse << schd_tab[fullRoute[i]][3] << " " << schd_tab[fullRoute[i]][7] << endl;

            }*/

			}




		}

		else{
			if(DEBUG == 1) gse << "Pick up or not group " << schd_tab[index][3] << endl;
			fullRoute[fullRoutecnt]= index;
			fullRoutecnt++;

		}


	}


	if(grpfound){


		if(DEBUG == 1) gse << "Seeing if we can swap anything around by timeslot" << endl;

		for (int i = 0; i < (groupcnt * 2) + 2; i++){
			if(i < 0)
				i = 0;
			if(i+1 != ((groupcnt * 2) + 2) && strcmp(schd_tab[grouptriparrtot[i]][42],schd_tab[grouptriparrtot[i+1]][42]) ==0 &&
					(int)to_number(schd_tab[grouptriparrtot[i]][4]) >  (int)to_number(schd_tab[grouptriparrtot[i+1]][4])){
				if(DEBUG == 1) gse << "We should swap these trips based off timeslot and cluster " << schd_tab[grouptriparrtot[i]][3]  << " " << schd_tab[grouptriparrtot[i+1]][3] << endl;
				int temp = grouptriparrtot[i];
				grouptriparrtot[i] = grouptriparrtot[i+1];
				grouptriparrtot[i+1] = temp;
				i = -1;


			}


		}

		for (int i = 0; i < (groupcnt * 2) + 2; i++){
			distances[i] = 0;
		}
		for (int i = 0; i < (groupcnt * 2) + 2; i++)
		{
			if (i + 1 < (groupcnt * 2) + 2)
			{ /////////if lat/long different add .75 otherwise keep 0 -- SJ
				if (isSameLocation(unordered_s_tab[i], unordered_s_tab[i + 1]))
				{
					distances[i + 1] = 0;
					if(DEBUG == 1) gse << "SAME " <<  schd_tab[unordered_s_tab[i]][3] << " " << distances[i + 1] << endl;
				}
				else
				{
					distances[i + 1] = getTime(unordered_s_tab[i],unordered_s_tab[i + 1]);
					if(DEBUG == 1) gse << schd_tab[unordered_s_tab[i]][3] << " " << distances[i + 1] << endl;
				}
			}
			else
				distances[i + 1] = 0;
		}

		int templocaltab[MAXSTOPS];
		templocaltab[0] = pickupafter;

		if (isSameLocation(pickupafter, unordered_s_tab[0]))
		{
			distances[0] = 0;
		}
		else
		{
			distances[0] = getTime(unordered_s_tab[0], pickupafter);
		}

		for (int i = 0; i < (groupcnt * 2) + 2; i++)
		{
			templocaltab[i + 1] = unordered_s_tab[i];
		}

		templocaltab[(groupcnt * 2) + 3] = dropoffbefore;

		if (isSameLocation(dropoffbefore, unordered_s_tab[(groupcnt * 2) + 1]))
		{
			distances[(groupcnt * 2) + 2] = 0;
		}
		else
		{
			distances[(groupcnt * 2) + 2] = getTime(unordered_s_tab[(groupcnt * 2) + 1], dropoffbefore);
		}

		if(DEBUG == 1) gse << "First grouping " << endl;

		bool grpokay =  checkgrp((groupcnt*2)+4, distances, templocaltab);
		if(grpokay){

			for (int i = 0; i < (groupcnt * 2) + 2; i++){
				distances[i] = 0;
			}
			for (int i = 0; i < (groupcnt * 2) + 2; i++)
			{
				if (i + 1 < (groupcnt * 2) + 2)
				{ /////////if lat/long different add .75 otherwise keep 0 -- SJ
					if (isSameLocation(grouptriparrtot[i], grouptriparrtot[i + 1]))
					{
						distances[i + 1] = 0;
					}
					else
					{
						distances[i + 1] = getTime(grouptriparrtot[i], grouptriparrtot[i + 1]);
					}
				}
				else
					distances[i + 1] = 0;
			}

			if (isSameLocation(pickupafter, grouptriparrtot[0]))
			{
				distances[0] = 0;
			}
			else
			{
				distances[0] = getTime(grouptriparrtot[0], pickupafter);
			}


			if (isSameLocation(dropoffbefore, grouptriparrtot[(groupcnt * 2) + 1]))
			{
				distances[(groupcnt * 2) + 2] = 0;
			}
			else
			{
				distances[(groupcnt * 2) + 2] = getTime(grouptriparrtot[(groupcnt * 2) + 1], dropoffbefore);
			}



			for (int i = 0; i < (groupcnt * 2) + 2; i++)
			{
				templocaltab[i + 1] = grouptriparrtot[i];
			}


			grpokay = checkgrp((groupcnt*2)+4, distances, templocaltab);
			if(!grpokay){
				if(DEBUG == 1) gse << "Reoptimizing is causing a violation when there is none so not going to " << endl;
				grpfound = false;
			}
		}
		else{
			if(DEBUG == 1) gse << "There is a violation in this group so we'll try REOPTIMIZE and if that doesn't work then skip!" << endl;


			for (int i = 0; i < (groupcnt * 2) + 2; i++){
				distances[i] = 0;
			}
			for (int i = 0; i < (groupcnt * 2) + 2; i++)
			{
				if (i + 1 < (groupcnt * 2) + 2)
				{ /////////if lat/long different add .75 otherwise keep 0 -- SJ
					if (isSameLocation(grouptriparrtot[i], grouptriparrtot[i + 1]))
					{
						distances[i + 1] = 0;
					}
					else
					{
						distances[i + 1] = getTime(grouptriparrtot[i], grouptriparrtot[i + 1]);
					}
				}
				else
					distances[i + 1] = 0;
			}

			if (isSameLocation(pickupafter, grouptriparrtot[0]))
			{
				distances[0] = 0;
			}
			else
			{
				distances[0] = getTime(grouptriparrtot[0], pickupafter);
			}


			if (isSameLocation(dropoffbefore, grouptriparrtot[(groupcnt * 2) + 1]))
			{
				distances[(groupcnt * 2) + 2] = 0;
			}
			else
			{
				distances[(groupcnt * 2) + 2] = getTime(grouptriparrtot[(groupcnt * 2) + 1], dropoffbefore);
			}



			for (int i = 0; i < (groupcnt * 2) + 2; i++)
			{
				templocaltab[i + 1] = grouptriparrtot[i];
			}


			grpokay = checkgrp((groupcnt*2)+4, distances, templocaltab);

			if(!grpokay){
				if(DEBUG == 1) gse << "Reoptimizing is causing a violation too so we're gonna skip completely " << endl;
				return false;
			}

		}

	}


	if(grpfound)
	{
		// if(DEBUG == 1) gse << "Reoptimizied" << endl;

		for(int i = 0; i < MAXSTOPS;i++){
			if((*local_s_tab)[i] == 0)
				break;
			(*local_s_tab)[i] = fullRoute[i];
			if(DEBUG == 1) gse << schd_tab[(*local_s_tab)[i]][3] << endl;
		}
		if(DEBUG == 1) gse << "Done optimizing" <<endl;
		return true;
	}


	return true;



}



void printSlack(int timeslot, int clusterid){

	int count;

	int unass = 0;
	int signed1 = 0;

	// if(DEBUG == 1) gse << "For timeslot: " << route << endl;

	//for(int m = 0; m < MAXTIMESLOTS; m++){

	//if (timeslot != -1 && m != timeslot)
	//continue;

	// if(DEBUG == 1) gse << "\t " << m <<  endl;

	for(int k = 0; k < MAXCLUSTERS; k++){
		if (clusterid != -1 && k != clusterid)
			continue;
		if(ts_tab[30][38][SLACK][0] == 0)
			continue;

		//  if(DEBUG == 1) gse << " for time slot " << m << " Cluster is " << k <<  " "  << endl;
		//  if(DEBUG == 1) gse << "\t\t\t";
		for(int i = 1; i <=   ts_tab[30][38][SLACK][0]; i++){

			if(strcmp(schd_tab[ts_tab[30][38][SLACK][i]][0],"")==0)
				unass++;
			else
				signed1++;
			// if(DEBUG == 1) gse << ts_tab[m][k][0] << " " << ts_tab[m][k][i] << endl;
			//if(strcmp(schd_tab[ts_tab[m][k][i]][0],segment.c_str())==0)
			// if(DEBUG == 1) gse << " segment " << schd_tab[ts_tab[m][k][i]][0] << " index " << ts_tab[m][k][i] << " \n| "  ;
		}

	}

	//  if(DEBUG == 1) gse << endl;


	//}

	cout<< "For cluster " << 38 << " and time slot " <<  30 << " Unassigned : "  << unass << " and Assigned : " << signed1 << endl;

}


void RemoveTrip(int timeslot, int clusterid, int tripidx){

	int tempidx[ts_tab[timeslot][clusterid][UNASSIGNED][0]];
	bool tripFound = false;
	int tripcnt;
	tripcnt = ts_tab[timeslot][clusterid][UNASSIGNED][0];
	// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;

	for(int i = 1; i <= tripcnt; i++){
		// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
		if(ts_tab[timeslot][clusterid][UNASSIGNED][i]== tripidx){
			tripFound = true;
		}
		if(tripFound){
			ts_tab[timeslot][clusterid][UNASSIGNED][i] = ts_tab[timeslot][clusterid][UNASSIGNED][i+1];
			//if(ts_tab[j][clusterid][SLACK][i] < 0)
			// if(DEBUG == 1) gse << " The new index is " << ts_tab[j][clusterid][SLACK][i] << "With index " << i <<  " with time slot " << j <<  " and trip cnt " << tripcnt << " and cluster " << clusterid << endl;
		}
	}
	if(tripFound){
		ts_tab[timeslot][clusterid][UNASSIGNED][0] = tripcnt-1;
		ts_tab[timeslot][clusterid][UNASSIGNED][tripcnt] = 0;
	}

}


void clearSlackAllClusters(int tripidx){

	bool tripFound = false;
	int tripcnt;
	// int starttm = starttimer(MONITOR1);
	for(int j = 0; j < MAXTIMESLOTS; j++){
		for(int K = 0; K < MAXCLUSTERS; K++){

			tripcnt = ts_tab[j][K][SLACK][0];
			// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;
			tripFound = false;
			for(int i = 1; i <= tripcnt; i++){
				// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
				if(abs(ts_tab[j][K][SLACK][i])== tripidx){
					tripFound = true;
					for(int z = i; z <= tripcnt;z ++){
						ts_tab[j][K][SLACK][z] = ts_tab[j][K][SLACK][z+1];
					}
					break;
				}

			}
			if(tripFound){
				ts_tab[j][K][SLACK][0] = tripcnt-1;
				ts_tab[j][K][SLACK][tripcnt] = 0;
			}
		}
	}
	//  if(DEBUG == 1) gse << "Cleared Slack for Trip "<< tripidx << " for clusterid " << clusterid << endl;
}

void clearSlack_allTimeslots(int cluster, int tripidx){

	bool tripFound = false;
	int tripcnt;
	// int starttm = starttimer(MONITOR1);
	for(int j = 0; j < MAXTIMESLOTS; j++){
		tripcnt = ts_tab[j][cluster][SLACK][0];
		// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;
		tripFound = false;
		for(int i = 1; i <= tripcnt; i++){
			// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
			if(abs(ts_tab[j][cluster][SLACK][i])== tripidx){
				tripFound = true;
				for(int z = i; z <= tripcnt;z ++){
					ts_tab[j][cluster][SLACK][z] = ts_tab[j][cluster][SLACK][z+1];
				}
				break;
			}

		}
		if(tripFound){
			ts_tab[j][cluster][SLACK][0] = tripcnt-1;
			ts_tab[j][cluster][SLACK][tripcnt] = 0;
		}
	}


	//  if(DEBUG == 1) gse << "Cleared Slack for Trip "<< tripidx << " for clusterid " << clusterid << endl;
}



void clearSlackAllClustersUNASSIGNED(int tripidx){

	bool tripFound = false;
	int tripcnt;
	// int starttm = starttimer(MONITOR1);
	for(int j = 0; j < MAXTIMESLOTS; j++){
		for(int K = 0; K < MAXCLUSTERS; K++){

			tripcnt = ts_tab[j][K][UNASSIGNED][0];
			// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;
			tripFound = false;
			for(int i = 1; i <= tripcnt; i++){
				// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
				if(abs(ts_tab[j][K][UNASSIGNED][i])== tripidx){
					tripFound = true;
					for(int z = i; z <= tripcnt;z ++){
						ts_tab[j][K][UNASSIGNED][z] = ts_tab[j][K][UNASSIGNED][z+1];
					}
					break;
				}

			}
			if(tripFound){
				ts_tab[j][K][UNASSIGNED][0] = tripcnt-1;
				ts_tab[j][K][UNASSIGNED][tripcnt] = 0;
			}
		}
	}
	//  if(DEBUG == 1) gse << "Cleared Slack for Trip "<< tripidx << " for clusterid " << clusterid << endl;
}





void clearSlack(int tripidx, int clusterid){

	bool tripFound = false;
	int tripcnt;
	// int starttm = starttimer(MONITOR1);
	for(int j = 0; j < MAXTIMESLOTS; j++){
		tripcnt = ts_tab[j][clusterid][SLACK][0];
		// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;
		tripFound = false;
		for(int i = 1; i <= tripcnt; i++){
			// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
			if(abs(ts_tab[j][clusterid][SLACK][i])== tripidx){
				tripFound = true;
				for(int k = i; k <= tripcnt; k ++){
					ts_tab[j][clusterid][SLACK][k] = ts_tab[j][clusterid][SLACK][k+1];
				}
				break;
			}
		}
		if(tripFound){
			ts_tab[j][clusterid][SLACK][0] = tripcnt-1;
			ts_tab[j][clusterid][SLACK][tripcnt] = 0;
		}
	}
	//  if(DEBUG == 1) gse << "Cleared Slack for Trip "<< tripidx << " for clusterid " << clusterid << endl;
}



void clearSlackAssigned(int tripidx, int timeslot, int clusterid){

	bool tripFound = false;
	int tripcnt;
	//int starttm = starttimer(MONITOR1);

	tripcnt = ts_tab[timeslot][clusterid][SLACK][0];
	// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;
	tripFound = false;
	for(int i = 1; i <= tripcnt; i++){
		// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
		if(ts_tab[timeslot][clusterid][SLACK][i] == tripidx){
			tripFound = true;
			for(int k = i; k <= tripcnt; k ++){
				ts_tab[timeslot][clusterid][SLACK][k] = ts_tab[timeslot][clusterid][SLACK][k+1];
			}
			break;
		}

	}
	if(tripFound){
		ts_tab[timeslot][clusterid][SLACK][0] = tripcnt-1;
		ts_tab[timeslot][clusterid][SLACK][tripcnt] = 0;
	}

	//  if(DEBUG == 1) gse << "Cleared Slack for Trip "<< tripidx << " for clusterid " << clusterid << " in " << endtimer(starttm, MONITOR) << " seconds " << endl;
}

void clearSlackUnassigned(int tripidx, int timeslot, int clusterid){

	bool tripFound = false;
	int tripcnt;
	// int starttm = starttimer(MONITOR1);

	tripcnt = ts_tab[timeslot][clusterid][UNASSIGNED][0];
	// if(DEBUG == 1) gse << "Trip count " << tripcnt << " " << clusterid << " " << j << " the index " << tripidx << endl;
	tripFound = false;
	for(int i = 1; i <= tripcnt; i++){
		// if(DEBUG == 1) gse << "The removed index is " << ts_tab[j][clusterid][i] << endl;
		if(ts_tab[timeslot][clusterid][UNASSIGNED][i] == tripidx){
			tripFound = true;
			for(int k = i; k <= tripcnt; k ++){
				ts_tab[timeslot][clusterid][UNASSIGNED][k] = ts_tab[timeslot][clusterid][UNASSIGNED][k+1];
			}
			break;
		}

	}
	if(tripFound){
		ts_tab[timeslot][clusterid][UNASSIGNED][0] = tripcnt-1;
		ts_tab[timeslot][clusterid][UNASSIGNED][tripcnt] = 0;
	}

	//  if(DEBUG == 1) gse << "Cleared Slack for Trip "<< tripidx << " for clusterid " << clusterid << " in " << endtimer(starttm, MONITOR) << " seconds " << endl;
}


//MP: If the trip is in the slack array then do not update
//    segstart is the index where the slack is
int updateSlack(int t1, int t2, int cid, int segstart, int isslack){

	//int starttm = starttimer(MONITOR1);
	int clusteridx;

	// MP: Loop through all the timeslots between t1 and t2. and update the slack for those clusters
	for(int t = t1; t <=t2; t++){
		clusteridx  = insertTrip(t, cid, segstart, isslack);
		//ts_tab[t][cid][0] = segstart;

		//if(strcmp(schd_tab[segstart][0], "S1001")==0)
		// if(DEBUG == 1) gse << t << " " << cid << " " << segstart << endl;
	}

	//tc_tab[cid][tc_tab[cid][0]+1] = segstart;
	//   if(DEBUG == 1) gse << "Updated Slack for seg "<< segstart << " for clusterid " << cid << " in " << endtimer(starttm, MONITOR) << " seconds " << endl;
	return 1;
}

void updateDatabase(int cnt, int index, Environment* env, Connection* conn, char (*schd_tab)[TRIPCOLSIZE][MAXLGSTRSIZE],int (*s_tab)[MAXSTOPS], string table_itms_segments,string table_itms_trips){
	string temp;
	string perf_time;
	string timetonextstop;
	string eta;
	string etd;
	string amb_occ;
	string wc_occ;
	char updatebuffer[916];
	string dist;
	string tripid;
	string prom_time;
	string stopnum;

	// if(DEBUG == 1) gse << schd_tab[s_tab[index][1]][0] << " " << cnt << " " << index  << endl;



	for(int i = 1; i < cnt+1; i++){

		//    if(DEBUG == 1) gse << "PU AMB " <<schd_tab[i][31] << endl;

		prom_time = schd_tab[s_tab[index][i]][4];
		stopnum = schd_tab[s_tab[index][i]][2];
		perf_time = schd_tab[s_tab[index][i]][25];

		timetonextstop = schd_tab[s_tab[index][i]][28];
		eta = schd_tab[s_tab[index][i]][29];
		//temp = temp+",";
		etd = schd_tab[s_tab[index][i]][30];
		// if(DEBUG == 1) gse << "TEMP " << b_time1[i] <<endl;
		amb_occ =  schd_tab[s_tab[index][i]][31];
		wc_occ =  schd_tab[s_tab[index][i]][32];
		dist = schd_tab[s_tab[index][i]][6];
		tripid = schd_tab[s_tab[index][i]][3];
		//   times  =  p_promised_time +","+est_traveltime1 +","+arrivetime1 +","+ departtime1 +","+to_string(p_perf_time) +","+starttime1 +","+endtime1 +","+to_string(p_timetonextstop) +","+to_string(itms_to_minutes (ampm2fullhrs (p_eta))); +","+to_string(itms_to_minutes (ampm2fullhrs (p_etd)));
		string command;

		//   if(DEBUG == 1) gse << "stop " << schd_tab[s_tab[index][i]][2] <<  " " << s_tab[index][i] << endl;

		if (strcmp(schd_tab[s_tab[index][i]][2],"1") == 0 ){

			sprintf(updatebuffer, "UPDATE %s set pu_etd = %s,pu_eta = %s, pu_disttonextstop=%s where SEGMENTID = '%s' AND TRAVEL_DATE = '%s'"
					,table_itms_segments.c_str(), prom_time.c_str(),to_string((int)to_number(prom_time)-15).c_str(), dist.c_str(), tripid.c_str(),schd_tab[s_tab[index][i]][1] );


		}
		else if /*(strcmp(schd_tab[i][2],"1") == 0 ||*/ (strcmp(schd_tab[s_tab[index][i]][2],MAXSTOPNUM[0]) == 0 ){

			sprintf(updatebuffer, "UPDATE %s set do_timetonextstop = %s,  do_disttonextstop = %s,  do_eta = %s, do_etd = %s where SEGMENTID = '%s' AND TRAVEL_DATE = '%s'"
					,table_itms_segments.c_str(), timetonextstop.c_str(),dist.c_str(),eta.c_str(),eta.c_str(),tripid.c_str(),schd_tab[s_tab[index][i]][1] );

			// if(DEBUG == 1) gse << updatebuffer << endl;

		}

		else if(strcmp(schd_tab[s_tab[index][i]][7],"P")==0 && strcmp(schd_tab[s_tab[index][i]][2],"1")!=0 && strcmp(schd_tab[s_tab[index][i]][2],"999")!=0  ){


			sprintf(updatebuffer, "UPDATE %s set pu_stop = %s, pu_perf_time = %s, pu_eta = %s, pu_etd = %s, pu_amb_occ = %s, pu_wc_occ = %s, pu_disttonextstop = %s, pu_timetonextstop = %s, SYSTEM_USER = '%s' where tripid = '%s'"
					,table_itms_trips.c_str(), stopnum.c_str(),  perf_time.c_str(),eta.c_str(),etd.c_str(),amb_occ.c_str(),wc_occ.c_str(),dist.c_str(), timetonextstop.c_str(),"SHM", /*std::chrono::system_clock::now()"05-JAN-2018"*/tripid.c_str() );

		}

		else if (strcmp(schd_tab[s_tab[index][i]][7],"D")==0 && strcmp(schd_tab[s_tab[index][i]][2],"1")!=0 && strcmp(schd_tab[s_tab[index][i]][2],"999")!=0  ) {
			sprintf(updatebuffer, "UPDATE %s set do_stop = %s, do_perf_time = %s, do_eta = %s, do_etd = %s, do_amb_occ = %s, do_wc_occ = %s , do_disttonextstop = %s, do_timetonextstop = %s,SYSTEM_USER = '%s' where tripid = '%s'"
					,table_itms_trips.c_str(), stopnum.c_str(), perf_time.c_str(),eta.c_str(),etd.c_str(), amb_occ.c_str(),wc_occ.c_str(),dist.c_str(), timetonextstop.c_str(), "SHM", /*std::chrono::system_clock::now() "05-JAN-2018"*/tripid.c_str() );
		}


		command = updatebuffer;
		if(DEBUG == 1) gse << command << ";"<< endl;
		//  if(DEBUG == 1) gse << "OCCI command \n" <<command <<endl;

		Statement* stmt = conn->createStatement (command);
		stmt->executeUpdate();
		conn->commit();
		///////////stmt->closeResultSet(rset);
		conn->terminateStatement(stmt);

		//  if(DEBUG == 1) gse << i << " finishing update statement " << cnt << endl;

	}

}

int lst[1][MAXSTOPS];







bool recalcUpFB(string (*temproute)[MAXSTOPS][TRIPCOLSIZE], int start_loc){

	/*

    string temproute1[MAXSTOPS][TRIPCOLSIZE] = (*temproute);
    //  if(DEBUG == 1) gse << "In recalc up " << endl;
    string etd = (*temproute)[start_loc+1][30];
    string perf = (*temproute)[start_loc+1][25];
    string ttns = (*temproute)[start_loc+1][28];
    string perf2 = (*temproute)[start_loc][25];
    string eta2 = (*temproute)[start_loc][29];
    string earliest2 = (*temproute)[start_loc][EARLIEST_ARR];
    string returntrip = (*temproute)[start_loc][18];
    string act_arr = (*temproute)[start_loc][23];
    string act_dep = (*temproute)[start_loc][24];
    string eta = (*temproute)[start_loc+1][29];
    string promtime = (*temproute)[start_loc+1][4];

int n_etd = (int)to_number(etd) - (int)to_number(perf) - (int)to_number(ttns);
int n_eta = n_etd - (int)to_number(perf2);

if((int)to_number(act_arr) <= 0 || (int)to_number(act_dep) <= 0 ){

if((int)to_number(eta2) >= n_eta && n_eta >= (int)to_number(earliest2) && "N" == returntrip){

    //  if(DEBUG == 1) gse << "not a return " << endl;

    (*temproute)[start_loc][29] = to_string(n_eta);
    (*temproute)[start_loc][4] = to_string(n_eta);


    string eta3 = (*temproute)[start_loc-1][29];
    string stopnum2 = (*temproute)[start_loc][2];
    string promtime2  = (*temproute)[start_loc][4];
    string starttime2 = (*temproute)[start_loc][26];



    if((int)to_number(eta3) > (int)to_number(eta2) && (int)to_number(stopnum2)!= 1){
        recalcUpFB(&(temproute1), start_loc-1);
    }
    if((int)to_number(stopnum2)== 1 && (int)to_number(promtime2) < (int)to_number(starttime2)){
           if(DEBUG == 1) gse << "Not a return trip 22 : " << promtime2 << " < " << starttime2 << " " << stopnum2 << endl;
        return false;
    }
    else  {
           if(DEBUG == 1) gse << "Not a return trip 11 : " << eta3 << " < " << eta2 << " " << stopnum2 << endl;
        return true;
    }
}

else if ((int)to_number(eta2) < n_eta && "N" == returntrip || n_eta < (int)to_number(earliest2) && "N" == returntrip) {
      if(DEBUG == 1) gse << "Is not a return trip and " +to_string(n_eta)+ " < " + earliest2 + "or "  +eta2+ " < " + to_string(n_eta) + " with stop num "  << (*temproute)[start_loc][2] <<
    " " << etd << " - " << perf << " - " << ttns << " new eta " << n_etd << " - " << perf2 <<   endl;
    return false;
    }





else if("Y" == returntrip  && (int)to_number(eta) >  (int)to_number(promtime)){
   //   if(DEBUG == 1) gse << "Is a return trip " << endl;
    string etd2 = (*temproute)[start_loc][30];
    string ttns2 = (*temproute)[start_loc][28];
    n_eta =  (int)to_number(etd2) + (int)to_number(ttns2);
    string latest =(*temproute)[start_loc+1][LATEST_DEP];

    if((int)to_number(latest) >= n_eta){
        (*temproute)[start_loc+1][4] =  to_string(n_eta);
        (*temproute)[start_loc+1][29] = to_string(n_eta);

        return true;
    }

    else{
            if(DEBUG == 1) gse << "Is a return trip and " +to_string(n_eta)+ " > " +latest << endl;
        return false;
    }

}

}
else {
      if(DEBUG == 1) gse << "There is an actual arrival or departure time: can't change" << endl;
    return false;
}*/

	return false;

}





//void recalcUpBatch(int * local_s_tab, int segstart, string table_itms_segments, string table_itms_trips){}






void recalcons_tab(string a_route , Environment* env, Connection* conn, string table_itms_segments, string table_itms_trips, int segstart){

	bool updatedb = true;
	//string p_customer;
	std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>  varHolder;
	string p_customer;
	bool notFound;
	int f1 = 0;
	int f2 = 0;
	std::string  promisedtime1;
	int prom_time;
	std::string est_traveltime1;
	std::string arrivetime1;
	std::string departtime1 ;
	std::string perftime1 ;
	int p_perf_time;
	std::string starttime1 ;
	std::string endtime1;
	std::string timetonextstop1 ;
	std::string eta1 ;
	int eta;
	std::string etd1; /// fix this hack in get next token

	int etd;
	std::string  lat1  ;
	std::string lon1   ;
	std::string lat2 ;
	std::string lon2; /// fix this hack in get next token
	std::string  amb_occ1 ;
	std::string wc_occ1 ;
	int cs_cap = 0;
	int bs_cap = 0;
	std::string amb_cap1 ;
	std::string wc_cap1 ; /// fix this hack in get next token
	int p_amb_occ;
	int p_wc_occ;
	int p_cs_occ;
	int p_bs_occ;
	int p_grp_cnt_wc;
	int p_grp_cnt_amb;
	int s_trip_appt_time = 0;
	int p_latency = 0;
	int p_prev_stop_num;
	int p_prev_perf_time;
	int OffLoaded;
	string p_trip_type ;
	string p_spl_other_desc ;
	int last_wc_occ = 0, last_cs_occ = 0, last_bs_occ = 0;
	int last_amb_occ = 0;
	int last_dep_time ;
	int last_arr_time ;
	int tot_driv_time = 0;
	double tot_miles = 0;
	string p_latestoptime ="";
	string p_earlystoptime= "";
	double p_disttonextstop = 0.0;
	int p_timetonextstop = 0;
	string p_name ;
	string p_return_trip ;
	string p_stop_type ;
	//junk p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time;
	//junk p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc , OffLoaded   , p_trip_type ;    //tofix p_
	string p_disability = "" ;
	int p_esc;
	string p_td_segmentid = "";
	int stopnum1;
	int p_stop_num;
	int p_early_morning_factor = 0;
	string p_street_by_street = "T";
	string p_citytown;
	string time_zone2 = "*";
	string time_zone;// = "*";
	int petaint;
	string rteStr;
	double disttrav;
	string grp_cnt_amb;
	string grp_cnt_wc;
	string dist;
	string p_promised_time;
	string p_eta;
	string p_etd;
	string scity;
	string dcity;
	string p_stop_type2;
	string latlongs;
	string capacity;
	string times;
	string prev_perftime1,prev_eta1,prev_etd1, prev_amb_occ1, prev_wc_occ1;
	int prev_eta,prev_etd,prev_p_perf_time;
	int index;
	int cnt = 0;
	double disttrav2;
	bool recalc = false;
	double prev_distance = 0;
	int indexstart;
	int AGRPCOUNTER = 0;
	int APRVGRPCOUNTER = 0;
	string p_prev_promised_time = "0000A";
	int timetonextstop2 = 0;


	cnt = 0;

	if(DEBUG == 1) gse << "\nCalculating for " << a_route << endl;
	std::clock_t start2 = std::clock();
	int i = segstart;

	//if(strcmp ( schd_tab[i][0], argv[2] ) == 0){
		//(int)to_number(schd_tab[i][0].substr(1,schd_tab[i][0].length()))

	if(DEBUG == 1) gse << "There was a violations for route so recalculating original:  " << a_route << endl;


	int routeint = (int)to_number(a_route.substr(1,a_route.length()));


	/*for(int k = 1;k < MAXSTOPS; k++){
                     if(s_tab[i][k]==0){break;}
                       if(DEBUG == 1) gse << s_tab[i][k] << endl;
                }*/

	//   if(DEBUG == 1) gse << routeint << endl;
	//   if(DEBUG == 1) gse << s_tab[i][0] << endl;


	if(s_tab[i][0]==routeint){


		int local_s_tab[MAXSTOPS];
		int counter = 0;

		for(int y = 1; y < MAXSTOPS; y++){
			if(s_tab[i][y] ==0)
				break;
			local_s_tab[counter] = s_tab[i][y];
			counter++;

		}

		if(DEBUG == 1) gse << "The counter is " << counter << endl;

		//create_group(local_s_tab,counter);

		int grouptraveltimeallowance[MAXTRIPIDX];


		for(int y = 0; y < MAXTRIPIDX; y++){
			grouptraveltimeallowance[y] = 0;
		}
		int extratraveltime = 0;
		int groupid = 1;
		bool secondpassinsertedtrip = false;

		for(int y = 0; y < counter;y++){

			string groupmark = schd_tab[local_s_tab[y]][GRPIDX];


			if(strcmp(schd_tab[local_s_tab[y]][2],MAXSTOPNUM[0])!=0){
				if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"D")==0 && groupmark!= "" ){
					//strcpy(schd_tab[local_s_tab[y]][GRPIDX],to_string(groupid).c_str());
					//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[y]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
					int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
					grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
				}
				if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"P")==0 && groupmark!= "" ){
					groupid++;
				}
			}

		}

		//bool isVol = isVolSegment(schd_tab[s_tab[i][1]][0], schd_tab[s_tab[i][1]][1],schd_tab[s_tab[i][1]][14]);
		getCS_CY_cap(cs_cap, bs_cap, schd_tab[s_tab[i][1]][SEGMENTTYPE]);

		indexstart = i;
		//   if(DEBUG == 1) gse << "Here" <<endl;
		for(int k = 1; k < MAXSTOPS; k++){

			//    if(DEBUG == 1) gse << "Test " << s_tab[i][k] << endl;
			if(s_tab[i][k]==0){break;}

			p_stop_num = (int)to_number(schd_tab[s_tab[i][k]][2]);

			if(p_stop_num == 1){
				index = s_tab[i][k];
				cnt = 0;
				//   if(DEBUG == 1) gse << "Stop " << schd_tab[s_tab[i][k]][2] <<endl;
				disttrav = to_number(schd_tab[s_tab[i][k]][6]);
				dist = schd_tab[s_tab[i][k]][6];//////////////////////////////////move distance to after loop when finished converting binary tree function as
				////////////// because it stores the NEXT distance as distance FROM.


				//temp = schd_tab[s_tab[i][k]][4];
				promisedtime1 = schd_tab[s_tab[i][k]][4];
				prom_time =(int)to_number(promisedtime1);
				//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
				p_promised_time = itms_minutes_to_ampm(prom_time);
				est_traveltime1 = schd_tab[s_tab[i][k]][22];
				arrivetime1 =schd_tab[s_tab[i][k]][23];
				arrivetime1 = padStr( arrivetime1);
				departtime1 =schd_tab[s_tab[i][k]][24];
				departtime1 = padStr(departtime1);
				perftime1 = schd_tab[s_tab[i][k]][25];
				//perftime1 = padStr(perftime1);
				p_perf_time = (int)to_number(perftime1);
				starttime1 = schd_tab[s_tab[i][k]][26];
				starttime1  = padStr(starttime1 );
				endtime1 = schd_tab[s_tab[i][k]][27];
				endtime1 = padStr(endtime1);
				s_trip_appt_time = (int)to_number(endtime1);
				timetonextstop1 = schd_tab[s_tab[i][k]][28];
				eta1 = schd_tab[s_tab[i][k]][29];
				eta = (int)to_number(eta1);
				eta1 = itms_minutes_to_ampm(eta);

				etd1 = schd_tab[s_tab[i][k]][30]; /// fix this hack in get next token
				etd = (int)to_number(etd1);
				etd1 = itms_minutes_to_ampm(etd);
				//temp = schd_tab[s_tab[i][k]][10];
				lat1 =  schd_tab[s_tab[i][k]][10];
				lon1 =  schd_tab[s_tab[i][k]][37];
				lat2 =  schd_tab[s_tab[i][k]][38];

				lon2 = schd_tab[s_tab[i][k]][39]; /// fix this hack in get next token
				// temp = schd_tab[s_tab[i][k]][12];
				amb_occ1 =  schd_tab[s_tab[i][k]][31];
				wc_occ1 =  schd_tab[s_tab[i][k]][32];
				p_cs_occ = to_number(schd_tab[s_tab[i][k]][CS_OCC]);
				p_bs_occ =to_number(schd_tab[s_tab[i][k]][BS_OCC]);
				amb_cap1 =  schd_tab[s_tab[i][1]][33];

				//temp = temp+",";
				wc_cap1 =  schd_tab[s_tab[i][1]][34]; /// fix this hack in get next token
				grp_cnt_amb = schd_tab[s_tab[i][k]][35];
				p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
				grp_cnt_wc = schd_tab[s_tab[i][k]][36];
				p_grp_cnt_wc = (int)to_number(grp_cnt_wc);
				p_trip_type = schd_tab[s_tab[i][k]][8];
				p_spl_other_desc = schd_tab[s_tab[i][k]][9];
				last_dep_time = prom_time;
				last_arr_time = prom_time;
				p_name = schd_tab[s_tab[i][k]][14];
				p_return_trip = schd_tab[s_tab[i][k]][18];
				p_stop_type = schd_tab[s_tab[i][k]][7];

				disttrav = (int)to_number(schd_tab[s_tab[i][k]][6]);
				dist = schd_tab[s_tab[i][k]][6];
				//////////////////////////////////move distance to after loop when finished converting binary tree function as
				////////////// because it stores
				p_esc = (int)to_number(schd_tab[s_tab[i][k]][13]);
				p_td_segmentid = schd_tab[s_tab[i][k]][0];

				//  if(DEBUG == 1) gse << "The segment is for recalc " << p_td_segmentid << " " <<  schd_tab[s_tab[i][k]][0] << endl;

				p_stop_num = (int)to_number(schd_tab[s_tab[i][k]][2]);
				p_citytown = schd_tab[s_tab[i][k]][11];

				p_eta = eta1;
				p_etd = etd1;

			}



			//temp = schd_tab[s_tab[i][k]][4];
			promisedtime1 = schd_tab[s_tab[i][k]][4];
			prom_time =(int)to_number(promisedtime1);

			p_promised_time = itms_minutes_to_ampm(prom_time);
			est_traveltime1 = schd_tab[s_tab[i][k]][22];
			arrivetime1 =schd_tab[s_tab[i][k]][23];
			arrivetime1 = padStr( arrivetime1);
			departtime1 =schd_tab[s_tab[i][k]][24];
			departtime1 = padStr(departtime1);
			perftime1 = schd_tab[s_tab[i][k]][25];
			//perftime1 = padStr(perftime1);
			p_perf_time = (int)to_number(perftime1);
			starttime1 = schd_tab[s_tab[i][k]][26];
			starttime1  = padStr(starttime1 );
			endtime1 = schd_tab[s_tab[i][k]][27];
			endtime1 = padStr(endtime1);
			s_trip_appt_time = (int)to_number(endtime1);
			timetonextstop1 = schd_tab[s_tab[i][k]][28];
			eta1 = schd_tab[s_tab[i][k]][29];
			eta = (int)to_number(eta1);
			eta1 = itms_minutes_to_ampm(eta);

			etd1 = schd_tab[s_tab[i][k]][30]; /// fix this hack in get next token
			etd = (int)to_number(etd1);
			etd1 = itms_minutes_to_ampm(etd);
			//temp = schd_tab[s_tab[i][k]][10];
			lat1 =  schd_tab[s_tab[i][k]][10];
			lon1 =  schd_tab[s_tab[i][k]][37];
			lat2 =  schd_tab[s_tab[i][k]][38];

			lon2 = schd_tab[s_tab[i][k]][39]; /// fix this hack in get next token
			// temp = schd_tab[s_tab[i][k]][12];
			amb_occ1 =  schd_tab[s_tab[i][k]][31];
			wc_occ1 =  schd_tab[s_tab[i][k]][32];
			p_cs_occ = to_number(schd_tab[s_tab[i][k]][CS_OCC]);
			p_bs_occ =to_number(schd_tab[s_tab[i][k]][BS_OCC]);
			amb_cap1 =  schd_tab[s_tab[i][1]][33];
			//temp = temp+",";
			wc_cap1 =  schd_tab[s_tab[i][1]][34]; /// fix this hack in get next token
			grp_cnt_amb = schd_tab[s_tab[i][k]][35];
			p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
			grp_cnt_wc = schd_tab[s_tab[i][k]][36];
			p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

			p_disability = schd_tab[s_tab[i][k]][12];
			//p_amb_occ = to_number(amb_occ1);
			//p_wc_occ = to_number(wc_occ1);
			p_trip_type = schd_tab[s_tab[i][k]][8];
			p_spl_other_desc = schd_tab[s_tab[i][k]][9];
			//last_dep_time = prom_time;
			//last_arr_time = prom_time;
			p_name = schd_tab[s_tab[i][k]][14];
			p_return_trip = schd_tab[s_tab[i][k]][18];
			p_stop_type = schd_tab[s_tab[i][k]][7];
			p_esc = (int)to_number(schd_tab[s_tab[i][k]][13]);
			p_td_segmentid = schd_tab[s_tab[i][k]][0];


			if (p_stop_num == 1){
				last_dep_time = prom_time;
				last_arr_time = prom_time;
			}
			if(p_stop_num != 1){
				prev_distance = to_number( schd_tab[s_tab[i][k-1]][6]);
				timetonextstop2 = to_number( schd_tab[s_tab[i][k-1]][28]);

			}

			disttrav = to_number( schd_tab[s_tab[i][k]][6]);


			p_citytown = schd_tab[s_tab[i][k]][11];

			p_eta = eta1;
			p_etd = etd1;



			//   if(DEBUG == 1) gse << "STOP TYPE  " <<  p_stop_type << endl;
			int p_WHEELLOAD1;
			int p_AMBLOAD1;
			int p_MAXEARLYDROPOFFFACTOR1;
			int p_DIALRIDEEARLYPICKFACTOR1;
			int p_DIALRIDELATEPICKFACTOR1;
			int p_OTHEREARLYPICKFACTOR1;
			int p_OTHERLATEPICKFACTOR1;
			string IGNOREPUTIMES1;
			int p_SHORTBREAK1;
			int p_LUNCHBREAK1;
			int p_PROXIMITYFACTOR1;
			int a_mediumshortdistance1;
			int a_mediumlongdistance1;
			int a_shorttriptime1;
			int a_longtriptime1;
			int a_mediumtriptime1;
			int a_extra_loadtime1;
			string ZONE_DESCR1;
			string IGNORE_DEPOTS_CUTOFF1;


			int grouppickupcnt = 0;

			string groupmark = schd_tab[s_tab[i][k]][GRPIDX];
			if(groupmark != ""){
				int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
				grouppickupcnt = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
				//  if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
			}






			string pReturn_trip = schd_tab[s_tab[i][k]][18];
			string  pDisability = schd_tab[s_tab[i][k]][12];
			string p_trip_type1 = schd_tab[s_tab[i][k]][8];


			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability, p_trip_type1);

			double estdisttrip = to_number(schd_tab[s_tab[i][k]][21]);

			int aAllowedTT;



			if(estdisttrip < a_mediumshortdistance1)
				aAllowedTT = a_shorttriptime1 + grouppickupcnt;
			else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1))
				aAllowedTT = a_mediumtriptime1 + grouppickupcnt;
			else
				aAllowedTT = a_longtriptime1 + grouppickupcnt;

			if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
				aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
			}





			int p_perf_time;
			string pDisposition = schd_tab[s_tab[i][k]][DISPOSITION];
			set_p_perf_time(pDisposition,pDisability, p_perf_time, p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1 );

			int est_time;
			string tripid = schd_tab[s_tab[i][k]][3];
			tripid = tripid.substr(0,1);
			string endtime2;
			if(tripid == "S"){
				endtime2 =to_string( (int)itms_to_minutes(ampm2fullhrs(p_promised_time)));
			}

			if(p_stop_type == "P"){
				if((int)to_number(starttime1)!= 0)
					est_time = (int)to_number(starttime1);
				else{
					est_time =  (int)to_number(endtime2) - (int)to_number(est_traveltime1);
				}
			}
			else{
				if((int)to_number(endtime2)!= 0)
					est_time = (int)to_number(endtime2);
				else{

					est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
				}
			}

			string timezonetime = itms_minutes_to_ampm(est_time);
			//p_eta = eta1;
			if(p_stop_num ==1){
				p_eta = p_promised_time;
				p_etd = etd1;
			}
			else{
				p_eta = eta1;
				p_etd = etd1;
			}
			string route = schd_tab[s_tab[i][k]][0];
			if( (route == "" || timeZones(p_eta, timezonetime) != timeZones(timezonetime,p_eta))  && !secondpassinsertedtrip){time_zone = timeZones(p_eta, timezonetime); secondpassinsertedtrip = true;}
			else{  if(F_GET_TRAVEL_TIME (1.0 , timeZones(p_eta, timezonetime), "*") > F_GET_TRAVEL_TIME (1.0 , timeZones(timezonetime,p_eta), "*")){
				time_zone = timeZones(p_eta, timezonetime);secondpassinsertedtrip = false;
			}
			else{
				time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
			}
			//time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
			}
			//time_zone = timeZones(p_eta, timezonetime);
			string timezone2;
			if (p_stop_num != 1) {
				if (!isSameLocation(s_tab[i][k],s_tab[i][k - 1]))
					timezone2 = "#"; // not the same lat/long
				else
					timezone2 = "*";
			}








			varHolder = itms_calcroute( arrivetime1, departtime1,timetonextstop2,  rteStr ,   p_citytown ,     p_street_by_street ,     p_eta  ,    p_promised_time ,     p_perf_time ,   p_early_morning_factor ,  p_stop_num ,
					p_td_segmentid,  p_wc_occ   , p_amb_occ,   p_esc  ,  p_disability  , p_stop_type  ,  p_WHEELLOAD[0] ,  p_AMBLOAD[0] ,
					p_customer ,   p_return_trip  ,  p_DIALRIDEEARLYPICKFACTOR[0]  ,  p_DIALRIDELATEPICKFACTOR[0] ,  p_PROXIMITYFACTOR[0],  p_SHORTBREAK[0]  ,
					p_LUNCHBREAK[0]   ,   p_MAXEARLYDROPOFFFACTOR[0]  , p_OTHEREARLYPICKFACTOR[0]  ,  p_OTHERLATEPICKFACTOR[0] ,   p_name    ,
					p_timetonextstop , p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
					OffLoaded   , p_trip_type ,    p_prev_perf_time ,   p_prev_stop_num , p_latency   ,  s_trip_appt_time ,  p_grp_cnt_amb ,
					p_grp_cnt_wc,  ignorepu[0],  IGNORE_DEPOTS_CUTOFF[0], time_zone, timezone2, starttime1,p_cs_occ,p_bs_occ,last_cs_occ,last_bs_occ,pDisposition);






			p_eta = std::get<0>(varHolder);
			p_wc_occ=std::get<1>(varHolder);
			p_amb_occ=std::get<2>(varHolder);
			p_esc=std::get<3>(varHolder);
			p_timetonextstop=std::get<4>(varHolder);
			p_disttonextstop=std::get<5>(varHolder);
			p_earlystoptime=std::get<6>(varHolder);
			p_latestoptime=std::get<7>(varHolder);
			tot_miles=std::get<8>(varHolder);
			tot_driv_time=std::get<9>(varHolder);
			p_etd=std::get<10>(varHolder);
			OffLoaded=std::get<11>(varHolder);
			p_perf_time = std::get<12>(varHolder);
			p_cs_occ = std::get<13>(varHolder);
			p_bs_occ = std::get<14>(varHolder);

			if(!secondpassinsertedtrip){
				p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs(p_etd)) - p_perf_time);

				if (p_stop_num != 1 && p_stop_num !=(int)to_number(MAXSTOPNUM[0])) {
					if (timetonextstop2 == 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0)

						AGRPCOUNTER = AGRPCOUNTER + 1;
					else{
						if (AGRPCOUNTER > 0  && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0)
						{
							APRVGRPCOUNTER = AGRPCOUNTER + 1;
						}
						AGRPCOUNTER = 0;
					}


					if(p_disability.find("WC",0) == string::npos && p_disability.find("SC",0) == string::npos && p_disability.find("XLT",0) == string::npos){


						if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0){

							//  if(DEBUG == 1) gse << "petd changing " << p_etd << endl;

							p_perf_time = p_perf_time / AGRPCOUNTER;
						}


						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0) {

							p_perf_time = p_perf_time / APRVGRPCOUNTER;
							APRVGRPCOUNTER = 0;
						}
					}
					else{

						if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


							if (AGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0) {

								p_perf_time = p_perf_time / AGRPCOUNTER;
							}

							if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[s_tab[i][k]][7],schd_tab[s_tab[i][k-1]][7])==0) {

								p_perf_time = p_perf_time / APRVGRPCOUNTER;
								APRVGRPCOUNTER = 0;
							}
						}
					}

				}
				p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) + p_perf_time);
				//   if(DEBUG == 1) gse << "petd changing after " << p_etd << endl;
			}

			if(p_stop_type  == "P"){
				string tripidforwait = schd_tab[s_tab[i][k]][3];
				int DW = getDWByStop (tripidforwait, p_stop_type ,itms_to_minutes(ampm2fullhrs (p_eta)) , itms_to_minutes (ampm2fullhrs(p_etd)),(int)to_number(starttime1),p_perf_time);
				int PW = getPWByStop (tripidforwait,  p_stop_type  ,itms_to_minutes(ampm2fullhrs (p_eta))    , (int)to_number(starttime1));
				strcpy(schd_tab[s_tab[i][k]][DWWAIT], to_string(DW).c_str());
				strcpy(schd_tab[s_tab[i][k]][PWWAIT], to_string(PW).c_str());
			}
			else{
				int eta = itms_to_minutes (ampm2fullhrs (p_eta));
				int etd = (int)to_number(schd_tab[s_tab[i][k-1]][30]);
				int TT = (int)to_number(schd_tab[s_tab[i][k-1]][CALCULATEDTIME]);
				string tripidforwait = schd_tab[s_tab[i][k]][3];
				int DW = eta - etd + TT;
				int PW = getPWByStop (tripidforwait,  schd_tab[s_tab[i][k]][7],eta, (int)to_number(endtime1));
				strcpy(schd_tab[s_tab[i][k]][DWWAIT],to_string(DW).c_str());
				strcpy(schd_tab[s_tab[i][k]][PWWAIT],to_string(PW).c_str());
			}



			//capacity  = to_string(p_amb_occ)+ ","+ to_string(p_wc_occ)+","+ amb_cap1+","+ wc_cap1+ "," +to_string(p_grp_cnt_amb) +","+ to_string(p_grp_cnt_wc)+","+ p_disability;
			//times  =  to_string(itms_to_minutes (ampm2fullhrs ( p_promised_time))) +","+est_traveltime1 +","+arrivetime1 +","+ departtime1 +","+to_string(p_perf_time) +","+starttime1 +","+endtime1 +","+to_string(p_timetonextstop) +","+to_string(itms_to_minutes (ampm2fullhrs (p_eta))) +","+to_string(itms_to_minutes (ampm2fullhrs (p_etd)));


			strcpy((schd_tab[s_tab[i][k]][4]) , to_string(itms_to_minutes (ampm2fullhrs (p_promised_time))).c_str());

			strcpy((schd_tab[s_tab[i][k]][22]) , est_traveltime1.c_str());

			strcpy((schd_tab[s_tab[i][k]][23]) , arrivetime1.c_str());

			strcpy((schd_tab[s_tab[i][k]][24]) , departtime1.c_str());

			strcpy((schd_tab[s_tab[i][k]][25]) , to_string(p_perf_time).c_str());

			strcpy((schd_tab[s_tab[i][k]][26]) , starttime1.c_str());

			strcpy((schd_tab[s_tab[i][k]][27]) , endtime1.c_str() );
			if(k > 1){
				strcpy((schd_tab[s_tab[i][k-1]][28]) , to_string(timetonextstop2).c_str());
				strcpy((schd_tab[s_tab[i][k-1]][CALCULATEDTIME]) , to_string(p_timetonextstop).c_str());

			}


			strcpy((schd_tab[s_tab[i][k]][29]) , to_string(itms_to_minutes (ampm2fullhrs (p_eta))).c_str());

			strcpy((schd_tab[s_tab[i][k]][30]) ,to_string(itms_to_minutes (ampm2fullhrs (p_etd))).c_str());

			strcpy((schd_tab[s_tab[i][k]][31]) , to_string(p_amb_occ).c_str());

			strcpy((schd_tab[s_tab[i][k]][32]) , to_string(p_wc_occ).c_str());
			strcpy((schd_tab[s_tab[i][k]][CS_OCC]), to_string(p_cs_occ).c_str());
			strcpy((schd_tab[s_tab[i][k]][BS_OCC]), to_string(p_bs_occ).c_str());
			//strcpy((schd_tab[s_tab[i][k]][DIRTYBIT]) , ("Y"));

			strcpy( schd_tab[s_tab[i][k]][38], schd_tab[s_tab[i][k+1]][10]);
			strcpy( schd_tab[s_tab[i][k]][39], schd_tab[s_tab[i][k+1]][37]);


			prev_eta1 = schd_tab[s_tab[i][k]][29];
			prev_eta = (int)to_number(prev_eta1);
			prev_eta1 = itms_minutes_to_ampm(prev_eta);


			int t = k;
			string timezone3;
			if (p_stop_num != 1) {
				if (!isSameLocation(s_tab[i][t],s_tab[i][t-1]))
					timezone3 = "#"; // not the same lat/long
					else
						timezone3 = "*";


				string tripid = schd_tab[s_tab[i][t-1]][3];
				if(timezone3 == "*" && strcmp(schd_tab[s_tab[i][t-1]][7], schd_tab[s_tab[i][t]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[s_tab[i][t-1]][41], schd_tab[s_tab[i][t]][41])==0){
					strcpy(  schd_tab[s_tab[i][t]][29] ,schd_tab[s_tab[i][t-1]][29]);
					int l = t;
					tripid = schd_tab[s_tab[i][l]][3];
					while(isSameLocation(s_tab[i][l],s_tab[i][l-1]) && strcmp(schd_tab[s_tab[i][l-1]][7], schd_tab[s_tab[i][l]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[s_tab[i][l-1]][41], schd_tab[s_tab[i][l]][41])==0){
						strcpy(  schd_tab[s_tab[i][l-1]][30] , schd_tab[s_tab[i][l]][30]);
						l--;
						tripid = schd_tab[s_tab[i][l]][3];
						if(l == 1)
							break;
					}
				}
			}

			if(secondpassinsertedtrip){  if(DEBUG == 1) gse << "REDOING" << endl; k--;continue;}


			prev_perftime1 = schd_tab[s_tab[i][k]][25];
			prev_p_perf_time = (int)to_number(prev_perftime1);


			prev_etd1 = schd_tab[s_tab[i][k]][30]; /// fix this hack in get next token
			prev_etd = (int)to_number(prev_etd1);
			prev_etd1 = itms_minutes_to_ampm(prev_etd);
			//temp = schd_tab[s_tab[i][k]][12];
			prev_amb_occ1 =  schd_tab[s_tab[i][k]][31];
			prev_wc_occ1 =  schd_tab[s_tab[i][k]][32];
			last_dep_time=prev_etd;
			last_arr_time=prev_eta;
			string prev_cs_occ = schd_tab[s_tab[i][k]][CS_OCC];
			string prev_bs_occ = schd_tab[s_tab[i][k]][BS_OCC];
			last_cs_occ=to_number(prev_cs_occ);
			last_bs_occ=to_number(prev_bs_occ);
			last_amb_occ=(int)to_number(prev_amb_occ1);
			last_wc_occ=(int)to_number(prev_wc_occ1);
			p_prev_perf_time = prev_p_perf_time;
			p_prev_stop_num = (int)to_number(schd_tab[s_tab[i][k]][2]);
			p_prev_promised_time = p_promised_time;




			//strcpy((schd_tab[s_tab[i][k]][6]) ,to_string(disttrav).c_str());

			//slack_calc(s_tab[i][k], schd_tab);

			//  if(DEBUG == 1) gse << "Slack " << schd_tab[s_tab[i][k]-1][40] << endl;


			//   if(DEBUG == 1) gse << schd_tab[s_tab[i][k]][31] << endl;





			//if(p_stop_num != 999)
			cnt++;




			if(DEBUG == 1) gse << p_stop_num << " \t " << p_promised_time << " \t " << p_eta << " \t " << p_etd << " \t "  << setprecision(2) << prev_distance <<  "  \t" << p_timetonextstop << " \t " << p_stop_type << "\t " << p_wc_occ << " \t" << p_amb_occ << "\t" << p_cs_occ << "\t" << p_bs_occ << "\t" << p_esc << " " << arrivetime1 << " " << departtime1 << endl;





		}

		for(int q = 1; q < counter; q++) { strcpy(schd_tab[s_tab[i][q]][GRPIDX],"");  }




	}






	double duration = 1000.0 *( std::clock() - start2 ) / (double) CLOCKS_PER_SEC;
	//   if(DEBUG == 1) gse <<"updating shared memory: "<< duration <<'\n';

	std::clock_t start = std::clock();

	// if(DEBUG == 1) gse << cnt << endl;

	//if(updatedb){ updateDatabase(cnt, indexstart  , env, conn, schd_tab,s_tab,table_itms_segments, table_itms_trips);}

	duration = 1000.0 *( std::clock() - start ) / (double) CLOCKS_PER_SEC;
	//  if(DEBUG == 1) gse <<"Updating Database: "<< duration <<'\n';

	double duration2 = 1000.0 *( std::clock() - start2 ) / (double) CLOCKS_PER_SEC;

	if(DEBUG == 1) gse << "Done calculating" << endl;
	//  if(DEBUG == 1) gse <<"calculating for one: "<< duration2 <<'\n';


	return;



}






bool insertandcalcroute(int counter, double * distances, int * times, int * local_s_tab, int segstart, int puid, int doid, Environment* env, Connection* conn, string table_itms_segments, string table_itms_trips){

	//  if(DEBUG == 1) gse << "checking late and early factors " <<  p_DIALRIDEEARLYPICKFACTOR[0] << " " <<p_DIALRIDELATEPICKFACTOR[0] << endl;
	if(DEBUG == 1) gse << " insert and calc route " << endl;

	int p_WHEELLOAD1;
	int p_AMBLOAD1;
	int p_MAXEARLYDROPOFFFACTOR1;
	int p_DIALRIDEEARLYPICKFACTOR1;
	int p_DIALRIDELATEPICKFACTOR1;
	int p_OTHEREARLYPICKFACTOR1;
	int p_OTHERLATEPICKFACTOR1;
	string IGNOREPUTIMES1;
	int p_SHORTBREAK1;
	int p_LUNCHBREAK1;
	int p_PROXIMITYFACTOR1;
	int a_mediumshortdistance1;
	int a_mediumlongdistance1;
	int a_shorttriptime1;
	int a_longtriptime1;
	int a_mediumtriptime1;
	int a_extra_loadtime1;
	string ZONE_DESCR1;
	string IGNORE_DEPOTS_CUTOFF1;



	//   if(DEBUG == 1) gse << "made it2 " << endl;



	string lat1db[2], lon1db[2], tripid1db[1], disabilitydb[1], estdist[1];

	//  if(DEBUG == 1) gse << "local " <<  schd_tab[puid][0] << " id " << puid << endl;

	lat1db[0] = schd_tab[puid][10];
	lon1db[0] = schd_tab[puid][37];
	lat1db[1] = schd_tab[puid][10];
	lon1db[1] = schd_tab[puid][37];
	tripid1db[0] = schd_tab[puid][3];
	disabilitydb[0] = schd_tab[puid][12];
	estdist[0] = schd_tab[puid][21];
	int SEGSTART  = 0;

	bool routeFound = false;
	string a_route;

	//  if(DEBUG == 1) gse << "made it2 " << endl;


	int s_tab_idx;

	if(counter > 0){
		//   if(DEBUG == 1) gse << "COUNTER " << counter << endl;
		if(DEBUG == 1) gse <<"Stop  prom time    eta   etd     dist ttime stoptype    wc    amb \t esc"<< endl;
	}
	std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>  varHolder;
	string p_customer;
	bool notFound;
	int f1 = 0;
	int f2 = 0;


	std::string  promisedtime1;
	int prom_time;
	std::string est_traveltime1;
	std::string arrivetime1;
	std::string departtime1 ;
	std::string perftime1 ;
	int p_perf_time;
	std::string starttime1 ;
	std::string endtime1;
	std::string timetonextstop1 ;
	std::string eta1 ;
	int eta;
	std::string etd1; /// fix this hack in gettimes next token
	int etd;
	std::string  lat1  ;
	std::string lon1   ;
	std::string lat2 ;
	std::string lon2;
	/// fix this  p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
	///OffLoaded   , p_trip_type ,    p_hack in get next token
	std::string  amb_occ1 ;
	std::string wc_occ1 ;
	int cs_cap = 0;
	int bs_cap = 0;
	std::string amb_cap1 ;
	std::string wc_cap1 ; /// fix this hack in get next token
	int p_amb_occ;
	int p_wc_occ;
	int p_cs_occ;
	int p_bs_occ;
	int p_grp_cnt_wc;
	int p_grp_cnt_amb;
	int s_trip_appt_time = 0;
	int p_latency = 0;
	int p_prev_stop_num;
	int p_prev_perf_time;
	int OffLoaded;
	string p_trip_type ;
	string p_spl_other_desc ;
	int last_wc_occ = 0, last_cs_occ = 0, last_bs_occ = 0;
	int last_amb_occ = 0;
	int last_dep_time ;
	int last_arr_time ;
	int tot_driv_time = 0;
	double tot_miles = 0;
	string p_latestoptime ="";
	string p_earlystoptime= "";
	double p_disttonextstop = 0.0;
	int p_timetonextstop = 0;
	string p_name ;
	string p_return_trip ;
	string p_stop_type ;
	string p_disability = "" ;
	int p_esc;
	string p_td_segmentid = "";
	int stopnum1;
	int p_stop_num;
	int p_early_morning_factor = 0;
	string p_street_by_street = "T";
	string p_citytown;
	string time_zone2 = "*";
	string time_zone;// = "*";
	int petaint;
	string rteStr;
	double disttrav;
	string grp_cnt_amb;
	string grp_cnt_wc;
	string dist;
	string p_promised_time;
	string p_eta;
	string p_etd;
	string capacity;
	string times1;
	string prev_perftime1,prev_eta1,prev_etd1, prev_amb_occ1, prev_wc_occ1;
	int prev_eta,prev_etd,prev_p_perf_time;
	//int index;
	//int cnt = 0;
	double disttrav2;
	double prev_distance = 0;
	int AGRPCOUNTER = 0;
	int APRVGRPCOUNTER = 0;
	string p_prev_promised_time = "0000A";
	int timetonextstop2 = 0;
	bool ontime = true;
	//bool recalc = false;


	string indicies = to_string(puid) + "," +to_string(doid);
	string indafter1;string indafter2;


	string pueta;
	string doeta;
	string disttravpu;
	string disttravdo;
	string pustp;
	string dostp;
	string puetd;
	string doetd;
	string latlon1;
	string latlon2;
	string latlon3;
	string latlon4;
	string oResult;
	int actualTT = 0;
	string distholder[counter];
	string timeholder[counter];
	string originialeta[counter];
	string origdistholder[MAXSTOPS];
	string origtimeholder[MAXSTOPS];
	string origCalcTime[MAXSTOPS];
	bool finished = false;
	int timetraveled = 0;
	string route = schd_tab[local_s_tab[0]][0];
	int routeint = (int)to_number(route.substr(1,route.length()));
	int aStp = 0;//first stop to be inserted.



	//  if(DEBUG == 1) gse << "Counter " << counter << endl;



	if(DEBUG == 1) gse << "original distances " << endl;
	for(int i = 0; i < MAXSEGMENTS; i++){ ///save original distances
		if(s_tab[i][0]==routeint){
			s_tab_idx = i;
			if(DEBUG == 1) gse << "orginial distances route " << s_tab[i][0] << endl;
			for(int k = 1;k < MAXSTOPS; k++){
				if(s_tab[i][k]==0){break;}
				origdistholder[k] = schd_tab[s_tab[i][k]][6];
				origtimeholder[k] = schd_tab[s_tab[i][k]][28];
				originialeta[k] = schd_tab[s_tab[i][k]][29];
				origCalcTime[k] = schd_tab[s_tab[i][k]][CALCULATEDTIME];
				if(DEBUG == 1) gse << schd_tab[s_tab[i][k]][2] << " " << schd_tab[s_tab[i][k]][3] << " " << schd_tab[s_tab[i][k]][6] << " " << schd_tab[s_tab[i][k]][28] << endl;
			}
		}
	}

	if(DEBUG == 1) gse << "The passed distances are " << endl;
	for(int i = 0; i < counter; i++){
		if(distances[local_s_tab[i]]!=-1){
			if(DEBUG == 1) gse << distances[local_s_tab[i]] << " " << schd_tab[local_s_tab[i]][3] << " " << local_s_tab[i] << " "   <<times[local_s_tab[i]] <<  endl;
		}
		else{
			if(DEBUG == 1) gse << "Using original dist " << schd_tab[local_s_tab[i]][6] << " "  << schd_tab[local_s_tab[i]][3] << " " << local_s_tab[i] << " "   <<schd_tab[local_s_tab[i]][28] <<  endl;

		}
	}


	if(DEBUG == 1) gse << "Tripids : " << endl;

	for(int i = 0; i < counter; i++){ ///copy new distances into array in correct stop order
		//if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || (strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 && strcmp(schd_tab[local_s_tab[i]][2], "999")!=0) ) {
		//   if(DEBUG == 1) gse << " Using distance " << distances[f2] << endl;
		if(/*(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || strcmp(schd_tab[local_s_tab[i+1]][0], "")==0) && strcmp(schd_tab[local_s_tab[i]][2], MAXSTOPNUM[0])!=0 */
				distances[local_s_tab[i]]!=-1){
			timetraveled = times[local_s_tab[i]];
			disttrav = distances[local_s_tab[i]];
			distholder[i] = to_string(disttrav);
			timeholder[i] = to_string(timetraveled);
			f2++;
			if(DEBUG == 1) gse << schd_tab[local_s_tab[i]][3] << " " << distances[local_s_tab[i]] << " " << times[local_s_tab[i]] <<  endl;
		}
		//}
		//else{
		//distholder[i] = schd_tab[local_s_tab[i]][6];
		//}
	}
	for(int k = 0; k < counter; k++){ //overwrite distances in trips table
		if(/*(strcmp(schd_tab[local_s_tab[k]][0], "")==0 || strcmp(schd_tab[local_s_tab[k+1]][0], "")==0) && strcmp(schd_tab[local_s_tab[k]][2], MAXSTOPNUM[0])!=0*/
				distances[local_s_tab[k]]!=-1
		){
			strcpy( schd_tab[local_s_tab[k]][6] , distholder[k].c_str());
			strcpy( schd_tab[local_s_tab[k]][28] , timeholder[k].c_str());
		}
	}


	if(DEBUG == 1) gse << "Distances and stopnumber and trip id and travel time to next stop  " << endl;
	for(int i = 0; i < counter; i++){
		if(DEBUG == 1) gse << schd_tab[local_s_tab[i]][2] << " " << schd_tab[local_s_tab[i]][3] << " " << schd_tab[local_s_tab[i]][6]<< " " << schd_tab[local_s_tab[i]][28] << endl;
	}


	for(int i = 0; i < counter; i++){
		if(strcmp(schd_tab[local_s_tab[i]][2],"1")==0){
			strcpy(schd_tab[local_s_tab[i]][2],"1");
		}
		else if(strcmp(schd_tab[local_s_tab[i]][2],MAXSTOPNUM[0])==0){
			strcpy(schd_tab[local_s_tab[i]][2],MAXSTOPNUM[0]);
		}
		else{
			int stopnum4 = (int)to_number(schd_tab[local_s_tab[i-1]][2]);
			stopnum4++;
			strcpy(schd_tab[local_s_tab[i]][2],to_string(stopnum4).c_str());

		}


	}


	int grouptraveltimeallowance[MAXTRIPIDX];


	for(int y = 0; y < MAXTRIPIDX; y++){
		grouptraveltimeallowance[y] = 0;
	}
	int extratraveltime = 0;
	int groupid = 1;

	for(int y = 0; y < counter;y++){

		string groupmark = schd_tab[local_s_tab[y]][GRPIDX];


		if(strcmp(schd_tab[local_s_tab[y]][2],MAXSTOPNUM[0])!=0){
			if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"D")==0 && groupmark!= "" ){
				//strcpy(schd_tab[local_s_tab[y]][GRPIDX],to_string(groupid).c_str());
				//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[y]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
				int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
				grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
			}
			if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"P")==0 && groupmark!= ""){
				groupid++;
			}
		}

	}

	if(DEBUG == 1) gse << "Moving on to inserting " << endl;




	/*  if(DEBUG == 1) gse << "Getting insertion stop " << endl;
for(int i = 0; i < counter; i++){
                if(strcmp(schd_tab[local_s_tab[i]][0],"")==0){
                    aStp = (int)to_number(schd_tab[local_s_tab[i]][2]);
                      if(DEBUG == 1) gse << "do violation check after " << aStp <<endl;
                    break;
                }
}*/

	aStp = 1;
	bool secondpassinsertedtrip = false;





	//  if(DEBUG == 1) gse << "using all 1 " << 0 << " " <<  a_shorttriptime[0] << " " << a_mediumtriptime[0] << " " << a_longtriptime[0] << endl;
	if(DEBUG == 1) gse << "Getting cap" << endl;
	starttimer(FILE1);
	//bool isVol = isVolSegment(schd_tab[local_s_tab[SEGSTART]][0], schd_tab[local_s_tab[SEGSTART]][1],schd_tab[local_s_tab[SEGSTART]][14]);
	getCS_CY_cap(cs_cap, bs_cap, schd_tab[local_s_tab[SEGSTART]][SEGMENTTYPE]);
	if(DEBUG == 1) gse << "End cap" << endl;
	starttimer(FILE1);

	for(int i = 0; i < counter; i++)
	{


		//    if(DEBUG == 1) gse << "i is " << i << endl;

		promisedtime1 = schd_tab[local_s_tab[i]][4];
		prom_time =(int)to_number(promisedtime1);
		//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
		p_promised_time = itms_minutes_to_ampm(prom_time);
		est_traveltime1 = schd_tab[local_s_tab[i]][22];
		arrivetime1 =schd_tab[local_s_tab[i]][23];
		arrivetime1 = padStr( arrivetime1);
		departtime1 =schd_tab[local_s_tab[i]][24];
		departtime1 = padStr(departtime1);
		perftime1 = schd_tab[local_s_tab[i]][25];
		//perftime1 = padStr(perftime1);
		p_perf_time = (int)to_number(perftime1);
		starttime1 = schd_tab[local_s_tab[i]][26];
		starttime1  = padStr(starttime1 );
		endtime1 = schd_tab[local_s_tab[i]][27];
		endtime1 = padStr(endtime1);
		s_trip_appt_time = (int)to_number(endtime1);
		timetonextstop1 = schd_tab[local_s_tab[i]][28];
		eta1 = schd_tab[local_s_tab[i]][29];
		//   if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
		eta = (int)to_number(eta1);
		//   if(DEBUG == 1) gse << "eat and int " << eta << endl;
		eta1 = itms_minutes_to_ampm(eta);
		//  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
		etd1 = schd_tab[local_s_tab[i]][30]; /// fix this hack in get next token
		etd = (int)to_number(etd1);
		etd1 = itms_minutes_to_ampm(etd);
		//temp = schd_tab[local_s_tab[i]][10];
		lat1 =  schd_tab[local_s_tab[i]][10];
		lon1 =  schd_tab[local_s_tab[i]][37];
		lat2 =  schd_tab[local_s_tab[i]][38];

		lon2 = schd_tab[local_s_tab[i]][39]; /// fix this hack in get next token
		// temp = schd_tab[local_s_tab[i]][12];
		amb_occ1 =  schd_tab[local_s_tab[i]][31];
		wc_occ1 =  schd_tab[local_s_tab[i]][32];
		p_cs_occ = to_number(schd_tab[local_s_tab[i]][CS_OCC]);
		p_bs_occ =to_number(schd_tab[local_s_tab[i]][BS_OCC]);
		amb_cap1 =  schd_tab[local_s_tab[SEGSTART]][33];
		//temp = temp+",";
		wc_cap1 =  schd_tab[local_s_tab[SEGSTART]][34]; /// fix this hack in get next token
		grp_cnt_amb = schd_tab[local_s_tab[i]][35];
		p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
		grp_cnt_wc = schd_tab[local_s_tab[i]][36];
		p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

		p_disability = schd_tab[local_s_tab[i]][12];
		//p_amb_occ = to_number(amb_occ1);
		//p_wc_occ = to_number(wc_occ1);
		p_trip_type = schd_tab[local_s_tab[i]][8];
		p_spl_other_desc = schd_tab[local_s_tab[i]][9];
		//last_dep_time = prom_time;
		//last_arr_time = prom_time;
		p_name = schd_tab[local_s_tab[i]][14];
		p_return_trip = schd_tab[local_s_tab[i]][18];
		p_stop_type = schd_tab[local_s_tab[i]][7];
		p_esc = (int)to_number(schd_tab[local_s_tab[i]][13]);
		p_stop_num = (int)to_number(schd_tab[local_s_tab[i]][2]);
		p_td_segmentid = schd_tab[local_s_tab[SEGSTART]][0];
		//    if(DEBUG == 1) gse << "The segment is  " << p_td_segmentid << " " <<  schd_tab[local_s_tab[SEGSTART]][0] << endl;
		//  if(DEBUG == 1) gse << "STop num " << p_stop_num<< endl;
		prev_distance = 0;
		if (p_stop_num == 1){
			last_dep_time = prom_time;
			last_arr_time = prom_time;

		}
		if(p_stop_num != 1){
			prev_distance = to_number( schd_tab[local_s_tab[i-1]][6]);
			timetonextstop2 = to_number( schd_tab[local_s_tab[i-1]][28]);
			disttrav = prev_distance;
		}

		if(DEBUG == 1) gse << "The time to next stop is " << timetonextstop2 << " " << schd_tab[local_s_tab[i-1]][28] << endl;







		/*  if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ){//strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ){
                            prev_distance = distances[f1];
                            f1++;
                           if(DEBUG == 1) gse << "Prev distance inserted trip " << prev_distance << " " <<  schd_tab[local_s_tab[i]][3] << endl;
                            }
                            else{
                             prev_distance = to_number( schd_tab[local_s_tab[i-1]][6]);
                            //   if(DEBUG == 1) gse << "Prev distance non inserted" << prev_distance << " " <<  schd_tab[local_s_tab[i]][3] << endl;
                            }
                        }
                       if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ) {
                          //   if(DEBUG == 1) gse << " Using distance " << distances[f2] << endl;
                        disttrav = distances[f2];
                        distholder[i] = to_string(disttrav);
                        f2++;
                       }
                       else{
                           distholder[i] = schd_tab[local_s_tab[i]][6];
                       }*/

		//     if(DEBUG == 1) gse << "The distance is " << distholder[i] << " " << i <<  endl;

		//  if(DEBUG == 1) gse << "Disttrav " << prev_distance << endl;

		p_citytown =  schd_tab[local_s_tab[i]][11];
		int p_WHEELLOAD1;
		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;
		int grouppickupcnt = 0;



		string pReturn_trip = schd_tab[local_s_tab[i]][18];
		string  pDisability = schd_tab[local_s_tab[i]][12];
		string p_trip_type1 = schd_tab[local_s_tab[i]][8];


		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);

		double estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);

		int aAllowedTT;
		/*if(to_number(estdist[0]) < 3.0)
                            aAllowedTT = 50;
                        else if(to_number(estdist[0]) >= 3.0 &&  to_number(estdist[0]) < 6.0)
                            aAllowedTT = 65;
                        else if(to_number(estdist[0]) >= 6.0 &&  to_number(estdist[0])< 9.0)
                            aAllowedTT = 95;
                        else if(to_number(estdist[0]) >= 9.0 &&  to_number(estdist[0]) < 12.0)
                            aAllowedTT = 115;
                        else if(to_number(estdist[0])>= 12.0 && to_number(estdist[0]) < 14.0)
                            aAllowedTT = 135;
                        else if(to_number(estdist[0]) > 14.0)
                            aAllowedTT = 155;*/

		extratraveltime = 0;

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];
		if(groupmark != ""){
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			extratraveltime = grouptraveltimeallowance[grpnumber] -EXTRAGRPTT[0];
			if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
		}
		int allowedDW;
		double esttime = to_number(schd_tab[local_s_tab[i]][22]);

		if(estdisttrip < a_mediumshortdistance1){
			aAllowedTT = a_shorttriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
		}
		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
			aAllowedTT = a_mediumtriptime1 + extratraveltime;
		}
		else{
			aAllowedTT = a_longtriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
		}

		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
		}

		int p_perf_time;
		string pDisposition = schd_tab[local_s_tab[i]][DISPOSITION];
		set_p_perf_time(pDisposition,pDisability, p_perf_time, p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1 );

		int est_time;
		string tripid = schd_tab[local_s_tab[i]][3];
		tripid = tripid.substr(0,1);
		string endtime2;
		if(tripid == "S"){
			endtime2 =to_string( (int)itms_to_minutes(ampm2fullhrs(p_promised_time)));
		}

		if(p_stop_type == "P"){
			if((int)to_number(starttime1)!= 0)
				est_time = (int)to_number(starttime1);
			else{
				est_time =  (int)to_number(endtime2) - (int)to_number(est_traveltime1);
			}
		}
		else{
			if((int)to_number(endtime2)!= 0)
				est_time = (int)to_number(endtime2);
			else{

				est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
			}
		}

		string timezonetime = itms_minutes_to_ampm(est_time);
		//p_eta = eta1;
		if(p_stop_num == 1){
			p_eta = p_promised_time;
			p_etd = etd1;
		}
		else{
			p_eta = eta1;
			p_etd = etd1;
		}

		string route = schd_tab[local_s_tab[i]][0];
		if( (route == "" || timeZones(p_eta, timezonetime) != timeZones(timezonetime,p_eta))  && !secondpassinsertedtrip){time_zone = timeZones(p_eta, timezonetime); secondpassinsertedtrip = true;}
		else{  if(F_GET_TRAVEL_TIME (1.0 , timeZones(p_eta, timezonetime), "*") > F_GET_TRAVEL_TIME (1.0 , timeZones(timezonetime,p_eta), "*")){
			time_zone = timeZones(p_eta, timezonetime);secondpassinsertedtrip = false;
		}
		else{
			time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(p_eta, timezonetime);
		string timezone2;
		if (p_stop_num != 1) {
			if (!isSameLocation(local_s_tab[i],local_s_tab[i-1]))
				timezone2 = "#"; // not the same lat/long
			else
				timezone2 = "*";
		}





		//if (aStp == 0 && strcmp(schd_tab[local_s_tab[i]][0],"")==0)
		// aStp = (int)to_number(schd_tab[local_s_tab[i]][2]);






		//  if(DEBUG == 1) gse << "Est distance " << estdisttrip << " for trip " << schd_tab[local_s_tab[i]][3] << " allowed time " << aAllowedTT << endl;




		//

		//  if(DEBUG == 1) gse << "ETa 1" << p_eta << " " << p_etd << endl;
		//  if(DEBUG == 1) gse << "1. I am here " << prev_distance << endl;

		varHolder = itms_calcroute( arrivetime1, departtime1,timetonextstop2,  rteStr ,   p_citytown ,     p_street_by_street ,     p_eta  ,    p_promised_time ,     p_perf_time ,   p_early_morning_factor ,  p_stop_num ,
				p_td_segmentid,  p_wc_occ   , p_amb_occ,   p_esc  ,  p_disability  , p_stop_type  ,  p_WHEELLOAD[0] ,  p_AMBLOAD[0] ,
				p_customer ,   p_return_trip  ,  p_DIALRIDEEARLYPICKFACTOR[0]  ,  p_DIALRIDELATEPICKFACTOR[0] ,  p_PROXIMITYFACTOR[0],  p_SHORTBREAK[0]  ,
				p_LUNCHBREAK[0]   ,   p_MAXEARLYDROPOFFFACTOR[0]  , p_OTHEREARLYPICKFACTOR[0]  ,  p_OTHERLATEPICKFACTOR[0] ,   p_name    ,
				p_timetonextstop , p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
				OffLoaded   , p_trip_type ,    p_prev_perf_time ,   p_prev_stop_num , p_latency   ,  s_trip_appt_time ,  p_grp_cnt_amb ,
				p_grp_cnt_wc,  ignorepu[0],  IGNORE_DEPOTS_CUTOFF[0], time_zone, timezone2,starttime1, p_cs_occ,p_bs_occ,last_cs_occ,last_bs_occ,pDisposition);

		//    if(DEBUG == 1) gse << "2. I am here " << std::get<4>(varHolder) << endl;

		p_eta = std::get<0>(varHolder);
		p_wc_occ=std::get<1>(varHolder);
		p_amb_occ=std::get<2>(varHolder);
		p_esc=std::get<3>(varHolder);
		p_timetonextstop=std::get<4>(varHolder);
		p_disttonextstop=std::get<5>(varHolder);
		p_earlystoptime=std::get<6>(varHolder);
		p_latestoptime=std::get<7>(varHolder);
		tot_miles=std::get<8>(varHolder);
		tot_driv_time=std::get<9>(varHolder);
		p_etd=std::get<10>(varHolder);
		OffLoaded=std::get<11>(varHolder);
		p_perf_time = std::get<12>(varHolder);
		p_cs_occ = std::get<13>(varHolder);
		p_bs_occ = std::get<14>(varHolder);

		if(!secondpassinsertedtrip){
			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) - p_perf_time);



			if (p_stop_num != 1 && p_stop_num != (int)to_number(MAXSTOPNUM[0])) {
				if (timetonextstop2 == 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)

					AGRPCOUNTER = AGRPCOUNTER + 1;
				else{
					if (AGRPCOUNTER > 0  && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)
					{
						APRVGRPCOUNTER = AGRPCOUNTER + 1;
					}
					AGRPCOUNTER = 0;
				}


				if(p_disability.find("WC",0) == string::npos && p_disability.find("SC",0) == string::npos && p_disability.find("XLT",0) == string::npos){


					if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0){
						if(DEBUG == 1) gse << "We are editing perf time " <<endl;
						p_perf_time = p_perf_time / AGRPCOUNTER;
					}


					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

						p_perf_time = p_perf_time / APRVGRPCOUNTER;
						APRVGRPCOUNTER = 0;
					}
				}
				else{

					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


						if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / AGRPCOUNTER;
						}

						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / APRVGRPCOUNTER;
							APRVGRPCOUNTER = 0;
						}
					}
				}

			}


			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) + p_perf_time);
		}

		bool changedeta = true;

		if(itms_to_minutes (ampm2fullhrs (p_eta)) != eta)
			changedeta = true;





		//   if(DEBUG == 1) gse << "ETa 2" << p_eta << " " << p_etd << endl;

		//  if(DEBUG == 1) gse << "2. I am here " << schd_tab[local_s_tab[0]][0] << endl;

		strcpy(schd_tab[local_s_tab[i]][4], to_string(itms_to_minutes (ampm2fullhrs ( p_promised_time))).c_str());
		strcpy( schd_tab[local_s_tab[i]][22] ,est_traveltime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][23],arrivetime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][24] ,departtime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][25] ,to_string(p_perf_time).c_str());
		strcpy( schd_tab[local_s_tab[i]][26] ,starttime1.c_str());
		strcpy( schd_tab[local_s_tab[i]][27] ,endtime1.c_str()) ;
		if(i > 0){
			strcpy(  schd_tab[local_s_tab[i-1]][28] ,to_string(timetonextstop2).c_str()) ;
			strcpy(  schd_tab[local_s_tab[i-1]][CALCULATEDTIME] ,to_string(p_timetonextstop).c_str()) ;
			if(DEBUG == 1) gse << "Copying " << p_timetonextstop << "  to "  << local_s_tab[i-1] << endl;
		}

		strcpy(  schd_tab[local_s_tab[i]][29] ,to_string(itms_to_minutes (ampm2fullhrs (p_eta))).c_str());
		strcpy(  schd_tab[local_s_tab[i]][30] ,to_string(itms_to_minutes (ampm2fullhrs (p_etd))).c_str());
		//strcpy(  schd_tab[local_s_tab[i]][DIRTYBIT] ,("Y")) ;
		//temproute[i][6] = to_string(disttrav);
		strcpy( schd_tab[local_s_tab[i]][31] ,  to_string(p_amb_occ).c_str());
		strcpy( schd_tab[local_s_tab[i]][32] ,to_string(p_wc_occ).c_str());
		strcpy((schd_tab[local_s_tab[i]][CS_OCC]), to_string(p_cs_occ).c_str());
		strcpy((schd_tab[local_s_tab[i]][BS_OCC]), to_string(p_bs_occ).c_str());
		strcpy( schd_tab[local_s_tab[i]][38], schd_tab[local_s_tab[i+1]][10]);
		strcpy( schd_tab[local_s_tab[i]][39], schd_tab[local_s_tab[i+1]][37]);

		if(p_stop_type  == "P"){
			string tripidforwait = schd_tab[local_s_tab[i]][3];
			int DW = getDWByStop (tripidforwait, p_stop_type ,itms_to_minutes (ampm2fullhrs (p_eta)) , itms_to_minutes (ampm2fullhrs (p_etd))  ,(int)to_number(starttime1), p_perf_time);
			int PW = getPWByStop (tripidforwait,  p_stop_type  ,itms_to_minutes (ampm2fullhrs (p_eta))    , (int)to_number(starttime1));
			strcpy(schd_tab[local_s_tab[i]][DWWAIT], to_string(DW).c_str());
			strcpy(schd_tab[local_s_tab[i]][PWWAIT], to_string(PW).c_str());
		}
		else{


			int eta = itms_to_minutes (ampm2fullhrs (p_eta));
			int etd = (int)to_number(schd_tab[local_s_tab[i-1]][30]);
			int TT = (int)to_number(schd_tab[local_s_tab[i-1]][CALCULATEDTIME]);
			string tripidforwait = schd_tab[local_s_tab[i]][3];
			int DW = eta - etd + TT;
			int PW = getPWByStop (tripidforwait,  schd_tab[local_s_tab[i]][7],eta, (int)to_number(endtime1));
			strcpy(schd_tab[local_s_tab[i]][DWWAIT],to_string(DW).c_str());
			strcpy(schd_tab[local_s_tab[i]][PWWAIT],to_string(PW).c_str());
		}


		//  if(DEBUG == 1) gse << " local " << schd_tab[local_s_tab[SEGSTART]][0] << " " << local_s_tab[SEGSTART] << endl;
		//  strcpy( schd_tab[local_s_tab[i]][0] ,schd_tab[local_s_tab[SEGSTART]][0]);

		prev_eta1 = schd_tab[local_s_tab[i]][29];
		prev_eta = (int)to_number(prev_eta1);
		prev_eta1 = itms_minutes_to_ampm(prev_eta);

		if(DEBUG == 1) gse << "Starting loop " << endl;

		int t = i;
		string timezone3;
		if (p_stop_num != 1) {
			if (!isSameLocation(local_s_tab[t],local_s_tab[t-1]))
				timezone3 = "#"; // not the same lat/long
				else
					timezone3 = "*";


			tripid = schd_tab[local_s_tab[t-1]][3];
			if(timezone3 == "*" && strcmp(schd_tab[local_s_tab[t-1]][7], schd_tab[local_s_tab[t]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[local_s_tab[t-1]][41], schd_tab[local_s_tab[t]][41])==0){
				strcpy(  schd_tab[local_s_tab[t]][29] ,schd_tab[local_s_tab[t-1]][29]);
				int l = t;
				tripid = schd_tab[local_s_tab[l]][3];
				while(isSameLocation(local_s_tab[l],local_s_tab[l-1]) && strcmp(schd_tab[local_s_tab[l-1]][7], schd_tab[local_s_tab[l]][7])==0 && tripid.substr(0,1)!="S" && strcmp(schd_tab[local_s_tab[l-1]][41], schd_tab[local_s_tab[l]][41])==0){
					strcpy(  schd_tab[local_s_tab[l-1]][30] , schd_tab[local_s_tab[l]][30]);
					l--;
					tripid = schd_tab[local_s_tab[l]][3];
					if(l == 0)
						break;
				}
			}
		}

		if(secondpassinsertedtrip){  if(DEBUG == 1) gse << "REDOING" << endl; i--;continue;}

		prev_perftime1 = schd_tab[local_s_tab[i]][25];
		prev_p_perf_time = (int)to_number(prev_perftime1);


		prev_etd1 = schd_tab[local_s_tab[i]][30];
		prev_etd = (int)to_number(prev_etd1);
		prev_etd1 = itms_minutes_to_ampm(prev_etd);
		//temp = temproute[i][12];
		prev_amb_occ1 =  schd_tab[local_s_tab[i]][31];
		prev_wc_occ1 =  schd_tab[local_s_tab[i]][32];
		//amb_cap1 = getNextToken(&(temp), ",");
		//wc_cap1 =getNextToken(&(temp), ",");
		last_dep_time=prev_etd;
		last_arr_time=prev_eta;
		string prev_cs_occ = schd_tab[local_s_tab[i]][CS_OCC];
		string prev_bs_occ = schd_tab[local_s_tab[i]][BS_OCC];
		last_cs_occ=to_number(prev_cs_occ);
		last_bs_occ=to_number(prev_bs_occ);
		last_amb_occ=(int)to_number(prev_amb_occ1);
		last_wc_occ=(int)to_number(prev_wc_occ1);
		p_prev_perf_time = prev_p_perf_time;
		p_prev_stop_num = (int)to_number(schd_tab[local_s_tab[i]][2]);
		p_prev_promised_time = p_promised_time;


		//  if(DEBUG == 1) gse << "3. I am here " << schd_tab[local_s_tab[0]][0] << endl;


		// temp = temproute[i][4];


		/*if(temproute[i][20] == "0" && temproute[i-1][20] != "0"){
                               if(DEBUG == 1) gse << "Stop Num " << temproute[i-1][2] << endl;
                        temp = temproute[i-1][12];
                        getNextToken(&(temp), ",");
                        getNextToken(&(temp), ",");
                        amb_cap1 = getNextToken(&(temp), ",");
                        wc_cap1 =getNextToken(&(temp), ",");
                        }*/

		//   if(DEBUG == 1) gse << last_dep_time << endl;


		//  if(DEBUG == 1) gse << "4. I am here " << schd_tab[local_s_tab[0]][0] << endl;

		/*  if(local_s_tab[i] == puid && p_stop_num == aStp){
        indafter1 = schd_tab[local_s_tab[i-1]][20];
        pueta = p_eta;
         puetd = p_etd;
        disttravpu = to_string(disttrav);
        pustp = to_string(p_stop_num);
        latlon1 = schd_tab[local_s_tab[i-1]][10];
         latlon1= latlon1 +","+ schd_tab[local_s_tab[i-1]][37];
        latlon2 = schd_tab[local_s_tab[i+1]][10];
         latlon2= latlon2+ ","+ schd_tab[local_s_tab[i+1]][37];
        //indicies = temproute[i][20];
       //    if(DEBUG == 1) gse << indicies << endl;
    }





    if(local_s_tab[i] == puid && p_stop_num > aStp){
       doeta = p_eta;
       disttravdo = to_string(disttrav);
       dostp = to_string(p_stop_num);
       doetd = p_etd;
       if(p_stop_num == aStp +1)
        indafter2 = indafter1;
      else
        indafter2 = schd_tab[local_s_tab[i-1]][20];
         latlon3 = schd_tab[local_s_tab[i-1]][10];
         latlon3= latlon3 +","+ schd_tab[local_s_tab[i-1]][37];
         latlon4 = schd_tab[local_s_tab[i+1]][10];
         latlon4= latlon4+ ","+ schd_tab[local_s_tab[i+1]][37];


         actualTT = (itms_to_minutes (ampm2fullhrs (doeta)) - itms_to_minutes (ampm2fullhrs (puetd))); //flipped eta/etd
            if(DEBUG == 1) gse << "Actual travel time " << actualTT << endl;
    }
		 */


		//actual travel time



		string tripid2 = schd_tab[local_s_tab[i]][3];
		string p_trip_type2 = schd_tab[local_s_tab[i]][8];

		if(strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && (tripid2.substr(0,1) == "T" ||  tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN"){

			int pickupid = (int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX]);
			int doeta1 = (int)to_number(schd_tab[local_s_tab[i]][30]) - (int)to_number(schd_tab[local_s_tab[i]][25]);
			int puetd1 = (int)to_number(schd_tab[pickupid][30]);
			int stopafter;

			for(int t = 0; t < counter; t++){
				if(local_s_tab[t] == pickupid){
					stopafter = local_s_tab[t+1];
					break;
				}
			}

			string pReturn_trip1 = schd_tab[pickupid][18];
			string pDisability1 = schd_tab[pickupid][12];
			string p_trip_type11 = schd_tab[pickupid][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type11);
			int aLatepickup;

			if (pReturn_trip1 == "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}


			if((int)to_number(schd_tab[stopafter][30]) - (int)to_number(schd_tab[stopafter][25])  >= (int)to_number(schd_tab[pickupid][4]) + aLatepickup + (int)to_number(schd_tab[pickupid][25]) + (int)to_number(schd_tab[pickupid][CALCULATEDTIME])){
				puetd1 = (int)to_number(schd_tab[pickupid][4]) + aLatepickup + (int)to_number(schd_tab[pickupid][25]);
				if(DEBUG == 1) gse << "Changing puetd to " << puetd1 << " " << (int)to_number(schd_tab[stopafter][30]) << "  " <<  (int)to_number(schd_tab[stopafter][25]) <<  endl;
			}


			actualTT = doeta1 - puetd1; //flipped eta/etd
			if(DEBUG == 1) gse << "Actual travel time of " << schd_tab[local_s_tab[i]][3] << " " << actualTT << " out of " << aAllowedTT << endl;
		}

		else
			actualTT = 0;



		p_eta = itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][29]));
		p_etd = itms_minutes_to_ampm((int)to_number(schd_tab[local_s_tab[i]][30]));


		if(DEBUG == 1) gse << p_stop_num << " \t " << p_promised_time << " \t " << p_eta << " \t " << p_etd << " \t "  << setprecision(2) << prev_distance <<  "  \t" << p_timetonextstop << " \t " << p_stop_type << "\t wc occ" << p_wc_occ << " \t amb occ" << p_amb_occ << "\t" << p_cs_occ << "\t" << p_bs_occ << "\t" << p_esc << " " << arrivetime1 << " " << departtime1 << " " << p_trip_type << " " << schd_tab[local_s_tab[i]][20] << " " << " " <<schd_tab[local_s_tab[i]][42]<< " " << schd_tab[local_s_tab[i]][41] << " " << local_s_tab[i] <<" start time: " << starttime1<< " end time: " << endtime1 << " trip id " <<schd_tab[local_s_tab[i]][3] << " " << schd_tab[local_s_tab[i]][10] << " " << schd_tab[local_s_tab[i]][37]  <<  endl;



		int aLatepickup;

		if (p_return_trip == "Y"){
			aLatepickup = p_OTHERLATEPICKFACTOR1;
		}
		else{
			aLatepickup = p_DIALRIDELATEPICKFACTOR1;
		}

		if(p_stop_num == (int)to_number(MAXSTOPNUM[0])){
			endtime1 = to_string((int)itms_to_minutes(ampm2fullhrs(p_promised_time))); // to make sure segments do not go beyond the end'
			//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
		}

		bool preassigntripchange = true;
		if(strcmp(schd_tab[local_s_tab[i]][LATEDEVIATION],"")!=0 || strcmp(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION],"")!=0){
			preassigntripchange = false;
			if ((p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" ) {
				if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup)//p_DIALRIDELATEPICKFACTOR )
				{
					int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(starttime1) + aLatepickup);
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}

				}
			}


			if ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000")
			{
				if((((itms_to_minutes(ampm2fullhrs(p_eta))) >  (int)to_number(endtime1)) && prom_time != 0))
				{

					int dev =  itms_to_minutes(ampm2fullhrs(p_eta)) - ((int)to_number(endtime1));
					if(dev > (int)to_number(schd_tab[local_s_tab[i]][LATEDEVIATION])){
						preassigntripchange = true;
					}


				}
			}

			if((actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50) && actualTT > 0)){
				if((actualTT - aAllowedTT) > (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION])){
					if(DEBUG == 1) gse << "The dev is " << (int)to_number(schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION]) << endl;
					preassigntripchange = true;
				}
			}
		}


		if(actualTT > aAllowedTT + floor((RELAXCONSTRAINTS[0] - 1)*50)){
			if(DEBUG == 1) gse << "Travel time violation " <<  p_stop_num << " >= " <<  aStp << " " << actualTT << " > " << aAllowedTT<< endl;

		}
		if(!preassigntripchange)
		{
			if(DEBUG == 1) gse << "Preassigntripchange not true"  << schd_tab[local_s_tab[i]][TRVLTIMEDEVIATION] << " " <<  endl;
		}

		if(/*strcmp(USEREVERSECALC[0],"Y")!=0*/true){
			/*** 1. Check for WC violations ***/
			if (schd_tab[local_s_tab[i]][0] == "" && disabilitydb[0].find("WC")>=0 && p_stop_num >= aStp) {
				if (to_number(wc_cap1) == 0) {
					if(!finished){
						oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
						//strcpy( schd_tab[local_s_tab[i]][0] ,"");

						a_route = schd_tab[local_s_tab[SEGSTART]][0];
						//    if(DEBUG == 1) gse << "1 " << a_route << endl;


						for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
							if(s_tab[s_tab_idx][m]==0){break;}
							strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
							strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
							strcpy( schd_tab[s_tab[s_tab_idx][m]][29] , originialeta[m].c_str());
							strcpy( schd_tab[s_tab[s_tab_idx][m]][CALCULATEDTIME] , origCalcTime[m].c_str());

						}
						if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid<< endl;
						for(int k = 1;k < MAXSTOPS; k++){
							if(s_tab[s_tab_idx][k]==0){break;}
							if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << schd_tab[s_tab[s_tab_idx][k]][29] << endl;
						}
						for(int d = 0; d < counter; d++){
							if(strcmp(schd_tab[local_s_tab[d]][0],"")==0)//if it's an unassigned trip, reset eta.
								strcpy(schd_tab[local_s_tab[d]][29],"");
						}

						if(DEBUG == 1) gse <<  oResult << "\n\n";
						//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
						recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
						break;
					}
					finished = true;


				}
			} //general






			/*** 2. Check for Capacity Violation ***/
			if ((p_wc_occ> (int)to_number(wc_cap1) && p_stop_num >= aStp) || (p_amb_occ > (int)to_number(amb_cap1) && p_stop_num >= aStp)
					|| (p_cs_occ > cs_cap  &&  p_stop_num >=aStp) || (p_bs_occ > bs_cap  &&  p_stop_num >=aStp)) {
				//   if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;
				if(!finished){
					// string route = schd_tab[local_s_tab[1]][0];
					oResult = "NOK Capacity Violation when assigning Trip on Segment " + p_td_segmentid + " with capacities wc, amb " + wc_cap1 + " " + amb_cap1;
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");

					a_route = schd_tab[local_s_tab[SEGSTART]][0];
					//  if(DEBUG == 1) gse << "2 " << a_route << endl;

					for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
						if(s_tab[s_tab_idx][m]==0){break;}
						strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
						strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
						strcpy( schd_tab[s_tab[s_tab_idx][m]][29] , originialeta[m].c_str());
						strcpy( schd_tab[s_tab[s_tab_idx][m]][CALCULATEDTIME] , origCalcTime[m].c_str());
					}
					if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
					for(int k = 1;k < MAXSTOPS; k++){
						if(s_tab[s_tab_idx][k]==0){break;}

						if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << schd_tab[s_tab[s_tab_idx][k]][29] << endl;
					}
					for(int i = 0; i < counter; i++){
						if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
							strcpy(schd_tab[local_s_tab[i]][29],"");
					}
					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
					recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
					break;
				}
				finished = true;


			} //per stop number



			if(changedeta){



				/***3. Pickup Window violation *****/
				if ( preassigntripchange && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" && (p_stop_num >= aStp )) {

					if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup + floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
					{
						//   if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
						// oDropETA = " Dropoff ETA:  ;" ;
						if(!finished){
							string tripid = schd_tab[local_s_tab[i]][3];
							oResult = "Impact: " + tripid +" Pickup is outside the window with start time + late pickup: " + itms_minutes_to_ampm(((int)to_number(starttime1) + aLatepickup)); //oResult
							//  strcpy( schd_tab[local_s_tab[i]][0] ,"");

							a_route = schd_tab[local_s_tab[SEGSTART]][0];
							//   if(DEBUG == 1) gse << "3 " << a_route << endl;
							if(strcmp(USEREVERSECALC[0],"Y")!=0){
								for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
									if(s_tab[s_tab_idx][m]==0){break;}
									strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][29] , originialeta[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][CALCULATEDTIME] , origCalcTime[m].c_str());
								}
								for(int i = 0; i < counter; i++){
									if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
										strcpy(schd_tab[local_s_tab[i]][29],"");
								}
								if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
								for(int k = 1;k < MAXSTOPS; k++){
									if(s_tab[s_tab_idx][k]==0){break;}
									if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << schd_tab[s_tab[s_tab_idx][k]][29] << endl;
								}

								if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
								//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
								recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
								break;
							}
							else {
								ontime = false;
							}

						}
						finished = true;

					}

				}


				if(p_stop_num == (int)to_number(MAXSTOPNUM[0])){
					endtime1 = to_string((int)itms_to_minutes(ampm2fullhrs(p_promised_time))); // to make sure segments do not go beyond the end'
					//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
				}
				/*** 4. Check if someone is late for Appointment ***/
				/** Added condition if the appt. time is not null and return_trip = Y **/
				if ( preassigntripchange && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"&& (p_stop_num >= aStp)))
				{



					if((((itms_to_minutes(ampm2fullhrs(p_eta))) > /*12 +*/ (int)to_number(endtime1)+ floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0))
					{
						if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;
						if(!finished){
							string tripid = schd_tab[local_s_tab[i]][3];
							oResult = "Impact: " +  tripid + " will be late: " + to_string((int)itms_to_minutes(ampm2fullhrs(p_eta)) - (int)to_number(endtime1) ) +
									" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
							// strcpy( schd_tab[local_s_tab[i]][0] ,"");
							if(DEBUG == 1) gse <<   oResult <<"\n\n";

							a_route = schd_tab[local_s_tab[SEGSTART]][0];
							//  if(DEBUG == 1) gse << "4 " << a_route << endl;
							if(strcmp(USEREVERSECALC[0],"Y")!=0){
								for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
									if(s_tab[s_tab_idx][m]==0){break;}
									strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][29] , originialeta[m].c_str());
									strcpy( schd_tab[s_tab[s_tab_idx][m]][CALCULATEDTIME] , origCalcTime[m].c_str());
								}
								for(int i = 0; i < counter; i++){
									if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
										strcpy(schd_tab[local_s_tab[i]][29],"");
								}
								if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
								for(int k = 1;k < MAXSTOPS; k++){
									if(s_tab[s_tab_idx][k]==0){break;}
									if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << schd_tab[s_tab[s_tab_idx][k]][29] << endl;
								}

								if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
								//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
								recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
								break;
							}
							else {
								ontime = false;
							}
						}
						finished = true;
					}
				}


				/**** 5. Check if it exceeds the Travel Time ****/
				if((preassigntripchange && actualTT > aAllowedTT+ floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && actualTT > 0) && p_stop_num >= aStp){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {
					if(!finished){
						string tripid = schd_tab[local_s_tab[i]][3];
						oResult = "Impact: Travel Time Violation on Trip: " + tripid  + " TT: " + to_string(actualTT) + " Allowed: " + to_string(aAllowedTT) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
						// strcpy( schd_tab[local_s_tab[i]][0] ,"");

						if(DEBUG == 1) gse << oResult;

						a_route = schd_tab[local_s_tab[SEGSTART]][0];
						if(strcmp(USEREVERSECALC[0],"Y")!=0){
							for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
								if(s_tab[s_tab_idx][m]==0){break;}
								strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
								strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
								strcpy( schd_tab[s_tab[s_tab_idx][m]][29] , originialeta[m].c_str());
								strcpy( schd_tab[s_tab[s_tab_idx][m]][CALCULATEDTIME] , origCalcTime[m].c_str());
							}
							for(int i = 0; i < counter; i++){
								if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
									strcpy(schd_tab[local_s_tab[i]][29],"");
							}
							if(DEBUG == 1) gse << "Back to originial distances " << p_td_segmentid << endl;
							for(int k = 1;k < MAXSTOPS; k++){
								if(s_tab[s_tab_idx][k]==0){break;}
								if(DEBUG == 1) gse << schd_tab[s_tab[s_tab_idx][k]][2] << " " << schd_tab[s_tab[s_tab_idx][k]][3] << " " << schd_tab[s_tab[s_tab_idx][k]][6] << schd_tab[s_tab[s_tab_idx][k]][29] << endl;
							}

							if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
							//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
							recalcons_tab(a_route , env, conn, table_itms_segments, table_itms_trips, segstart);
							break;
						}
						else {
							ontime = false;
						}



					}
					finished = true;

				}



			}



		}


		if(p_stop_num==(int)to_number(MAXSTOPNUM[0])){



			bool usereversefail = true;
			if(strcmp(USEREVERSECALC[0],"Y")==0){
				usereversefail = reversecalclocal(counter, local_s_tab, ontime);
			}
			if(!usereversefail){
				if(DEBUG == 1) gse << "There was a violation so reverse calcing!" << endl;
				//UPDATE_REVERSE_CALCULATE_BATCH(counter, local_s_tab);
				for(int m = 1; m < MAXSTOPS; m++){//retstore orginial distances
					if(s_tab[s_tab_idx][m]==0){break;}

					strcpy( schd_tab[s_tab[s_tab_idx][m]][6] , origdistholder[m].c_str());
					strcpy( schd_tab[s_tab[s_tab_idx][m]][28] , origtimeholder[m].c_str());
					strcpy( schd_tab[s_tab[s_tab_idx][m]][29] , originialeta[m].c_str());
					strcpy( schd_tab[s_tab[s_tab_idx][m]][CALCULATEDTIME] , origCalcTime[m].c_str());
				}
				for(int i = 0; i < counter; i++){
					if(strcmp(schd_tab[local_s_tab[i]][0],"")==0)//if it's an unassigned trip, reset eta.
						strcpy(schd_tab[local_s_tab[i]][29],"");
				}

				//  if(DEBUG == 1) gse <<  oResult << "\n\n";

				a_route = schd_tab[local_s_tab[SEGSTART]][0];

				UPDATE_REVERSE_CALCULATE_BATCH(counter,local_s_tab,a_route);

				return false;
			}




			if(oResult == "")   if(DEBUG == 1) gse << "The indicies are inserted after " << indafter1 << " and " << indafter2  << " and the segment is " << p_td_segmentid << " with tripid " << tripid1db[0] <<endl;
			for(int k = 0; k < counter; k++){
				//strcpy( schd_tab[local_s_tab[k]][0] ,schd_tab[local_s_tab[SEGSTART]][0]);
				//strcpy( schd_tab[local_s_tab[k]][6] , distholder[k].c_str());
			}

			if(oResult == ""){
				oResult = "Impact: On time";
				routeFound = true;
			}


		}


	}

	//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
	if(DEBUG == 1) gse << "Returning " << endl;
	return routeFound;
}










int checkforlatetripsrecalc(int counter, int * local_s_tab, int insertionstart){


	int p_WHEELLOAD1;
	int p_AMBLOAD1;
	int p_MAXEARLYDROPOFFFACTOR1;
	int p_DIALRIDEEARLYPICKFACTOR1;
	int p_DIALRIDELATEPICKFACTOR1;
	int p_OTHEREARLYPICKFACTOR1;
	int p_OTHERLATEPICKFACTOR1;
	string IGNOREPUTIMES1;
	int p_SHORTBREAK1;
	int p_LUNCHBREAK1;
	int p_PROXIMITYFACTOR1;
	int a_mediumshortdistance1;
	int a_mediumlongdistance1;
	int a_shorttriptime1;
	int a_longtriptime1;
	int a_mediumtriptime1;
	int a_extra_loadtime1;
	bool ontime = true;
	string ZONE_DESCR1;
	string IGNORE_DEPOTS_CUTOFF1;

	//  if(DEBUG == 1) gse << "checking late and early factors " <<  p_DIALRIDEEARLYPICKFACTOR[0] << " " <<p_DIALRIDELATEPICKFACTOR[0] << endl;


	//   if(DEBUG == 1) gse << "made it2 " << endl;



	bool routeFound = false;
	string a_route;

	//   if(DEBUG == 1) gse << "made it2 " << counter << endl;


	int s_tab_idx;

	if(counter > 0){
		//   if(DEBUG == 1) gse << "COUNTER " << counter << endl;
		if(DEBUG == 1) gse <<"Stop  prom time    eta   etd     dist ttime stoptype    wc    amb \t esc"<< endl;
	}
	std::tuple<string,int,int,int,int,double,string,string,double,int,string,int, int,int,int>  varHolder;
	string p_customer;
	bool notFound;
	int f1 = 0;
	int f2 = 0;


	std::string  promisedtime1;
	int prom_time;
	std::string est_traveltime1;
	std::string arrivetime1;
	std::string departtime1 ;
	std::string perftime1 ;
	int p_perf_time;
	std::string starttime1 ;
	std::string endtime1;
	std::string timetonextstop1 ;
	std::string eta1 ;
	int eta;
	std::string etd1; /// fix this hack in get next token
	int etd;
	std::string  lat1  ;
	std::string lon1   ;
	std::string lat2 ;
	std::string lon2;
	/// fix this  p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
	///OffLoaded   , p_trip_type ,    p_hack in get next token
	std::string  amb_occ1 ;
	std::string wc_occ1 ;
	int cs_cap = 0;
	int bs_cap = 0;
	std::string amb_cap1 ;
	std::string wc_cap1 ; /// fix this hack in get next token
	int p_amb_occ;
	int p_wc_occ;
	int p_cs_occ;
	int p_bs_occ;
	int p_grp_cnt_wc;
	int p_grp_cnt_amb;
	int s_trip_appt_time = 0;
	int p_latency = 0;
	int p_prev_stop_num;
	int p_prev_perf_time;
	int OffLoaded;
	string p_trip_type ;
	string p_spl_other_desc ;
	int last_wc_occ = 0, last_cs_occ = 0, last_bs_occ = 0;
	int last_amb_occ = 0;
	int last_dep_time ;
	int last_arr_time ;
	int tot_driv_time = 0;
	double tot_miles = 0;
	string p_latestoptime ="";
	string p_earlystoptime= "";
	double p_disttonextstop = 0.0;
	int p_timetonextstop = 0;
	string p_name ;
	string p_return_trip ;
	string p_stop_type ;
	string p_disability = "" ;
	int p_esc;
	string p_td_segmentid = "";
	int stopnum1;
	int p_stop_num;
	int p_early_morning_factor = 0;
	string p_street_by_street = "T";
	string p_citytown;
	string time_zone2 = "*";
	string time_zone;// = "*";
	int petaint;
	string rteStr;
	double disttrav;
	string grp_cnt_amb;
	string grp_cnt_wc;
	string dist;
	string p_promised_time;
	string p_eta;
	string p_etd;
	string capacity;
	string times;
	string prev_perftime1,prev_eta1,prev_etd1, prev_amb_occ1, prev_wc_occ1;
	int prev_eta,prev_etd,prev_p_perf_time;
	//int index;
	//int cnt = 0;
	double disttrav2;
	double prev_distance = 0;
	int SEGSTART = 0;
	//bool recalc = false;



	string indafter1;string indafter2;


	string pueta;
	string doeta;
	string disttravpu;
	string disttravdo;
	string pustp;
	string dostp;
	string puetd;
	string doetd;
	string latlon1;
	string latlon2;
	string latlon3;
	string latlon4;
	string oResult;
	int actualTT = 0;
	string distholder[counter];
	string origdistholder[MAXSTOPS];
	string origetaholder[MAXSTOPS];
	bool finished = false;
	string route = schd_tab[local_s_tab[0]][0];
	int routeint = (int)to_number(route.substr(1,route.length()));
	int aStp = 0;//first stop to be inserted.

	int AGRPCOUNTER = 0;
	int APRVGRPCOUNTER = 0;
	string p_prev_promised_time = "0000A";
	int timetonextstop2 = 0;






	create_group(local_s_tab,counter);

	int grouptraveltimeallowance[MAXTRIPIDX];


	for(int y = 0; y < MAXTRIPIDX; y++){
		grouptraveltimeallowance[y] = 0;
	}
	int extratraveltime = 0;
	int groupid = 1;
	bool secondpassinsertedtrip = false;

	for(int y = 0; y < counter;y++){

		string groupmark = schd_tab[local_s_tab[y]][GRPIDX];


		if(strcmp(schd_tab[local_s_tab[y]][2],MAXSTOPNUM[0])!=0){
			if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"D")==0 && groupmark!= "" ){
				//strcpy(schd_tab[local_s_tab[y]][GRPIDX],to_string(groupid).c_str());
				//strcpy(schd_tab[(int)to_number(schd_tab[local_s_tab[y]][PICKUPIDX])][GRPIDX],to_string(groupid).c_str());
				int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
				grouptraveltimeallowance[grpnumber] = grouptraveltimeallowance[grpnumber] + EXTRAGRPTT[0];
			}
			if(y+1 < counter && strcmp(schd_tab[local_s_tab[y]][7],"D")==0 && strcmp(schd_tab[local_s_tab[y+1]][7],"P")==0 && groupmark!= "" ){
				groupid++;
			}
		}

	}

	//bool isVol = isVolSegment(schd_tab[local_s_tab[SEGSTART]][0], schd_tab[local_s_tab[SEGSTART]][1],schd_tab[local_s_tab[SEGSTART]][14]);
	getCS_CY_cap(cs_cap, bs_cap,schd_tab[local_s_tab[SEGSTART]][SEGMENTTYPE]);


	for(int i = 0; i < counter; i++)
	{




		//  if(DEBUG == 1) gse << "i is " << i << endl;

		promisedtime1 = schd_tab[local_s_tab[i]][4];
		prom_time =(int)to_number(promisedtime1);
		//   if(DEBUG == 1) gse << "Promise time1 " << prom_time << endl;
		p_promised_time = itms_minutes_to_ampm(prom_time);
		est_traveltime1 = schd_tab[local_s_tab[i]][22];
		arrivetime1 =schd_tab[local_s_tab[i]][23];
		arrivetime1 = padStr( arrivetime1);
		departtime1 =schd_tab[local_s_tab[i]][24];
		departtime1 = padStr(departtime1);
		perftime1 = schd_tab[local_s_tab[i]][25];
		//perftime1 = padStr(perftime1);
		p_perf_time = (int)to_number(perftime1);
		starttime1 = schd_tab[local_s_tab[i]][26];
		starttime1  = padStr(starttime1 );
		endtime1 = schd_tab[local_s_tab[i]][27];
		endtime1 = padStr(endtime1);
		s_trip_appt_time = (int)to_number(endtime1);
		timetonextstop1 = schd_tab[local_s_tab[i]][28];
		eta1 = schd_tab[local_s_tab[i]][29];
		//   if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << "s_tab value  " << local_s_tab[i] <<  endl;
		eta = (int)to_number(eta1);
		//   if(DEBUG == 1) gse << "eat and int " << eta << endl;
		eta1 = itms_minutes_to_ampm(eta);
		//  if(DEBUG == 1) gse << "eat1 and int 1" << eta1 << endl;
		etd1 = schd_tab[local_s_tab[i]][30]; /// fix this hack in get next token
		etd = (int)to_number(etd1);
		etd1 = itms_minutes_to_ampm(etd);
		//temp = schd_tab[local_s_tab[i]][10];
		lat1 =  schd_tab[local_s_tab[i]][10];
		lon1 =  schd_tab[local_s_tab[i]][37];
		lat2 =  schd_tab[local_s_tab[i]][38];

		lon2 = schd_tab[local_s_tab[i]][39]; /// fix this hack in get next token
		// temp = schd_tab[local_s_tab[i]][12];
		amb_occ1 =  schd_tab[local_s_tab[i]][31];
		wc_occ1 =  schd_tab[local_s_tab[i]][32];
		p_cs_occ = to_number(schd_tab[local_s_tab[i]][CS_OCC]);
		p_bs_occ =to_number(schd_tab[local_s_tab[i]][BS_OCC]);
		amb_cap1 =  schd_tab[local_s_tab[SEGSTART]][33];
		//temp = temp+",";
		wc_cap1 =  schd_tab[local_s_tab[SEGSTART]][34]; /// fix this hack in get next token
		grp_cnt_amb = schd_tab[local_s_tab[i]][35];
		p_grp_cnt_amb = (int)to_number(grp_cnt_amb);
		grp_cnt_wc = schd_tab[local_s_tab[i]][36];
		p_grp_cnt_wc = (int)to_number(grp_cnt_wc);

		p_disability = schd_tab[local_s_tab[i]][12];
		//p_amb_occ = to_number(amb_occ1);
		//p_wc_occ = to_number(wc_occ1);
		p_trip_type = schd_tab[local_s_tab[i]][8];
		p_spl_other_desc = schd_tab[local_s_tab[i]][9];
		//last_dep_time = prom_time;
		//last_arr_time = prom_time;
		p_name = schd_tab[local_s_tab[i]][14];
		p_return_trip = schd_tab[local_s_tab[i]][18];
		p_stop_type = schd_tab[local_s_tab[i]][7];
		p_esc = (int)to_number(schd_tab[local_s_tab[i]][13]);
		p_stop_num = (int)to_number(schd_tab[local_s_tab[i]][2]);
		p_td_segmentid = "STEST";
		//    if(DEBUG == 1) gse << "The segment is  " << p_td_segmentid << " " <<  schd_tab[local_s_tab[SEGSTART]][0] << endl;
		//  if(DEBUG == 1) gse << "STop num " << p_stop_num<< endl;
		prev_distance = 0;
		if (p_stop_num == 1){
			last_dep_time = prom_time;
			last_arr_time = prom_time;

		}
		if(p_stop_num != 1){
			prev_distance = to_number( schd_tab[local_s_tab[i-1]][6]);
			timetonextstop2 = to_number( schd_tab[local_s_tab[i-1]][28]);
			disttrav = prev_distance;
		}
		/*  if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ){//strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ){
                            prev_distance = distances[f1];
                            f1++;
                           if(DEBUG == 1) gse << "Prev distance inserted trip " << prev_distance << " " <<  schd_tab[local_s_tab[i]][3] << endl;
                            }
                            else{
                             prev_distance = to_number( schd_tab[local_s_tab[i-1]][6]);
                            //   if(DEBUG == 1) gse << "Prev distance non inserted" << prev_distance << " " <<  schd_tab[local_s_tab[i]][3] << endl;
                            }
                        }
                       if(strcmp(schd_tab[local_s_tab[i]][0], "")==0 || strcmp(schd_tab[local_s_tab[i+1]][0], "")==0 ) {
                          //   if(DEBUG == 1) gse << " Using distance " << distances[f2] << endl;
                        disttrav = distances[f2];
                        distholder[i] = to_string(disttrav);
                        f2++;
                       }
                       else{
                           distholder[i] = schd_tab[local_s_tab[i]][6];
                       }*/

		//     if(DEBUG == 1) gse << "The distance is " << distholder[i] << " " << i <<  endl;

		//  if(DEBUG == 1) gse << "Disttrav " << prev_distance << endl;

		p_citytown =  schd_tab[local_s_tab[i]][11];


		//if (aStp == 0 && strcmp(schd_tab[local_s_tab[i]][0],"")==0)
		// aStp = (int)to_number(schd_tab[local_s_tab[i]][2]);
		int p_WHEELLOAD1;

		int p_AMBLOAD1;
		int p_MAXEARLYDROPOFFFACTOR1;
		int p_DIALRIDEEARLYPICKFACTOR1;
		int p_DIALRIDELATEPICKFACTOR1;
		int p_OTHEREARLYPICKFACTOR1;
		int p_OTHERLATEPICKFACTOR1;
		string IGNOREPUTIMES1;
		int p_SHORTBREAK1;
		int p_LUNCHBREAK1;
		int p_PROXIMITYFACTOR1;
		int a_mediumshortdistance1;
		int a_mediumlongdistance1;
		int a_shorttriptime1;
		int a_longtriptime1;
		int a_mediumtriptime1;
		int a_extra_loadtime1;
		string ZONE_DESCR1;
		string IGNORE_DEPOTS_CUTOFF1;

		int grouppickupcnt = 0;

		string groupmark = schd_tab[local_s_tab[i]][GRPIDX];
		if(groupmark != ""){
			int grpnumber = (int)to_number(getNextToken(&groupmark, "^"));
			grouppickupcnt = grouptraveltimeallowance[grpnumber] - EXTRAGRPTT[0];
			//  if(DEBUG == 1) gse << "Extra travel time " << extratraveltime << endl;
		}

		string pReturn_trip = schd_tab[local_s_tab[i]][18];
		string  pDisability = schd_tab[local_s_tab[i]][12];
		string p_trip_type1 = schd_tab[local_s_tab[i]][8];


		set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
				p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
				a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip,  pDisability,p_trip_type1);


		double estdisttrip = to_number(schd_tab[local_s_tab[i]][21]);

		int aAllowedTT;



		int allowedDW;
		double esttime = to_number(schd_tab[local_s_tab[i]][22]);

		if(estdisttrip < a_mediumshortdistance1){
			aAllowedTT = a_shorttriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_SML[0]);
		}
		else if ((estdisttrip >= a_mediumshortdistance1) && (estdisttrip < a_mediumlongdistance1)){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_MED[0]);
			aAllowedTT = a_mediumtriptime1 + extratraveltime;
		}
		else{
			aAllowedTT = a_longtriptime1 + extratraveltime;
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
		}

		if((int)to_number(est_traveltime1) > a_longtriptime1 /*|| to_number(endtime1) == 0*/){
			allowedDW = (int)ceil(esttime*DW_VARIANCE_CHECK_LNG[0]);
			aAllowedTT = (int)to_number(est_traveltime1) * XTRTRAVTIME[0];
		}
		int p_perf_time;
		string pDisposition = schd_tab[local_s_tab[i]][DISPOSITION];
		set_p_perf_time(pDisposition,pDisability, p_perf_time, p_WHEELLOAD1,p_AMBLOAD1,a_extra_loadtime1 );



		int est_time;
		string tripid = schd_tab[local_s_tab[i]][3];
		tripid = tripid.substr(0,1);
		string endtime2;
		if(tripid == "S"){
			endtime2 =to_string( (int)itms_to_minutes(ampm2fullhrs(p_promised_time)));
		}

		if(p_stop_type == "P"){
			if((int)to_number(starttime1)!= 0)
				est_time = (int)to_number(starttime1);
			else{
				est_time =  (int)to_number(endtime2) - (int)to_number(est_traveltime1);
			}
		}
		else{
			if((int)to_number(endtime2)!= 0)
				est_time = (int)to_number(endtime2);
			else{

				est_time = (int)to_number(starttime1) + (int)to_number(est_traveltime1);
			}
		}

		string timezonetime = itms_minutes_to_ampm(est_time);
		//p_eta = eta1;
		if(p_stop_num ==1){
			p_eta = p_promised_time;
			p_etd = etd1;
		}
		else{
			p_eta = eta1;
			p_etd = etd1;
		}
		string route = schd_tab[local_s_tab[i]][0];
		if( (route == "" || timeZones(p_eta, timezonetime) != timeZones(timezonetime,p_eta))  && !secondpassinsertedtrip){time_zone = timeZones(p_eta, timezonetime); secondpassinsertedtrip = true;}
		else{  if(F_GET_TRAVEL_TIME (1.0 , timeZones(p_eta, timezonetime), "*") > F_GET_TRAVEL_TIME (1.0 , timeZones(timezonetime,p_eta), "*")){
			time_zone = timeZones(p_eta, timezonetime);secondpassinsertedtrip = false;
		}
		else{
			time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(timezonetime, p_eta);secondpassinsertedtrip = false;
		}
		//time_zone = timeZones(p_eta, timezonetime);
		string timezone2;
		if (p_stop_num != 1) {
			if (!isSameLocation(local_s_tab[i],local_s_tab[i-1]))
				timezone2 = "#"; // not the same lat/long
			else
				timezone2 = "*";
		}







		//  if(DEBUG == 1) gse << "ETa 1" << p_eta << " " << p_etd << endl;
		//  if(DEBUG == 1) gse << "1. I am here " << prev_distance << endl;

		varHolder = itms_calcroute( arrivetime1, departtime1,timetonextstop2,  rteStr ,   p_citytown ,     p_street_by_street ,     p_eta  ,    p_promised_time ,     p_perf_time ,   p_early_morning_factor ,  p_stop_num ,
				p_td_segmentid,  p_wc_occ   , p_amb_occ,   p_esc  ,  p_disability  , p_stop_type  ,  p_WHEELLOAD[0] ,  p_AMBLOAD[0] ,
				p_customer ,   p_return_trip  ,  p_DIALRIDEEARLYPICKFACTOR[0]  ,  p_DIALRIDELATEPICKFACTOR[0] ,  p_PROXIMITYFACTOR[0],  p_SHORTBREAK[0]  ,
				p_LUNCHBREAK[0]   ,   p_MAXEARLYDROPOFFFACTOR[0]  , p_OTHEREARLYPICKFACTOR[0]  ,  p_OTHERLATEPICKFACTOR[0] ,   p_name    ,
				p_timetonextstop , p_disttonextstop ,  p_earlystoptime ,  p_latestoptime  ,  tot_miles ,   tot_driv_time  ,   p_etd  ,  last_dep_time ,  last_arr_time , last_amb_occ ,  last_wc_occ ,  p_spl_other_desc ,
				OffLoaded   , p_trip_type ,    p_prev_perf_time ,   p_prev_stop_num , p_latency   ,  s_trip_appt_time ,  p_grp_cnt_amb ,
				p_grp_cnt_wc,  ignorepu[0],  IGNORE_DEPOTS_CUTOFF[0], time_zone, timezone2,starttime1,p_cs_occ,p_bs_occ,last_cs_occ,last_bs_occ,pDisposition);

		//    if(DEBUG == 1) gse << "2. I am here " << std::get<4>(varHolder) << endl;

		p_eta = std::get<0>(varHolder);
		p_wc_occ=std::get<1>(varHolder);
		p_amb_occ=std::get<2>(varHolder);
		p_esc=std::get<3>(varHolder);
		p_timetonextstop=std::get<4>(varHolder);
		p_disttonextstop=std::get<5>(varHolder);
		p_earlystoptime=std::get<6>(varHolder);
		p_latestoptime=std::get<7>(varHolder);
		tot_miles=std::get<8>(varHolder);
		tot_driv_time=std::get<9>(varHolder);
		p_etd=std::get<10>(varHolder);
		OffLoaded=std::get<11>(varHolder);
		p_perf_time = std::get<12>(varHolder);
		p_cs_occ = std::get<13>(varHolder);
		p_bs_occ = std::get<14>(varHolder);


		if(!secondpassinsertedtrip){
			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) - p_perf_time);

			if (p_stop_num != 1 && p_stop_num != (int)to_number(MAXSTOPNUM[0])) {
				if (timetonextstop2 == 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)

					AGRPCOUNTER = AGRPCOUNTER + 1;
				else{
					if (AGRPCOUNTER > 0  && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0)
					{
						APRVGRPCOUNTER = AGRPCOUNTER + 1;
					}
					AGRPCOUNTER = 0;
				}


				if(p_disability.find("WC",0) == string::npos && p_disability.find("SC",0) == string::npos && p_disability.find("XLT",0) == string::npos){


					if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0){

						p_perf_time = p_perf_time / AGRPCOUNTER;
					}


					if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

						p_perf_time = p_perf_time / APRVGRPCOUNTER;
						APRVGRPCOUNTER = 0;
					}
				}
				else{

					if (strcmp(ACALCULATE_GCOUNT_WC[0],"Y")==0){


						if (AGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / AGRPCOUNTER;
						}

						if (APRVGRPCOUNTER > 0 && strcmp(schd_tab[local_s_tab[i]][7],schd_tab[local_s_tab[i-1]][7])==0) {

							p_perf_time = p_perf_time / APRVGRPCOUNTER;
							APRVGRPCOUNTER = 0;
						}
					}
				}

			}
			p_etd =  itms_minutes_to_ampm(itms_to_minutes (ampm2fullhrs (p_etd)) + p_perf_time);
		}

		//   if(DEBUG == 1) gse << "ETa 2" << p_eta << " " << p_etd << endl;

		//  if(DEBUG == 1) gse << "2. I am here " << schd_tab[local_s_tab[0]][0] << endl;


		//  if(DEBUG == 1) gse << " local " << schd_tab[local_s_tab[SEGSTART]][0] << " " << local_s_tab[SEGSTART] << endl;
		//  strcpy( schd_tab[local_s_tab[i]][0] ,schd_tab[local_s_tab[SEGSTART]][0]);



		//  if(DEBUG == 1) gse << "3. I am here " << schd_tab[local_s_tab[0]][0] << endl;


		// temp = temproute[i][4];

		prev_eta1 = to_string(itms_to_minutes (ampm2fullhrs (p_eta)));
		prev_eta = (int)to_number(prev_eta1);
		prev_eta1 = itms_minutes_to_ampm(prev_eta);

		if(secondpassinsertedtrip){  if(DEBUG == 1) gse << "REDOING" << endl; i--;continue;}

		prev_perftime1 = to_string(p_perf_time);
		prev_p_perf_time = (int)to_number(prev_perftime1);


		prev_etd1 = to_string(itms_to_minutes (ampm2fullhrs (p_etd)));
		prev_etd = (int)to_number(prev_etd1);
		prev_etd1 = itms_minutes_to_ampm(prev_etd);
		//temp = temproute[i][12];
		prev_amb_occ1 =  to_string(p_amb_occ);
		prev_wc_occ1 =  to_string(p_wc_occ);
		//amb_cap1 = getNextToken(&(temp), ",");
		//wc_cap1 =getNextToken(&(temp), ",");
		last_dep_time=prev_etd;
		last_arr_time=prev_eta;
		string prev_cs_occ = schd_tab[local_s_tab[i]][CS_OCC];
		string prev_bs_occ = schd_tab[local_s_tab[i]][BS_OCC];
		last_cs_occ=to_number(prev_cs_occ);
		last_bs_occ=to_number(prev_bs_occ);

		last_amb_occ=(int)to_number(prev_amb_occ1);
		last_wc_occ=(int)to_number(prev_wc_occ1);
		p_prev_perf_time = prev_p_perf_time;
		p_prev_stop_num = (int)to_number(schd_tab[local_s_tab[i]][2]);
		p_prev_promised_time = p_promised_time;
		/*if(temproute[i][20] == "0" && temproute[i-1][20] != "0"){
                               if(DEBUG == 1) gse << "Stop Num " << temproute[i-1][2] << endl;
                        temp = temproute[i-1][12];
                        getNextToken(&(temp), ",");
                        getNextToken(&(temp), ",");
                        amb_cap1 = getNextToken(&(temp), ",");
                        wc_cap1 =getNextToken(&(temp), ",");
                        }*/

		//   if(DEBUG == 1) gse << last_dep_time << endl;


		//  if(DEBUG == 1) gse << "4. I am here " << schd_tab[local_s_tab[0]][0] << endl;

		/*  if(local_s_tab[i] == puid && p_stop_num == aStp){
        indafter1 = schd_tab[local_s_tab[i-1]][20];
        pueta = p_eta;
         puetd = p_etd;
        disttravpu = to_string(disttrav);
        pustp = to_string(p_stop_num);
        latlon1 = schd_tab[local_s_tab[i-1]][10];
         latlon1= latlon1 +","+ schd_tab[local_s_tab[i-1]][37];
        latlon2 = schd_tab[local_s_tab[i+1]][10];
         latlon2= latlon2+ ","+ schd_tab[local_s_tab[i+1]][37];
        //indicies = temproute[i][20];
       //    if(DEBUG == 1) gse << indicies << endl;
    }





    if(local_s_tab[i] == puid && p_stop_num > aStp){
       doeta = p_eta;
       disttravdo = to_string(disttrav);
       dostp = to_string(p_stop_num);
       doetd = p_etd;
       if(p_stop_num == aStp +1)
        indafter2 = indafter1;
      else
        indafter2 = schd_tab[local_s_tab[i-1]][20];
         latlon3 = schd_tab[local_s_tab[i-1]][10];
         latlon3= latlon3 +","+ schd_tab[local_s_tab[i-1]][37];
         latlon4 = schd_tab[local_s_tab[i+1]][10];
         latlon4= latlon4+ ","+ schd_tab[local_s_tab[i+1]][37];


         actualTT = (itms_to_minutes (ampm2fullhrs (doeta)) - itms_to_minutes (ampm2fullhrs (puetd))); //flipped eta/etd
            if(DEBUG == 1) gse << "Actual travel time " << actualTT << endl;
    }
		 */




		bool changedeta = true;

		if(itms_to_minutes (ampm2fullhrs (p_eta)) != eta)
			changedeta = true;



		//actual travel time

		string tripid2 = schd_tab[local_s_tab[i]][3];
		string p_trip_type2 = schd_tab[local_s_tab[i]][8];

		if(strcmp(schd_tab[local_s_tab[i]][7],"D")==0 && (tripid2.substr(0,1) == "T" || tripid2.substr(0,1) == "R") && p_trip_type2 != "BRK" && p_trip_type2 != "LUNCH" && p_trip_type2 != "ADMIN"){

			int pickupid = (int)to_number(schd_tab[local_s_tab[i]][PICKUPIDX]);
			int doeta1 = (int)to_number(schd_tab[local_s_tab[i]][30])-(int)to_number(schd_tab[local_s_tab[i]][25]);
			int puetd1 = (int)to_number(schd_tab[pickupid][30]);
			int stopafter;

			for(int t = 0; t < counter; t++){
				if(local_s_tab[t] == pickupid){
					stopafter = local_s_tab[t+1];
					break;
				}
			}

			string pReturn_trip1 = schd_tab[pickupid][18];
			string pDisability1 = schd_tab[pickupid][12];
			string p_trip_type11 = schd_tab[pickupid][8];

			set_registry_values(  p_WHEELLOAD1,  p_AMBLOAD1,
					p_MAXEARLYDROPOFFFACTOR1, p_DIALRIDEEARLYPICKFACTOR1, p_DIALRIDELATEPICKFACTOR1, p_OTHEREARLYPICKFACTOR1,  p_OTHERLATEPICKFACTOR1,IGNOREPUTIMES1, p_SHORTBREAK1, p_LUNCHBREAK1,  p_PROXIMITYFACTOR1,  a_mediumshortdistance1, a_mediumlongdistance1, a_shorttriptime1,
					a_longtriptime1, a_mediumtriptime1, a_extra_loadtime1, ZONE_DESCR1,IGNORE_DEPOTS_CUTOFF1, pReturn_trip1,  pDisability1,p_trip_type11);
			int aLatepickup;

			if (pReturn_trip1 == "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}

			if((int)to_number(schd_tab[stopafter][30]) - (int)to_number(schd_tab[stopafter][25])  >= (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]) + (int)to_number(schd_tab[pickupid][CALCULATEDTIME])){

				puetd1 = (int)to_number(schd_tab[pickupid][4]) + aLatepickup+ (int)to_number(schd_tab[pickupid][25]);

				if(DEBUG == 1) gse << "Changing puetd to " << puetd1 << " " << (int)to_number(schd_tab[stopafter][30]) << "  " <<  (int)to_number(schd_tab[stopafter][25]) <<  endl;
			}


			actualTT = doeta1 - puetd1; //flipped eta/etd
			if(DEBUG == 1) gse << "Actual travel time of " << schd_tab[local_s_tab[i]][3] << " " << actualTT << endl;
		}

		else
			actualTT = 0;




		if(DEBUG == 1) gse << p_stop_num << " \t " << p_promised_time << " \t " << p_eta << " \t " << p_etd << " \t "  << setprecision(2) << prev_distance <<  "  \t" << p_timetonextstop << " \t " << p_stop_type << "\t wc occ" << p_wc_occ << " \t amb occ" << p_amb_occ << "\t" << p_cs_occ << "\t" << p_bs_occ << "\t" << p_esc << " " << arrivetime1 << " " << departtime1 << " " << p_trip_type << " " << schd_tab[local_s_tab[i]][20] << " " << " " <<schd_tab[local_s_tab[i]][42]<< " " << schd_tab[local_s_tab[i]][41] << " " << local_s_tab[i] << " end time: " << endtime1 << " trip id " <<schd_tab[local_s_tab[i]][3]  << " " << schd_tab[local_s_tab[i]][10] << " " << schd_tab[local_s_tab[i]][37]  <<  endl;


		//  if(DEBUG == 1) gse << "5. I am here " << schd_tab[local_s_tab[0]][0] << endl;
		//    if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;
		if(/*strcmp(USEREVERSECALC[0],"Y")!=0*/true){
			/*** 1. Check for WC violations ***/
			if (schd_tab[local_s_tab[i]][0] == "" && p_disability.find("WC") != string::npos && i >= insertionstart) {
				if (to_number(wc_cap1) == 0) {
					if(!finished){
						oResult = "NOK Cannot Assign WC Trip on Non-WC Vehicle: " + wc_cap1;
						//strcpy( schd_tab[local_s_tab[i]][0] ,"");

						a_route = schd_tab[local_s_tab[SEGSTART]][0];
						//    if(DEBUG == 1) gse << "1 " << a_route << endl;


						if(DEBUG == 1) gse <<  oResult << "\n\n";

						//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
						if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
							return local_s_tab[i-1];
						}
						else{
							return local_s_tab[i];
						}
					}
					finished = true;


				}
			} //general

			/*** 2. Check for Capacity Violation ***/
			if ((p_wc_occ> (int)to_number(wc_cap1) && i >= insertionstart) || (p_amb_occ > (int)to_number(amb_cap1) && i >= insertionstart)
					|| (p_cs_occ > cs_cap   && i >= insertionstart) || (p_bs_occ > bs_cap   && i >= insertionstart)) {
				//   if(DEBUG == 1) gse << "CAP" << amb_cap1 << " " <<wc_cap1 << endl;
				if(!finished){
					// string route = schd_tab[local_s_tab[1]][0];
					oResult = "NOK Capacity Violation when assigning Trip on Segment " + p_td_segmentid + " with capacities wc, amb " + wc_cap1 + " " + amb_cap1;
					//strcpy( schd_tab[local_s_tab[i]][0] ,"");

					a_route = schd_tab[local_s_tab[SEGSTART]][0];
					//  if(DEBUG == 1) gse << "2 " << a_route << endl;

					if(DEBUG == 1) gse <<  oResult <<"\n\n";
					//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
					if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
						return local_s_tab[i-1];
					}
					else{
						return local_s_tab[i];
					}
				}
				finished = true;


			} //per stop number


			int aLatepickup;

			if (p_return_trip == "Y"){
				aLatepickup = p_OTHERLATEPICKFACTOR1;
			}
			else{
				aLatepickup = p_DIALRIDELATEPICKFACTOR1;
			}
			if(changedeta){

				/***3. Pickup Window violation *****/
				if (true && (p_stop_type == "P") && starttime1 != "0" && starttime1 != "" &&   starttime1 != "0000" && (i >= insertionstart )) {

					if( itms_to_minutes(ampm2fullhrs(p_eta))  > (int)to_number(starttime1) + aLatepickup+ floor((RELAXCONSTRAINTS[0] - 1)*50))//p_DIALRIDELATEPICKFACTOR )
					{
						//   if(DEBUG == 1) gse << "Starttime " << itms_minutes_to_ampm(to_number(starttime1)) << endl;
						// oDropETA = " Dropoff ETA:  ;" ;
						if(!finished){
							string tripid = schd_tab[local_s_tab[i]][3];
							oResult = "Impact: " + tripid +" Pickup is outside the window with start time: " + itms_minutes_to_ampm(((int)to_number(starttime1)+ aLatepickup)); //oResult
							//  strcpy( schd_tab[local_s_tab[i]][0] ,"");

							a_route = schd_tab[local_s_tab[SEGSTART]][0];
							//   if(DEBUG == 1) gse << "3 " << a_route << endl;
							if(strcmp(USEREVERSECALC[0],"Y")!=0){

								if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
								//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

								if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
									return local_s_tab[i-1];
								}
								else{
									return local_s_tab[i];
								}
							}
							else{
								ontime = false;
							}

						}
						finished = true;

					}

				}


				if(p_stop_num == (int)to_number(MAXSTOPNUM[0])){
					endtime1 = to_string((int)itms_to_minutes(ampm2fullhrs(p_promised_time))); // to make sure segments do not go beyond the end'
					//  if(DEBUG == 1) gse << "promtime " << endtime1 << " " << p_promised_time << " " << (int)itms_to_minutes(ampm2fullhrs(p_promised_time)) << endl;
				}
				/*** 4. Check if someone is late for Appointment ***/
				/** Added condition if the appt. time is not null and return_trip = Y **/
				if (true && ((p_stop_type == "D") && (endtime1) != "0" && (endtime1) != "" && (endtime1) != "0000"&& (i >= insertionstart)))
				{



					if((((itms_to_minutes(ampm2fullhrs(p_eta))) > /*12 +*/ (int)to_number(endtime1)+ floor((RELAXCONSTRAINTS[0] - 1)*50)) && prom_time != 0))
					{
						if(DEBUG == 1) gse << "Endtime " << endtime1 << endl;
						if(!finished){
							string tripid = schd_tab[local_s_tab[i]][3];
							oResult = "Impact: " +  tripid + " will be late: " + to_string((int)itms_to_minutes(ampm2fullhrs(p_eta)) - (int)to_number(endtime1) ) +
									" minutes for the " + itms_minutes_to_ampm((int)to_number(endtime1)) + " Appointment";
							// strcpy( schd_tab[local_s_tab[i]][0] ,"");
							if(DEBUG == 1) gse <<   oResult <<"\n\n";

							a_route = schd_tab[local_s_tab[SEGSTART]][0];
							if(strcmp(USEREVERSECALC[0],"Y")!=0){

								if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
								//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

								if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
									return local_s_tab[i-1];
								}
								else{
									return local_s_tab[i];
								}
							}
							else{
								ontime = false;
							}
						}
						finished = true;
					}
				}


				/**** 5. Check if it exceeds the Travel Time ****/
				if((actualTT > aAllowedTT+ floor((RELAXCONSTRAINTS[0] - 1)*50) /*60*/ && actualTT > 0) && i >= insertionstart){//} && (p_spl_other_desc.find("LP") == std::string::npos))  {
					if(!finished){
						string tripid = schd_tab[local_s_tab[i]][3];
						oResult = "Impact: Travel Time Violation on Trip: " + tripid  + " TT: " + to_string(actualTT) + " Allowed: " + to_string(aAllowedTT) + " dist " + to_string(estdisttrip) + " Seg: " + schd_tab[local_s_tab[i]][0] + "\n";
						// strcpy( schd_tab[local_s_tab[i]][0] ,"");

						if(DEBUG == 1) gse << oResult;

						a_route = schd_tab[local_s_tab[SEGSTART]][0];
						if(strcmp(USEREVERSECALC[0],"Y")!=0){

							if(DEBUG == 1) gse <<   oResult << "\n\n"; // of inserted trip
							//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }

							if(strcmp(schd_tab[local_s_tab[i]][3],schd_tab[local_s_tab[i]][0])==0){
								return local_s_tab[i-1];
							}
							else{
								return local_s_tab[i];
							}
						}
						else{
							ontime = false;
						}

					}
					finished = true;

				}


			}

		}

		if(p_stop_num==(int)to_number(MAXSTOPNUM[0])){


			int  usereversefail = 0;
			if(strcmp(USEREVERSECALC[0],"Y")==0){
				usereversefail = reversecalclocal_returnindex(counter, local_s_tab, ontime);
			}
			if(usereversefail!=0){
				if(DEBUG == 1) gse << "There was a violation so reverse calcing!" << endl;
				//UPDATE_REVERSE_CALCULATE_BATCH(counter, local_s_tab);

				return usereversefail;


				//  if(DEBUG == 1) gse <<  oResult << "\n\n";
			}



			if( oResult == "")   if(DEBUG == 1) gse << "The indicies are inserted after " << indafter1 << " and " << indafter2  << " and the segment is " << p_td_segmentid    <<endl;


			if(oResult == ""){
				oResult = "Impact: On time";
				routeFound = true;
			}
			//for(int q = 0; q < counter; q++) { strcpy(schd_tab[local_s_tab[q]][GRPIDX],"");  }
			return 0;

		}


	}

	return 0 ;

}



int getTravTime(int tripidx, int do_aftershmid){



	double blat = to_number(schd_tab[tripidx][10]);
	double gridlat = to_number(schd_tab[do_aftershmid][10]);
	double blon = to_number(schd_tab[tripidx][37]);
	double gridlon = to_number(schd_tab[do_aftershmid][37]);
	double dist = ((blat - gridlat)*(blat - gridlat) + (blon - gridlon)*(blon - gridlon)) ;
	dist = sqrt(dist)*3959.0 * 3.1415/180;
	//double dist = (acos(1.0*sin(blat)*sin(gridlat)+cos(blat)*cos(gridlat)*cos(blon-gridlon)))*3959.87;
	//getTimeZone(env ,conn);
	string time_zone = timeZones(schd_tab[tripidx][29],itms_minutes_to_ampm((int)to_number(schd_tab[tripidx][4])));




	string running = "RUNNINGCALC";
	strcpy(shared_process_tab[WRITINGFB][0], running.c_str());

	int waitingforosrm = 0;
	int q;


	//if(strcmp(schd_tab[s_tab[i][g]][0], "")==0 || (strcmp(schd_tab[local_s_tab[g+1]][0], "")==0  && strcmp(schd_tab[s_tab[i][g]][2], MAXSTOPNUM[0])!=0) ){
	string lat1 = schd_tab[tripidx][10];
	string lon1 = schd_tab[tripidx][37];
	string lat2 = schd_tab[do_aftershmid][10];
	string lon2 = schd_tab[do_aftershmid][37];

	string osrm = lat1 + "," + lon1 + "," + lat2 + "," + lon2;

	for (int d = 0; d < MAXREQUESTS; d++)
	{

		if (requestIsEmpty(d))
		{
			//usleep(10);
			if (requestIsEmpty(d))
			{
				q = d;
				break;
			}
		}
		if (d + 1 == MAXREQUESTS)
			d = -1;
	}
	//  if(DEBUG == 1) gse << "q is " << q << endl;

	string function = "CalcDist";

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	char timebuffer[100];
	sprintf(timebuffer, "%s", asctime(&tm));
	string localtimestr = timebuffer;
	localtimestr.erase(std::remove(localtimestr.begin(), localtimestr.end(), '\n'), localtimestr.end());

	updateRequest(q, "getTravTime", "NUM");
	updateRequest(q, function, "FUNC");
	updateRequest(q, localtimestr, "TIMESTAMP");
	updateRequest(q, to_string(0), "ID");
	updateRequest(q, osrm, "LATLONG");
	updateRequest(q, to_string(tripidx), "TRIPIDX");

	waitingforosrm++;

	//}




	strcpy(shared_process_tab[WRITINGFB][0], "READY");
	int datafromosrm = 0;
	int timebetween = 0;
	while (true)
	{

		if (fetchRequest(q, "DISTANCE") != "" &&  fetchRequest(q, "TIME") != "" &&/*fetchRequest(q, "ID") == to_string(g) &&*/ fetchRequest(q, "NUM") == "getTravTime"&& fetchRequest(q, "FUNC") == "CalcDist")
		{
			timebetween = (int)to_number(fetchRequest(q, "TIME"));
			clearRequest(q);
			while(!requestIsEmpty(q)){
			}
			//f++;
			//g++;
			datafromosrm++;
			break;
		}


	}


	int trav_time = F_GET_TRAVEL_TIME (timebetween , time_zone, "*");

	//  if(DEBUG == 1) gse << "The time zone is : " << time_zone << " " << trav_time << " " << dist  << endl;




	return trav_time;
}


